#include "fatfs.h"


BOOL FsInitializeModule(VOID);


#define BYTES_PER_SECTOR				512
#define NUMBER_OF_DIR_ENTRIES			0xe0
#define CLUSTER_OFFSET					(0x21-2)

typedef struct _BPB {
	BYTE			BS_jmpBoot[3];
	BYTE			BS_OEMName[8];
	WORD			BPB_BytesPerSec;
	BYTE			BPB_SecPerClus;
	WORD			BPB_RsvdSecCnt;
	BYTE			BPB_NumFATs;
	WORD			BPB_RootEntCnt;
	WORD			BPB_TotSec16;
	BYTE			BPB_Media;
	WORD			BPB_FATSz16;
	WORD			BPB_SecPerTrk;
	WORD			BPB_NumHeads;
	DWORD			BPB_HiddSec;
	DWORD			BPB_TotSec32;
	BYTE			BS_DrvNum;
	BYTE			BS_Reserved1;
	BYTE			BS_BootSig;
	DWORD			BS_VolID;
	BYTE			BS_VolLab[11];
	BYTE			BS_FilSysType[8];
} BPB, *PBPB;

//루트 디렉토리 엔트리 구조체
typedef struct _DIRECTORY_ENTRY {
	
	BYTE	filename[8];
	BYTE	extension[3];
	BYTE	attribute;
	BYTE	reserved[10];
	WORD	time;
	WORD	date;
	WORD	cluster;
	DWORD	filesize;

} DIRECTORY_ENTRY, *PDIRECTORY_ENTRY;

typedef struct _FILE_CONTROL_BLOCK {
	
	BOOL	found;	//파일 시스템 내에서 파일을 찾았는지를 나타내는 변수

	BYTE	*pt_filename;	//파일의 이름
	DWORD	attribute;	//파일의 속성
	DWORD	filesize;	//파일의 크기

	WORD	cur_cluster;	//파일의 클러스터 번호
	DWORD	bytesread;
	BYTE	buffer[BYTES_PER_SECTOR];

} FILE_CONTROL_BLOCK, *PFILE_CONTROL_BLOCK;


static BOOL FspLoadFAT(void);
static BOOL FspLoadDirEntry(void);
static WORD FspGetNextCluster(WORD CurCluster);


#define FAT_SIZE		(BYTES_PER_SECTOR*9)
static BYTE m_FAT[FAT_SIZE];
static DIRECTORY_ENTRY m_DirEntry[NUMBER_OF_DIR_ENTRIES];


//파일시스템 초기화 함수
BOOL FsInitializeModule(VOID)
{

	//디스크의 FAT테이블을 읽어오는 함수
	if(!FspLoadFAT()) { 
		DbgPrint("FspLoadFAT() returned an error. \r\n");
		return FALSE;
	}

	//Root Directory Entry를 읽어와서 저장하는 함수
	if(!FspLoadDirEntry()) {
		DbgPrint("FspLoadDirEntry() returned an error. \r\n");
		return FALSE;
	}

	return TRUE;
}
//파일 시스템 내에서 파일을 탐색하는 함수
//Root Directory Entry 에서 인자로 넘어온 파일을 찾는 함수

KERNELAPI VOID FsGetFileList(FS_FILE_INFO_CALLBACK CallBack, PVOID Context)
{
	
	FILE_INFO FileInfo;
	int i, j, k;

	//Root Directory Entry 를 for문으로 탐색
	for(i=0; i<NUMBER_OF_DIR_ENTRIES; i++) {
		if(m_DirEntry[i].filename[0] == 0xe5 || m_DirEntry[i].filename[0] == NULL)
			continue;

		j=0;
		while(m_DirEntry[i].filename[j] != ' ' && j<8) {
			FileInfo.filename[j] = m_DirEntry[i].filename[j];
			j++;
		}
		FileInfo.filename[j++] = '.';

		k=j;
		j=0;
		while(m_DirEntry[i].extension[j] != ' ' && j<3) {
			FileInfo.filename[j+k] = m_DirEntry[i].extension[j];
			j++;
		}
		FileInfo.filename[j+k] = '\0';
		
		//fileinfo 구조체에 복사해 넣은 후, 우리가 찾고자하는 파일이 맞는지를 확인
		FileInfo.attribute = m_DirEntry[i].attribute;
		FileInfo.time = m_DirEntry[i].time;
		FileInfo.date = m_DirEntry[i].date;
		FileInfo.filesize = m_DirEntry[i].filesize;
		FileInfo.start_cluster = m_DirEntry[i].cluster;

		//Callback 함수에 Fileinfo 구조체의 첫 번째 인자를 넣어서 파일이 맞는지 확인
		if(!CallBack(&FileInfo, Context))
			break;
	}
}



static BOOL Fsp_of_callback(FILE_INFO *pFileInfo, PVOID Context)
{

	PFILE_CONTROL_BLOCK pContext = (PFILE_CONTROL_BLOCK)Context;

	if(!strcmp(pFileInfo->filename, pContext->pt_filename)) {
		pContext->cur_cluster = pFileInfo->start_cluster;
		pContext->filesize = pFileInfo->filesize;
		pContext->found = TRUE;
	return FALSE;
}

return TRUE;

}

KERNELAPI HANDLE FsOpenFile(BYTE *pFilename, DWORD Attribute)
{
	
	PFILE_CONTROL_BLOCK pt_block;

	//파일 이름 확인
	if(pFilename == NULL || strlen(pFilename) == 0)
		return NULL;
	strupr(pFilename);

	//메모리 할당
	pt_block = MmAllocateNonCachedMemory(sizeof(FILE_CONTROL_BLOCK));
	if(pt_block == NULL) return NULL;

	pt_block->found			= FALSE;
	pt_block->pt_filename	= pFilename;
	pt_block->attribute		= Attribute;
	pt_block->bytesread		= 0;

	//파일 시스템 내에서 파일을 탐색
	FsGetFileList(Fsp_of_callback, pt_block);
	if(!pt_block->found) {
		FsCloseFile((HANDLE)pt_block);
		return NULL;
	}

	//파일의 데이터를 FCB의 buffer로 읽어들인다.
	//pt_block->cur_cluster+CLUSTER_OFFSET ->우리가 찾고자 하는 데이터의 위치
	if(!FddReadSector(pt_block->cur_cluster+CLUSTER_OFFSET, 1, pt_block->buffer)) {
		FsCloseFile((HANDLE)pt_block);
		return NULL;
	}

	return (HANDLE)pt_block;
}


//파일을 닫는 함수
//FCB에 할당된 메모리 해체하는 함수
KERNELAPI BOOL   FsCloseFile(HANDLE FileHandle)
{
	
	MmFreeNonCachedMemory(FileHandle);

	return TRUE;

}

KERNELAPI DWORD  FsReadFile(HANDLE FileHandle, BYTE *pData, DWORD NumberOfBytesToRead)
{
	
	PFILE_CONTROL_BLOCK pt_block = (PFILE_CONTROL_BLOCK)FileHandle;
	DWORD bytes_read, bytes_to_read, cur_read_bytes;
	DWORD pos_of_userdata, pos_of_buffer;

	//인자로넘어온 파일의 핸들을 검사
	if(FileHandle == NULL || pData == NULL || NumberOfBytesToRead == 0) return 0;

	//파일의 크기를 통해 사용자가 읽으려는 바이트를 계산
	if(pt_block->filesize <= pt_block->bytesread) {
		return 0;
	} else if(pt_block->bytesread+NumberOfBytesToRead < pt_block->filesize) {
		bytes_to_read = NumberOfBytesToRead;
	} else {
		bytes_to_read = pt_block->filesize - pt_block->bytesread;
	}

	pos_of_userdata = 0; //인자를 넘겨준 버퍼의 offset
	bytes_read = 0; //파일에서 최종 읽어드린 바이트 수를 저장하는 변수

	//루프를 통래 읽어야 될 총 바이트를 다 읽을떄까지 반복
	while(bytes_to_read != 0) {
		pos_of_buffer = pt_block->bytesread % BYTES_PER_SECTOR;
		cur_read_bytes = BYTES_PER_SECTOR - pos_of_buffer;

		//FCB의 buffer에 남아있는 바이트 수를 넘겨받는다
		if(cur_read_bytes > bytes_to_read)
			cur_read_bytes = bytes_to_read;

		//복사 후 연산에 연산된 변구들을 업데이트
		memcpy((pData+pos_of_userdata), (pt_block->buffer+pos_of_buffer), cur_read_bytes);

		bytes_read += cur_read_bytes;
		bytes_to_read -= cur_read_bytes;
		pt_block->bytesread += cur_read_bytes;
		pos_of_userdata += cur_read_bytes;

		//다음 클러스터로 넘어가고, 디스크에서 다음섹터를 읽는다
		if(pt_block->bytesread%BYTES_PER_SECTOR)
			continue;

		//다음 클러스터가 Bad 클러스터일 경우 중단, 아닐경우 클러스트를 디스크로부터 buffer로 로딩
		pt_block->cur_cluster = FspGetNextCluster(pt_block->cur_cluster);
		if(pt_block->cur_cluster < 0x2 || pt_block->cur_cluster > 0xfef)
			break;
		if(!FddReadSector(pt_block->cur_cluster+CLUSTER_OFFSET, 1, pt_block->buffer))
			break;
	}

	return bytes_read;
}



//디스크의 FAT테이블을 읽어오는 함수
static BOOL FspLoadFAT(void)
{

	CrtPrintText("Reading FAT Table...\r\n");
	return FddReadSector(0x01, 9, m_FAT);
}

//Root Directory Entry를 읽어들이는 함수
static BOOL FspLoadDirEntry(void)
{

	CrtPrintText("Reading Directory Entries... \r\n");
	return FddReadSector(0x13, 14, (BYTE *)m_DirEntry);

}


//다음 클러스터 번호를 찾는 함수
static WORD FspGetNextCluster(WORD CurCluster)
{
	
	WORD cluster, fat_entry;

	//찾고자 하는 클러스터 번호가 홀수인지 짝수인지 검사
	//fat_entry를 찾는다
	if(CurCluster%2) { /* odd */
		fat_entry = ((CurCluster>>1)*3)+1;
	} else { /*even */
		fat_entry = ((CurCluster>>1)*3);
	}

	//fat_entry를 통해 m_FAT버퍼의 FAT테이블과 비트연산을 통해 클러스터 번홀를 찾는다
	cluster = (WORD)(m_FAT[fat_entry]);
	cluster |= ((WORD)(m_FAT[fat_entry+1]) << 8);

	if(CurCluster % 2)
		cluster >>= 4;

	else
		cluster &= 0x0fff;

	return cluster;

}