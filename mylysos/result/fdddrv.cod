; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	c:\Users\상우\Documents\카카오톡 받은 파일\MylysOS\fdddrv.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CH@MHIGPNEI@FddTurnOffMotor?$CI?$CJ?5returned?5an?5er@ ; `string'
PUBLIC	_FddInitializeDriver
EXTRN	_PsSetThreadStatus:PROC
EXTRN	_PsCreateThread:PROC
EXTRN	_PsCreateProcess:PROC
EXTRN	_CrtPrintf:PROC
_BSS	SEGMENT
_m_ThreadHandle DD 01H DUP (?)
_m_ProcessHandle DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CH@MHIGPNEI@FddTurnOffMotor?$CI?$CJ?5returned?5an?5er@
; File c:\users\상우\documents\카카오톡 받은 파일\mylysos\fdddrv.c
CONST	SEGMENT
??_C@_0CH@MHIGPNEI@FddTurnOffMotor?$CI?$CJ?5returned?5an?5er@ DB 'FddTurn'
	DB	'OffMotor() returned an error.', 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _FddInitializeDriver
_TEXT	SEGMENT
_FddInitializeDriver PROC				; COMDAT

; 64   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 65   : 
; 66   : 		//플로피 디스크의 모터를 OFF
; 67   : 	if(!FddpTurnOffMotor()) {

  00009	e8 00 00 00 00	 call	 _FddpTurnOffMotor
  0000e	85 c0		 test	 eax, eax
  00010	75 11		 jne	 SHORT $LN3@FddInitial

; 68   : 		DbgPrint("FddTurnOffMotor() returned an error.\r\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MHIGPNEI@FddTurnOffMotor?$CI?$CJ?5returned?5an?5er@
  00017	e8 00 00 00 00	 call	 _CrtPrintf
  0001c	83 c4 04	 add	 esp, 4

; 69   : 		return FALSE;

  0001f	33 c0		 xor	 eax, eax
  00021	eb 53		 jmp	 SHORT $LN4@FddInitial
$LN3@FddInitial:

; 70   : 	}
; 71   : 
; 72   : 	//플로피 디스크에서 수행해야 할 동작들을 처리하기 위한 프로세스 설정
; 73   : 	if(!PsCreateProcess(&m_ProcessHandle))

  00023	68 00 00 00 00	 push	 OFFSET _m_ProcessHandle
  00028	e8 00 00 00 00	 call	 _PsCreateProcess
  0002d	83 c4 04	 add	 esp, 4
  00030	85 c0		 test	 eax, eax
  00032	75 04		 jne	 SHORT $LN2@FddInitial

; 74   : 		return FALSE;

  00034	33 c0		 xor	 eax, eax
  00036	eb 3e		 jmp	 SHORT $LN4@FddInitial
$LN2@FddInitial:

; 75   : 
; 76   : 	//플로피 디스크에서 수행해야 할 동작들을 처리하기 위한 쓰레드 생성
; 77   : 	if(!PsCreateThread(&m_ThreadHandle, m_ProcessHandle, FddpJobProcessThread, NULL, DEFAULT_STACK_SIZE, FALSE))

  00038	6a 00		 push	 0
  0003a	68 00 00 01 00	 push	 65536			; 00010000H
  0003f	6a 00		 push	 0
  00041	68 00 00 00 00	 push	 OFFSET _FddpJobProcessThread
  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _m_ProcessHandle
  0004b	50		 push	 eax
  0004c	68 00 00 00 00	 push	 OFFSET _m_ThreadHandle
  00051	e8 00 00 00 00	 call	 _PsCreateThread
  00056	83 c4 18	 add	 esp, 24			; 00000018H
  00059	85 c0		 test	 eax, eax
  0005b	75 04		 jne	 SHORT $LN1@FddInitial

; 78   : 		return FALSE;

  0005d	33 c0		 xor	 eax, eax
  0005f	eb 15		 jmp	 SHORT $LN4@FddInitial
$LN1@FddInitial:

; 79   : 	PsSetThreadStatus(m_ThreadHandle, THREAD_STATUS_READY);

  00061	6a 02		 push	 2
  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR _m_ThreadHandle
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _PsSetThreadStatus
  0006e	83 c4 08	 add	 esp, 8

; 80   : 
; 81   : 	return TRUE;

  00071	b8 01 00 00 00	 mov	 eax, 1
$LN4@FddInitial:

; 82   : 
; 83   : 
; 84   : }

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_FddInitializeDriver ENDP
_TEXT	ENDS
PUBLIC	_Fdd_IRQ_Handler
_BSS	SEGMENT
_m_FddInterruptOccurred DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
_BSS	ENDS
;	COMDAT _Fdd_IRQ_Handler
_TEXT	SEGMENT
_Fdd_IRQ_Handler PROC					; COMDAT

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 89   : 
; 90   : 	
; 91   : 		m_FddInterruptOccurred=TRUE;

  00009	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _m_FddInterruptOccurred, 1

; 92   : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_Fdd_IRQ_Handler ENDP
_TEXT	ENDS
EXTRN	_WRITE_PORT_UCHAR:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _FddpTurnOffMotor
_TEXT	SEGMENT
_FddpTurnOffMotor PROC					; COMDAT

; 109  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 110  : 
; 111  : 		WRITE_PORT_UCHAR((PUCHAR)FDD_DOR_PORT, 0x00);

  00009	6a 00		 push	 0
  0000b	68 f2 03 00 00	 push	 1010			; 000003f2H
  00010	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00015	83 c4 08	 add	 esp, 8

; 112  : 		return TRUE;

  00018	b8 01 00 00 00	 mov	 eax, 1

; 113  : 
; 114  : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_FddpTurnOffMotor ENDP
_TEXT	ENDS
EXTRN	_HalTaskSwitch:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _FddpJobProcessThread
_TEXT	SEGMENT
_job_item$ = -16					; size = 15
_StartContext$ = 8					; size = 4
_FddpJobProcessThread PROC				; COMDAT

; 240  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN3@FddpJobPro:

; 241  : 
; 242  : 		FDD_JOB_ITEM job_item;
; 243  : 
; 244  : 		while(1) {

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	85 c0		 test	 eax, eax
  00010	74 40		 je	 SHORT $LN2@FddpJobPro

; 245  : 			if(!FddpPopJobItem(&job_item)) {

  00012	8d 45 f0	 lea	 eax, DWORD PTR _job_item$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _FddpPopJobItem
  0001b	83 c4 04	 add	 esp, 4
  0001e	85 c0		 test	 eax, eax
  00020	75 07		 jne	 SHORT $LN1@FddpJobPro

; 246  : 				HalTaskSwitch();

  00022	e8 00 00 00 00	 call	 _HalTaskSwitch

; 247  : 				continue;

  00027	eb e0		 jmp	 SHORT $LN3@FddpJobPro
$LN1@FddpJobPro:

; 248  : 			}
; 249  : 
; 250  : 			FddpReadWriteSector(job_item.type, job_item.sector, job_item.numbers_of_sectors, job_item.pt_data);

  00029	8b 45 f7	 mov	 eax, DWORD PTR _job_item$[ebp+7]
  0002c	50		 push	 eax
  0002d	8a 4d f6	 mov	 cl, BYTE PTR _job_item$[ebp+6]
  00030	51		 push	 ecx
  00031	66 8b 55 f4	 mov	 dx, WORD PTR _job_item$[ebp+4]
  00035	52		 push	 edx
  00036	8b 45 f0	 mov	 eax, DWORD PTR _job_item$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _FddpReadWriteSector
  0003f	83 c4 10	 add	 esp, 16			; 00000010H

; 251  : 			PsSetThreadStatus(job_item.thread, THREAD_STATUS_READY);

  00042	6a 02		 push	 2
  00044	8b 45 fb	 mov	 eax, DWORD PTR _job_item$[ebp+11]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _PsSetThreadStatus
  0004d	83 c4 08	 add	 esp, 8

; 252  : 
; 253  : 		
; 254  : 		}

  00050	eb b7		 jmp	 SHORT $LN3@FddpJobPro
$LN2@FddpJobPro:

; 255  : 
; 256  : 		return 0;

  00052	33 c0		 xor	 eax, eax

; 257  : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_FddpJobProcessThread ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _FddpReadWriteSector
_TEXT	SEGMENT
_i$ = -12						; size = 4
_sector$ = -8						; size = 1
_track$ = -7						; size = 1
_head$ = -6						; size = 1
_drive$ = -5						; size = 1
_pDMAAddr$ = -4						; size = 4
_JobType$ = 8						; size = 4
_Sector$ = 12						; size = 2
_NumbersOfSectors$ = 16					; size = 1
_pData$ = 20						; size = 4
_FddpReadWriteSector PROC				; COMDAT

; 176  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 177  : 
; 178  : 		BYTE *pDMAAddr = (BYTE *)0x00000000;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pDMAAddr$[ebp], 0

; 179  : 		BYTE drive, head, track, sector;
; 180  : 		int i;
; 181  : 
; 182  : 		//디스크에 쓰기는 구현 X
; 183  : 		if(JobType == FDD_WRITE_SECTOR)

  00010	83 7d 08 01	 cmp	 DWORD PTR _JobType$[ebp], 1
  00014	75 07		 jne	 SHORT $LN13@FddpReadWr

; 184  : 			return FALSE;

  00016	33 c0		 xor	 eax, eax
  00018	e9 9f 01 00 00	 jmp	 $LN14@FddpReadWr
$LN13@FddpReadWr:

; 185  : 
; 186  : 		drive = 0;

  0001d	c6 45 fb 00	 mov	 BYTE PTR _drive$[ebp], 0

; 187  : 		head = ((Sector % (SECTORS_PER_TRACK * 2)) / SECTORS_PER_TRACK);

  00021	0f b7 45 0c	 movzx	 eax, WORD PTR _Sector$[ebp]
  00025	99		 cdq
  00026	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  0002b	f7 f9		 idiv	 ecx
  0002d	8b c2		 mov	 eax, edx
  0002f	99		 cdq
  00030	b9 12 00 00 00	 mov	 ecx, 18			; 00000012H
  00035	f7 f9		 idiv	 ecx
  00037	88 45 fa	 mov	 BYTE PTR _head$[ebp], al

; 188  : 		track = (Sector / (SECTORS_PER_TRACK *2));

  0003a	0f b7 45 0c	 movzx	 eax, WORD PTR _Sector$[ebp]
  0003e	99		 cdq
  0003f	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00044	f7 f9		 idiv	 ecx
  00046	88 45 f9	 mov	 BYTE PTR _track$[ebp], al

; 189  : 		sector = (Sector % SECTORS_PER_TRACK) + 1;

  00049	0f b7 45 0c	 movzx	 eax, WORD PTR _Sector$[ebp]
  0004d	99		 cdq
  0004e	b9 12 00 00 00	 mov	 ecx, 18			; 00000012H
  00053	f7 f9		 idiv	 ecx
  00055	83 c2 01	 add	 edx, 1
  00058	88 55 f8	 mov	 BYTE PTR _sector$[ebp], dl

; 190  : 
; 191  : 		//모터 ON =1st INTERRUPT
; 192  : 		m_FddInterruptOccurred = FALSE; {

  0005b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_FddInterruptOccurred, 0

; 193  : 			FddpTurnOnMotor();

  00065	e8 00 00 00 00	 call	 _FddpTurnOnMotor
$LN12@FddpReadWr:

; 194  : 		} while (!m_FddInterruptOccurred);

  0006a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _m_FddInterruptOccurred, 0
  00071	75 02		 jne	 SHORT $LN11@FddpReadWr
  00073	eb f5		 jmp	 SHORT $LN12@FddpReadWr
$LN11@FddpReadWr:

; 195  : 
; 196  : 		//calibrate drive - 2st INTERRUPT
; 197  : 		m_FddInterruptOccurred = FALSE;{

  00075	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_FddInterruptOccurred, 0

; 198  : 			FddpWriteFdcData(0x07);

  0007f	6a 07		 push	 7
  00081	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00086	83 c4 04	 add	 esp, 4

; 199  : 			FddpWriteFdcData(0x00);

  00089	6a 00		 push	 0
  0008b	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00090	83 c4 04	 add	 esp, 4
$LN10@FddpReadWr:

; 200  : 		} while(!m_FddInterruptOccurred);

  00093	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _m_FddInterruptOccurred, 0
  0009a	75 02		 jne	 SHORT $LN9@FddpReadWr
  0009c	eb f5		 jmp	 SHORT $LN10@FddpReadWr
$LN9@FddpReadWr:

; 201  : 
; 202  : 		//seek - 3rd Interrupt
; 203  : 		m_FddInterruptOccurred = FALSE; {

  0009e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_FddInterruptOccurred, 0

; 204  : 			FddpWriteFdcData(0x0f); //seek command

  000a8	6a 0f		 push	 15			; 0000000fH
  000aa	e8 00 00 00 00	 call	 _FddpWriteFdcData
  000af	83 c4 04	 add	 esp, 4

; 205  : 			FddpWriteFdcData((head << 2) + drive); //head 넘버

  000b2	0f b6 45 fa	 movzx	 eax, BYTE PTR _head$[ebp]
  000b6	0f b6 4d fb	 movzx	 ecx, BYTE PTR _drive$[ebp]
  000ba	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _FddpWriteFdcData
  000c3	83 c4 04	 add	 esp, 4

; 206  : 			FddpWriteFdcData(track);

  000c6	8a 45 f9	 mov	 al, BYTE PTR _track$[ebp]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _FddpWriteFdcData
  000cf	83 c4 04	 add	 esp, 4
$LN8@FddpReadWr:

; 207  : 		} while (!m_FddInterruptOccurred);

  000d2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _m_FddInterruptOccurred, 0
  000d9	75 02		 jne	 SHORT $LN7@FddpReadWr
  000db	eb f5		 jmp	 SHORT $LN8@FddpReadWr
$LN7@FddpReadWr:

; 208  : 
; 209  : 		//DMA를 설정하는 함수
; 210  : 		FddpSetupDMA(JobType);

  000dd	8b 45 08	 mov	 eax, DWORD PTR _JobType$[ebp]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _FddpSetupDMA
  000e6	83 c4 04	 add	 esp, 4

; 211  : 
; 212  : 		m_FddInterruptOccurred = FALSE; {

  000e9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_FddInterruptOccurred, 0

; 213  : 			FddpWriteFdcData(0xe6);

  000f3	68 e6 00 00 00	 push	 230			; 000000e6H
  000f8	e8 00 00 00 00	 call	 _FddpWriteFdcData
  000fd	83 c4 04	 add	 esp, 4

; 214  : 			FddpWriteFdcData((head << 2)+ drive);

  00100	0f b6 45 fa	 movzx	 eax, BYTE PTR _head$[ebp]
  00104	0f b6 4d fb	 movzx	 ecx, BYTE PTR _drive$[ebp]
  00108	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0010b	52		 push	 edx
  0010c	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00111	83 c4 04	 add	 esp, 4

; 215  : 			FddpWriteFdcData(track);

  00114	8a 45 f9	 mov	 al, BYTE PTR _track$[ebp]
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 _FddpWriteFdcData
  0011d	83 c4 04	 add	 esp, 4

; 216  : 			FddpWriteFdcData(head);

  00120	8a 45 fa	 mov	 al, BYTE PTR _head$[ebp]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00129	83 c4 04	 add	 esp, 4

; 217  : 			FddpWriteFdcData(1);

  0012c	6a 01		 push	 1
  0012e	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00133	83 c4 04	 add	 esp, 4

; 218  : 			FddpWriteFdcData(2);

  00136	6a 02		 push	 2
  00138	e8 00 00 00 00	 call	 _FddpWriteFdcData
  0013d	83 c4 04	 add	 esp, 4

; 219  : 			FddpWriteFdcData(SECTORS_PER_TRACK);

  00140	6a 12		 push	 18			; 00000012H
  00142	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00147	83 c4 04	 add	 esp, 4

; 220  : 			FddpWriteFdcData(27);

  0014a	6a 1b		 push	 27			; 0000001bH
  0014c	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00151	83 c4 04	 add	 esp, 4

; 221  : 			FddpWriteFdcData(0xff);

  00154	68 ff 00 00 00	 push	 255			; 000000ffH
  00159	e8 00 00 00 00	 call	 _FddpWriteFdcData
  0015e	83 c4 04	 add	 esp, 4
$LN6@FddpReadWr:

; 222  : 		}while (!m_FddInterruptOccurred);

  00161	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _m_FddInterruptOccurred, 0
  00168	75 02		 jne	 SHORT $LN5@FddpReadWr
  0016a	eb f5		 jmp	 SHORT $LN6@FddpReadWr
$LN5@FddpReadWr:

; 223  : 
; 224  : 		pDMAAddr += (BYTES_PER_SECTOR*(sector-1));

  0016c	0f b6 45 f8	 movzx	 eax, BYTE PTR _sector$[ebp]
  00170	83 e8 01	 sub	 eax, 1
  00173	c1 e0 09	 shl	 eax, 9
  00176	03 45 fc	 add	 eax, DWORD PTR _pDMAAddr$[ebp]
  00179	89 45 fc	 mov	 DWORD PTR _pDMAAddr$[ebp], eax

; 225  : 		if(JobType == FDD_READ_SECTOR) {

  0017c	83 7d 08 00	 cmp	 DWORD PTR _JobType$[ebp], 0
  00180	75 30		 jne	 SHORT $LN4@FddpReadWr

; 226  : 			for(i=0; i<(BYTES_PER_SECTOR*NumbersOfSectors); i++) {

  00182	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00189	eb 09		 jmp	 SHORT $LN3@FddpReadWr
$LN2@FddpReadWr:
  0018b	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0018e	83 c0 01	 add	 eax, 1
  00191	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN3@FddpReadWr:
  00194	0f b6 45 10	 movzx	 eax, BYTE PTR _NumbersOfSectors$[ebp]
  00198	c1 e0 09	 shl	 eax, 9
  0019b	39 45 f4	 cmp	 DWORD PTR _i$[ebp], eax
  0019e	7d 12		 jge	 SHORT $LN4@FddpReadWr

; 227  : 				*(pData+i) = *(pDMAAddr+i);

  001a0	8b 45 14	 mov	 eax, DWORD PTR _pData$[ebp]
  001a3	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  001a6	8b 4d fc	 mov	 ecx, DWORD PTR _pDMAAddr$[ebp]
  001a9	03 4d f4	 add	 ecx, DWORD PTR _i$[ebp]
  001ac	8a 11		 mov	 dl, BYTE PTR [ecx]
  001ae	88 10		 mov	 BYTE PTR [eax], dl

; 228  : 			}

  001b0	eb d9		 jmp	 SHORT $LN2@FddpReadWr
$LN4@FddpReadWr:

; 229  : 		}
; 230  : 
; 231  : 		//모터 off
; 232  : 		FddpTurnOffMotor();

  001b2	e8 00 00 00 00	 call	 _FddpTurnOffMotor

; 233  : 
; 234  : 		return TRUE;

  001b7	b8 01 00 00 00	 mov	 eax, 1
$LN14@FddpReadWr:

; 235  : 
; 236  : }

  001bc	5f		 pop	 edi
  001bd	5e		 pop	 esi
  001be	5b		 pop	 ebx
  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c3		 ret	 0
_FddpReadWriteSector ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _FddpTurnOnMotor
_TEXT	SEGMENT
_FddpTurnOnMotor PROC					; COMDAT

; 100  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 101  : 
; 102  : 		WRITE_PORT_UCHAR((PUCHAR)FDD_DOR_PORT, 0x1c);

  00009	6a 1c		 push	 28			; 0000001cH
  0000b	68 f2 03 00 00	 push	 1010			; 000003f2H
  00010	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00015	83 c4 08	 add	 esp, 8

; 103  : 		return TRUE;

  00018	b8 01 00 00 00	 mov	 eax, 1

; 104  : 
; 105  : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_FddpTurnOnMotor ENDP
_TEXT	ENDS
EXTRN	_READ_PORT_UCHAR:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _FddpWriteFdcData
_TEXT	SEGMENT
_status$ = -1						; size = 1
_Data$ = 8						; size = 1
_FddpWriteFdcData PROC					; COMDAT

; 119  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN3@FddpWriteF:

; 120  : 
; 121  : 		UCHAR	status;
; 122  : 
; 123  : 		do {
; 124  : 			status = READ_PORT_UCHAR((PUCHAR)FDD_STATUS_PORT);

  00009	68 f4 03 00 00	 push	 1012			; 000003f4H
  0000e	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00013	83 c4 04	 add	 esp, 4
  00016	88 45 ff	 mov	 BYTE PTR _status$[ebp], al

; 125  : 		} while( (status & 0xc0 ) != 0x80 );

  00019	0f b6 45 ff	 movzx	 eax, BYTE PTR _status$[ebp]
  0001d	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00022	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00027	75 e0		 jne	 SHORT $LN3@FddpWriteF

; 126  : 		WRITE_PORT_UCHAR((PUCHAR)FDD_DATA_PORT, Data);

  00029	8a 45 08	 mov	 al, BYTE PTR _Data$[ebp]
  0002c	50		 push	 eax
  0002d	68 f5 03 00 00	 push	 1013			; 000003f5H
  00032	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00037	83 c4 08	 add	 esp, 8

; 127  : 
; 128  : 		return TRUE;

  0003a	b8 01 00 00 00	 mov	 eax, 1

; 129  : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_FddpWriteFdcData ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _FddpSetupDMA
_TEXT	SEGMENT
_count$ = -4						; size = 2
_JobType$ = 8						; size = 4
_FddpSetupDMA PROC					; COMDAT

; 149  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 150  : 	
; 151  : 		WORD count = BYTES_PER_SECTOR*SECTORS_PER_TRACK-1;

  00009	66 c7 45 fc ff
	23		 mov	 WORD PTR _count$[ebp], 9215 ; 000023ffH

; 152  : 
; 153  : 		//읽기모드인지 쓰기모드인지 설정
; 154  : 		if(JobType == FDD_READ_SECTOR) {

  0000f	83 7d 08 00	 cmp	 DWORD PTR _JobType$[ebp], 0
  00013	75 0e		 jne	 SHORT $LN2@FddpSetupD

; 155  : 			WRITE_PORT_UCHAR((PUCHAR)0x0b, 0x46);

  00015	6a 46		 push	 70			; 00000046H
  00017	6a 0b		 push	 11			; 0000000bH
  00019	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0001e	83 c4 08	 add	 esp, 8

; 156  : 		} else {

  00021	eb 0c		 jmp	 SHORT $LN1@FddpSetupD
$LN2@FddpSetupD:

; 157  : 			WRITE_PORT_UCHAR((PUCHAR)0x0b, 0x4a);

  00023	6a 4a		 push	 74			; 0000004aH
  00025	6a 0b		 push	 11			; 0000000bH
  00027	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0002c	83 c4 08	 add	 esp, 8
$LN1@FddpSetupD:

; 158  : 		}
; 159  : 
; 160  : 		//ADDRESS
; 161  : 
; 162  : 		WRITE_PORT_UCHAR((PUCHAR)0x04, 0x00);

  0002f	6a 00		 push	 0
  00031	6a 04		 push	 4
  00033	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00038	83 c4 08	 add	 esp, 8

; 163  : 		WRITE_PORT_UCHAR((PUCHAR)0x04, 0x00);

  0003b	6a 00		 push	 0
  0003d	6a 04		 push	 4
  0003f	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00044	83 c4 08	 add	 esp, 8

; 164  : 		WRITE_PORT_UCHAR((PUCHAR)0x81, 0x00);

  00047	6a 00		 push	 0
  00049	68 81 00 00 00	 push	 129			; 00000081H
  0004e	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00053	83 c4 08	 add	 esp, 8

; 165  : 
; 166  : 		WRITE_PORT_UCHAR((PUCHAR)0x05, (BYTE)count);

  00056	8a 45 fc	 mov	 al, BYTE PTR _count$[ebp]
  00059	50		 push	 eax
  0005a	6a 05		 push	 5
  0005c	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00061	83 c4 08	 add	 esp, 8

; 167  : 		WRITE_PORT_UCHAR((PUCHAR)0x05, (BYTE)(count >> 8));

  00064	0f b7 45 fc	 movzx	 eax, WORD PTR _count$[ebp]
  00068	c1 f8 08	 sar	 eax, 8
  0006b	50		 push	 eax
  0006c	6a 05		 push	 5
  0006e	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00073	83 c4 08	 add	 esp, 8

; 168  : 
; 169  : 		WRITE_PORT_UCHAR((PUCHAR)0x0a, 0x02);

  00076	6a 02		 push	 2
  00078	6a 0a		 push	 10			; 0000000aH
  0007a	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0007f	83 c4 08	 add	 esp, 8

; 170  : 
; 171  : 
; 172  : }

  00082	5f		 pop	 edi
  00083	5e		 pop	 esi
  00084	5b		 pop	 ebx
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c3		 ret	 0
_FddpSetupDMA ENDP
_TEXT	ENDS
_BSS	SEGMENT
_m_JobItemQ DB	01e3H DUP (?)
; Function compile flags: /Odtp /ZI
_BSS	ENDS
;	COMDAT _FddpPopJobItem
_TEXT	SEGMENT
_bResult$ = -4						; size = 4
_pJobItem$ = 8						; size = 4
_FddpPopJobItem PROC					; COMDAT

; 261  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 262  : 
; 263  : 	BOOL	bResult = TRUE;

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 1

; 264  : 
; 265  : ENTER_CRITICAL_SECTION();

  00010	9c		 pushfd
  00011	fa		 cli

; 266  : 	{
; 267  : 		//큐 관리함수로부터 카운트 체크
; 268  : 		if(m_JobItemQ.cnt ==0) {

  00012	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ
  00019	85 c0		 test	 eax, eax
  0001b	75 0c		 jne	 SHORT $LN2@FddpPopJob

; 269  : 			bResult = FALSE;

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0

; 270  : 			goto $exit;

  00024	e9 9a 00 00 00	 jmp	 $$exit$985
$LN2@FddpPopJob:

; 271  : 		}
; 272  : 
; 273  : 		m_JobItemQ.cnt--;

  00029	a0 00 00 00 00	 mov	 al, BYTE PTR _m_JobItemQ
  0002e	2c 01		 sub	 al, 1
  00030	a2 00 00 00 00	 mov	 BYTE PTR _m_JobItemQ, al

; 274  : 		pJobItem->type		=m_JobItemQ.queue[m_JobItemQ.head].type;

  00035	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+1
  0003c	6b c0 0f	 imul	 eax, 15			; 0000000fH
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  00042	8b 90 03 00 00
	00		 mov	 edx, DWORD PTR _m_JobItemQ[eax+3]
  00048	89 11		 mov	 DWORD PTR [ecx], edx

; 275  : 		pJobItem->sector	=m_JobItemQ.queue[m_JobItemQ.head].sector;

  0004a	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+1
  00051	6b c0 0f	 imul	 eax, 15			; 0000000fH
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  00057	66 8b 90 07 00
	00 00		 mov	 dx, WORD PTR _m_JobItemQ[eax+7]
  0005e	66 89 51 04	 mov	 WORD PTR [ecx+4], dx

; 276  : 		pJobItem->numbers_of_sectors		=m_JobItemQ.queue[m_JobItemQ.head].numbers_of_sectors;

  00062	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+1
  00069	6b c0 0f	 imul	 eax, 15			; 0000000fH
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  0006f	8a 90 09 00 00
	00		 mov	 dl, BYTE PTR _m_JobItemQ[eax+9]
  00075	88 51 06	 mov	 BYTE PTR [ecx+6], dl

; 277  : 		pJobItem->pt_data		=m_JobItemQ.queue[m_JobItemQ.head].pt_data;

  00078	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+1
  0007f	6b c0 0f	 imul	 eax, 15			; 0000000fH
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  00085	8b 90 0a 00 00
	00		 mov	 edx, DWORD PTR _m_JobItemQ[eax+10]
  0008b	89 51 07	 mov	 DWORD PTR [ecx+7], edx

; 278  : 		pJobItem->thread		=m_JobItemQ.queue[m_JobItemQ.head].thread;

  0008e	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+1
  00095	6b c0 0f	 imul	 eax, 15			; 0000000fH
  00098	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  0009b	8b 90 0e 00 00
	00		 mov	 edx, DWORD PTR _m_JobItemQ[eax+14]
  000a1	89 51 0b	 mov	 DWORD PTR [ecx+11], edx

; 279  : 		m_JobItemQ.head++;

  000a4	a0 01 00 00 00	 mov	 al, BYTE PTR _m_JobItemQ+1
  000a9	04 01		 add	 al, 1
  000ab	a2 01 00 00 00	 mov	 BYTE PTR _m_JobItemQ+1, al

; 280  : 		if(m_JobItemQ.head >= FDD_JOB_ITEM_Q_SIZE)

  000b0	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+1
  000b7	83 f8 20	 cmp	 eax, 32			; 00000020H
  000ba	7c 07		 jl	 SHORT $$exit$985

; 281  : 			m_JobItemQ.head =0;

  000bc	c6 05 01 00 00
	00 00		 mov	 BYTE PTR _m_JobItemQ+1, 0
$$exit$985:

; 282  : 	}
; 283  : $exit:
; 284  : EXIT_CRITICAL_SECTION();

  000c3	9d		 popfd

; 285  : 	return bResult;

  000c4	8b 45 fc	 mov	 eax, DWORD PTR _bResult$[ebp]

; 286  : }

  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	5b		 pop	 ebx
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
_FddpPopJobItem ENDP
_TEXT	ENDS
PUBLIC	_FddReadSector
EXTRN	_PsGetCurrentThread:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _FddReadSector
_TEXT	SEGMENT
_job_item$ = -16					; size = 15
_SectorNumber$ = 8					; size = 2
_NumbersOfSectors$ = 12					; size = 1
_pData$ = 16						; size = 4
_FddReadSector PROC					; COMDAT

; 324  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 325  : 	FDD_JOB_ITEM job_item;
; 326  : 
; 327  : ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 328  : 	job_item.type				=FDD_READ_SECTOR;

  0000b	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _job_item$[ebp], 0

; 329  : 	job_item.sector				=SectorNumber;

  00012	66 8b 45 08	 mov	 ax, WORD PTR _SectorNumber$[ebp]
  00016	66 89 45 f4	 mov	 WORD PTR _job_item$[ebp+4], ax

; 330  : 	job_item.numbers_of_sectors	= NumbersOfSectors;

  0001a	8a 45 0c	 mov	 al, BYTE PTR _NumbersOfSectors$[ebp]
  0001d	88 45 f6	 mov	 BYTE PTR _job_item$[ebp+6], al

; 331  : 	job_item.pt_data			= pData;

  00020	8b 45 10	 mov	 eax, DWORD PTR _pData$[ebp]
  00023	89 45 f7	 mov	 DWORD PTR _job_item$[ebp+7], eax

; 332  : 	job_item.thread				= PsGetCurrentThread();

  00026	e8 00 00 00 00	 call	 _PsGetCurrentThread
  0002b	89 45 fb	 mov	 DWORD PTR _job_item$[ebp+11], eax

; 333  : 
; 334  : 	//작업을 플로피 디스크 작업 큐에 집어 넣는다
; 335  : 	if(!FddpPushJobItem(&job_item)) {

  0002e	8d 45 f0	 lea	 eax, DWORD PTR _job_item$[ebp]
  00031	50		 push	 eax
  00032	e8 00 00 00 00	 call	 _FddpPushJobItem
  00037	83 c4 04	 add	 esp, 4
  0003a	85 c0		 test	 eax, eax
  0003c	75 05		 jne	 SHORT $LN1@FddReadSec

; 336  : 		EXIT_CRITICAL_SECTION();

  0003e	9d		 popfd

; 337  : 		return FALSE;

  0003f	33 c0		 xor	 eax, eax
  00041	eb 19		 jmp	 SHORT $LN2@FddReadSec
$LN1@FddReadSec:

; 338  : 	}
; 339  : 
; 340  : 	//쓰레드 상태 변경
; 341  : 
; 342  : 	PsSetThreadStatus(job_item.thread, THREAD_STATUS_WAITING);

  00043	6a 03		 push	 3
  00045	8b 45 fb	 mov	 eax, DWORD PTR _job_item$[ebp+11]
  00048	50		 push	 eax
  00049	e8 00 00 00 00	 call	 _PsSetThreadStatus
  0004e	83 c4 08	 add	 esp, 8

; 343  : EXIT_CRITICAL_SECTION();

  00051	9d		 popfd

; 344  : 
; 345  : //태스크 스위치
; 346  : 	HalTaskSwitch();

  00052	e8 00 00 00 00	 call	 _HalTaskSwitch

; 347  : 
; 348  : 	return TRUE;

  00057	b8 01 00 00 00	 mov	 eax, 1
$LN2@FddReadSec:

; 349  : }

  0005c	5f		 pop	 edi
  0005d	5e		 pop	 esi
  0005e	5b		 pop	 ebx
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
_FddReadSector ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _FddpPushJobItem
_TEXT	SEGMENT
_bResult$ = -4						; size = 4
_pJobItem$ = 8						; size = 4
_FddpPushJobItem PROC					; COMDAT

; 292  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 293  : 			
; 294  : 		BOOL bResult = TRUE;

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 1

; 295  : ENTER_CRITICAL_SECTION();

  00010	9c		 pushfd
  00011	fa		 cli

; 296  : 	{
; 297  : 		//큐 관리함수로부터 카운트 체크
; 298  : 		if(m_JobItemQ.cnt >= FDD_JOB_ITEM_Q_SIZE) {

  00012	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ
  00019	83 f8 20	 cmp	 eax, 32			; 00000020H
  0001c	7c 0c		 jl	 SHORT $LN2@FddpPushJo

; 299  : 			bResult = FALSE;

  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0

; 300  : 			goto $exit;

  00025	e9 9a 00 00 00	 jmp	 $$exit$992
$LN2@FddpPushJo:

; 301  : 		}
; 302  : 
; 303  : 		m_JobItemQ.cnt++;

  0002a	a0 00 00 00 00	 mov	 al, BYTE PTR _m_JobItemQ
  0002f	04 01		 add	 al, 1
  00031	a2 00 00 00 00	 mov	 BYTE PTR _m_JobItemQ, al

; 304  : 		m_JobItemQ.queue[m_JobItemQ.tail].type	= pJobItem->type;

  00036	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+2
  0003d	6b c0 0f	 imul	 eax, 15			; 0000000fH
  00040	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  00043	8b 11		 mov	 edx, DWORD PTR [ecx]
  00045	89 90 03 00 00
	00		 mov	 DWORD PTR _m_JobItemQ[eax+3], edx

; 305  : 		m_JobItemQ.queue[m_JobItemQ.tail].sector	= pJobItem->sector;

  0004b	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+2
  00052	6b c0 0f	 imul	 eax, 15			; 0000000fH
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  00058	66 8b 51 04	 mov	 dx, WORD PTR [ecx+4]
  0005c	66 89 90 07 00
	00 00		 mov	 WORD PTR _m_JobItemQ[eax+7], dx

; 306  : 		m_JobItemQ.queue[m_JobItemQ.tail].numbers_of_sectors	= pJobItem->numbers_of_sectors;

  00063	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+2
  0006a	6b c0 0f	 imul	 eax, 15			; 0000000fH
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  00070	8a 51 06	 mov	 dl, BYTE PTR [ecx+6]
  00073	88 90 09 00 00
	00		 mov	 BYTE PTR _m_JobItemQ[eax+9], dl

; 307  : 		m_JobItemQ.queue[m_JobItemQ.tail].pt_data	= pJobItem->pt_data;

  00079	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+2
  00080	6b c0 0f	 imul	 eax, 15			; 0000000fH
  00083	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  00086	8b 51 07	 mov	 edx, DWORD PTR [ecx+7]
  00089	89 90 0a 00 00
	00		 mov	 DWORD PTR _m_JobItemQ[eax+10], edx

; 308  : 		m_JobItemQ.queue[m_JobItemQ.tail].thread	= pJobItem->thread;

  0008f	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+2
  00096	6b c0 0f	 imul	 eax, 15			; 0000000fH
  00099	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  0009c	8b 51 0b	 mov	 edx, DWORD PTR [ecx+11]
  0009f	89 90 0e 00 00
	00		 mov	 DWORD PTR _m_JobItemQ[eax+14], edx

; 309  : 		m_JobItemQ.tail++;

  000a5	a0 02 00 00 00	 mov	 al, BYTE PTR _m_JobItemQ+2
  000aa	04 01		 add	 al, 1
  000ac	a2 02 00 00 00	 mov	 BYTE PTR _m_JobItemQ+2, al

; 310  : 		
; 311  : 		if(m_JobItemQ.tail >= FDD_JOB_ITEM_Q_SIZE)

  000b1	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+2
  000b8	83 f8 20	 cmp	 eax, 32			; 00000020H
  000bb	7c 07		 jl	 SHORT $$exit$992

; 312  : 			m_JobItemQ.tail =0;

  000bd	c6 05 02 00 00
	00 00		 mov	 BYTE PTR _m_JobItemQ+2, 0
$$exit$992:

; 313  : 	}
; 314  : $exit:
; 315  : EXIT_CRITICAL_SECTION();

  000c4	9d		 popfd

; 316  : 	return bResult;

  000c5	8b 45 fc	 mov	 eax, DWORD PTR _bResult$[ebp]

; 317  : 	
; 318  : 
; 319  : 
; 320  : }

  000c8	5f		 pop	 edi
  000c9	5e		 pop	 esi
  000ca	5b		 pop	 ebx
  000cb	8b e5		 mov	 esp, ebp
  000cd	5d		 pop	 ebp
  000ce	c3		 ret	 0
_FddpPushJobItem ENDP
_TEXT	ENDS
END
