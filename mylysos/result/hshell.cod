; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	c:\Users\상우\Documents\카카오톡 받은 파일\MylysOS\hshell.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_04HEDFJGEJ@FREE?$AA@			; `string'
PUBLIC	??_C@_02PNJEAGMK@PS?$AA@			; `string'
PUBLIC	??_C@_04KDPJLEDB@TYPE?$AA@			; `string'
PUBLIC	??_C@_03DNALGGBA@DIR?$AA@			; `string'
PUBLIC	??_C@_06FDJJHOKF@TOGGLE?$AA@			; `string'
PUBLIC	??_C@_03MOABAAGA@VER?$AA@			; `string'
PUBLIC	??_C@_03LPAMKNAD@CLS?$AA@			; `string'
PUBLIC	??_C@_04DOKPJKJF@HELP?$AA@			; `string'
_BSS	SEGMENT
?cmd_next_pos@?1??HshpMainThread@@9@9 DD 01H DUP (?)	; `HshpMainThread'::`2'::cmd_next_pos
_BSS	ENDS
_DATA	SEGMENT
_m_InternalCmds DD FLAT:??_C@_04DOKPJKJF@HELP?$AA@
	DD	FLAT:_Hshp_CMD_help
	DD	FLAT:??_C@_03LPAMKNAD@CLS?$AA@
	DD	FLAT:_Hshp_CMD_cls
	DD	FLAT:??_C@_03MOABAAGA@VER?$AA@
	DD	FLAT:_Hshp_CMD_ver
	DD	FLAT:??_C@_06FDJJHOKF@TOGGLE?$AA@
	DD	FLAT:_Hshp_CMD_toggle
	DD	FLAT:??_C@_03DNALGGBA@DIR?$AA@
	DD	FLAT:_Hshp_CMD_dir
	DD	FLAT:??_C@_04KDPJLEDB@TYPE?$AA@
	DD	FLAT:_Hshp_CMD_type
	DD	FLAT:??_C@_02PNJEAGMK@PS?$AA@
	DD	FLAT:_Hshp_CMD_ps
	DD	FLAT:??_C@_04HEDFJGEJ@FREE?$AA@
	DD	FLAT:_Hshp_CMD_free
	DD	00H
	DD	00H
?bShow@?1??Hshp_CMD_toggle@@9@9 DD 01H			; `Hshp_CMD_toggle'::`2'::bShow
_DATA	ENDS
;	COMDAT ??_C@_04HEDFJGEJ@FREE?$AA@
CONST	SEGMENT
??_C@_04HEDFJGEJ@FREE?$AA@ DB 'FREE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02PNJEAGMK@PS?$AA@
CONST	SEGMENT
??_C@_02PNJEAGMK@PS?$AA@ DB 'PS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KDPJLEDB@TYPE?$AA@
CONST	SEGMENT
??_C@_04KDPJLEDB@TYPE?$AA@ DB 'TYPE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DNALGGBA@DIR?$AA@
CONST	SEGMENT
??_C@_03DNALGGBA@DIR?$AA@ DB 'DIR', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_06FDJJHOKF@TOGGLE?$AA@
CONST	SEGMENT
??_C@_06FDJJHOKF@TOGGLE?$AA@ DB 'TOGGLE', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MOABAAGA@VER?$AA@
CONST	SEGMENT
??_C@_03MOABAAGA@VER?$AA@ DB 'VER', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LPAMKNAD@CLS?$AA@
CONST	SEGMENT
??_C@_03LPAMKNAD@CLS?$AA@ DB 'CLS', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04DOKPJKJF@HELP?$AA@
CONST	SEGMENT
??_C@_04DOKPJKJF@HELP?$AA@ DB 'HELP', 00H		; `string'
CONST	ENDS
PUBLIC	_HshInitializeShell
EXTRN	_PsSetThreadStatus:PROC
EXTRN	_PsCreateThread:PROC
EXTRN	_PsCreateProcess:PROC
EXTRN	_memset:PROC
_BSS	SEGMENT
_m_ThreadHandle DD 01H DUP (?)
_m_ProcessHandle DD 01H DUP (?)
_m_CmdLine DB	080H DUP (?)
; Function compile flags: /Odtp /ZI
; File c:\users\상우\documents\카카오톡 받은 파일\mylysos\hshell.c
_BSS	ENDS
;	COMDAT _HshInitializeShell
_TEXT	SEGMENT
_HshInitializeShell PROC				; COMDAT

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 76   : 
; 77   : 	//m_CmdLine버퍼 초기화
; 78   : 	memset(m_CmdLine, NULL, MAX_CMD_LINE_CHAR);

  00009	68 80 00 00 00	 push	 128			; 00000080H
  0000e	6a 00		 push	 0
  00010	68 00 00 00 00	 push	 OFFSET _m_CmdLine
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 79   : 
; 80   : 	//웹에서 수행해야 할 동작들을 처리하기 위한 프로세스 생성
; 81   : 	if(!PsCreateProcess(&m_ProcessHandle))

  0001d	68 00 00 00 00	 push	 OFFSET _m_ProcessHandle
  00022	e8 00 00 00 00	 call	 _PsCreateProcess
  00027	83 c4 04	 add	 esp, 4
  0002a	85 c0		 test	 eax, eax
  0002c	75 04		 jne	 SHORT $LN2@HshInitial

; 82   : 		return FALSE;

  0002e	33 c0		 xor	 eax, eax
  00030	eb 3e		 jmp	 SHORT $LN3@HshInitial
$LN2@HshInitial:

; 83   : 
; 84   : 	//쉘에서 수행해야 할 동작들을 처리하기 위한 쓰레드 생성
; 85   : 	if(!PsCreateThread(&m_ThreadHandle, m_ProcessHandle, HshpMainThread, NULL, DEFAULT_STACK_SIZE, FALSE))

  00032	6a 00		 push	 0
  00034	68 00 00 01 00	 push	 65536			; 00010000H
  00039	6a 00		 push	 0
  0003b	68 00 00 00 00	 push	 OFFSET _HshpMainThread
  00040	a1 00 00 00 00	 mov	 eax, DWORD PTR _m_ProcessHandle
  00045	50		 push	 eax
  00046	68 00 00 00 00	 push	 OFFSET _m_ThreadHandle
  0004b	e8 00 00 00 00	 call	 _PsCreateThread
  00050	83 c4 18	 add	 esp, 24			; 00000018H
  00053	85 c0		 test	 eax, eax
  00055	75 04		 jne	 SHORT $LN1@HshInitial

; 86   : 		return FALSE;

  00057	33 c0		 xor	 eax, eax
  00059	eb 15		 jmp	 SHORT $LN3@HshInitial
$LN1@HshInitial:

; 87   : 	PsSetThreadStatus(m_ThreadHandle, THREAD_STATUS_READY);

  0005b	6a 02		 push	 2
  0005d	a1 00 00 00 00	 mov	 eax, DWORD PTR _m_ThreadHandle
  00062	50		 push	 eax
  00063	e8 00 00 00 00	 call	 _PsSetThreadStatus
  00068	83 c4 08	 add	 esp, 8

; 88   : 
; 89   : 	return TRUE;

  0006b	b8 01 00 00 00	 mov	 eax, 1
$LN3@HshInitial:

; 90   : }

  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c3		 ret	 0
_HshInitializeShell ENDP
_TEXT	ENDS
PUBLIC	??_C@_02HAOIJKIC@?$CFc?$AA@			; `string'
PUBLIC	??_C@_04OHLLKNHH@A?3?2?$DO?$AA@			; `string'
PUBLIC	??_C@_0CK@LBAJIGLI@FsInitializeModule?$CI?$CJ?5returned?5an@ ; `string'
EXTRN	_strlen:PROC
EXTRN	_CrtGetCursorPos:PROC
EXTRN	_HalTaskSwitch:PROC
EXTRN	_KbdGetKey:PROC
EXTRN	_CrtPrintf:PROC
EXTRN	_FsInitializeModule:PROC
;	COMDAT ??_C@_02HAOIJKIC@?$CFc?$AA@
CONST	SEGMENT
??_C@_02HAOIJKIC@?$CFc?$AA@ DB '%c', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04OHLLKNHH@A?3?2?$DO?$AA@
CONST	SEGMENT
??_C@_04OHLLKNHH@A?3?2?$DO?$AA@ DB 'A:\>', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@LBAJIGLI@FsInitializeModule?$CI?$CJ?5returned?5an@
CONST	SEGMENT
??_C@_0CK@LBAJIGLI@FsInitializeModule?$CI?$CJ?5returned?5an@ DB 'FsInitia'
	DB	'lizeModule() returned an error.', 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _HshpMainThread
_TEXT	SEGMENT
_cursor_y$ = -6						; size = 1
_cursor_x$ = -5						; size = 1
_KeyData$ = -4						; size = 2
_StartContext$ = 8					; size = 4
_HshpMainThread PROC					; COMDAT

; 96   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 97   : 	
; 98   : 	KBD_KEY_DATA KeyData;
; 99   : 	BYTE cursor_x, cursor_y;
; 100  : 	static int cmd_next_pos=0;
; 101  : 
; 102  : 	
; 103  : 	//파일시스템 초기화 함수 호출
; 104  : 	if(!FsInitializeModule()) {

  00009	e8 00 00 00 00	 call	 _FsInitializeModule
  0000e	85 c0		 test	 eax, eax
  00010	75 14		 jne	 SHORT $LN12@HshpMainTh

; 105  : 		DbgPrint("FsInitializeModule() returned an error.\r\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@LBAJIGLI@FsInitializeModule?$CI?$CJ?5returned?5an@
  00017	e8 00 00 00 00	 call	 _CrtPrintf
  0001c	83 c4 04	 add	 esp, 4

; 106  : 		return 0;

  0001f	33 c0		 xor	 eax, eax
  00021	e9 14 01 00 00	 jmp	 $LN13@HshpMainTh
$LN12@HshpMainTh:

; 107  : 	}
; 108  : 
; 109  : 	HshpPrintPrompt();

  00026	e8 00 00 00 00	 call	 _HshpPrintPrompt
$LN11@HshpMainTh:

; 110  : 
; 111  : 	//반복하면서 kbdGetKey함수를 이용하여 유저가 입렬하는 키를 받아온다.
; 112  : 	while(1) {

  0002b	b8 01 00 00 00	 mov	 eax, 1
  00030	85 c0		 test	 eax, eax
  00032	0f 84 00 01 00
	00		 je	 $LN10@HshpMainTh

; 113  : 		if(!KbdGetKey(&KeyData)) {

  00038	8d 45 fc	 lea	 eax, DWORD PTR _KeyData$[ebp]
  0003b	50		 push	 eax
  0003c	e8 00 00 00 00	 call	 _KbdGetKey
  00041	83 c4 04	 add	 esp, 4
  00044	85 c0		 test	 eax, eax
  00046	75 07		 jne	 SHORT $LN9@HshpMainTh

; 114  : 			HalTaskSwitch();

  00048	e8 00 00 00 00	 call	 _HalTaskSwitch

; 115  : 			continue;

  0004d	eb dc		 jmp	 SHORT $LN11@HshpMainTh
$LN9@HshpMainTh:

; 116  : 		}
; 117  : 
; 118  : 		//특수문자일 경우 루프처음으로 건너뜀
; 119  : 		if(KeyData.type != KBD_KTYPE_GENERAL) {

  0004f	0f b6 45 fc	 movzx	 eax, BYTE PTR _KeyData$[ebp]
  00053	85 c0		 test	 eax, eax
  00055	74 02		 je	 SHORT $LN8@HshpMainTh

; 120  : 			continue;

  00057	eb d2		 jmp	 SHORT $LN11@HshpMainTh
$LN8@HshpMainTh:

; 121  : 		}
; 122  : 
; 123  : 		//백스페이스 키를 입력한경우 처리
; 124  : 		if(KeyData.key == '\b')

  00059	0f b6 45 fd	 movzx	 eax, BYTE PTR _KeyData$[ebp+1]
  0005d	83 f8 08	 cmp	 eax, 8
  00060	75 41		 jne	 SHORT $LN7@HshpMainTh

; 125  : 		{
; 126  : 			//초기 커서 위치 설정
; 127  : 			CrtGetCursorPos(&cursor_x, &cursor_y);

  00062	8d 45 fa	 lea	 eax, DWORD PTR _cursor_y$[ebp]
  00065	50		 push	 eax
  00066	8d 4d fb	 lea	 ecx, DWORD PTR _cursor_x$[ebp]
  00069	51		 push	 ecx
  0006a	e8 00 00 00 00	 call	 _CrtGetCursorPos
  0006f	83 c4 08	 add	 esp, 8

; 128  : 			//x커서의 값이 문자열 길이보다 작은 경우
; 129  : 			if(cursor_x <= SHELL_PROMPT_LENGTH)

  00072	0f b6 75 fb	 movzx	 esi, BYTE PTR _cursor_x$[ebp]
  00076	68 00 00 00 00	 push	 OFFSET ??_C@_04OHLLKNHH@A?3?2?$DO?$AA@
  0007b	e8 00 00 00 00	 call	 _strlen
  00080	83 c4 04	 add	 esp, 4
  00083	3b f0		 cmp	 esi, eax
  00085	77 02		 ja	 SHORT $LN6@HshpMainTh

; 130  : 				continue;

  00087	eb a2		 jmp	 SHORT $LN11@HshpMainTh
$LN6@HshpMainTh:

; 131  : 
; 132  : 			m_CmdLine[--cmd_next_pos] = NULL;

  00089	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cmd_next_pos@?1??HshpMainThread@@9@9
  0008e	83 e8 01	 sub	 eax, 1
  00091	a3 00 00 00 00	 mov	 DWORD PTR ?cmd_next_pos@?1??HshpMainThread@@9@9, eax
  00096	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cmd_next_pos@?1??HshpMainThread@@9@9
  0009c	c6 81 00 00 00
	00 00		 mov	 BYTE PTR _m_CmdLine[ecx], 0
$LN7@HshpMainTh:

; 133  : 		}
; 134  : 		CrtPrintf("%c", KeyData.key); //입력된 문자 출력

  000a3	0f b6 45 fd	 movzx	 eax, BYTE PTR _KeyData$[ebp+1]
  000a7	50		 push	 eax
  000a8	68 00 00 00 00	 push	 OFFSET ??_C@_02HAOIJKIC@?$CFc?$AA@
  000ad	e8 00 00 00 00	 call	 _CrtPrintf
  000b2	83 c4 08	 add	 esp, 8

; 135  : 
; 136  : 		//사용자가 입력한 명령어가 실행파일인지, 탭키인지에 대한 검사 수행
; 137  : 		if(KeyData.key == '\r') {

  000b5	0f b6 45 fd	 movzx	 eax, BYTE PTR _KeyData$[ebp+1]
  000b9	83 f8 0d	 cmp	 eax, 13			; 0000000dH
  000bc	75 29		 jne	 SHORT $LN5@HshpMainTh

; 138  : 			m_CmdLine[cmd_next_pos] = NULL;

  000be	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cmd_next_pos@?1??HshpMainThread@@9@9
  000c3	c6 80 00 00 00
	00 00		 mov	 BYTE PTR _m_CmdLine[eax], 0

; 139  : 			HshpParser(); //실행 명령어 처리

  000ca	e8 00 00 00 00	 call	 _HshpParser

; 140  : 			HshpPrintPrompt(); //다음 라인에 쉘 프롬프트 문자 출력

  000cf	e8 00 00 00 00	 call	 _HshpPrintPrompt

; 141  : 			cmd_next_pos = 0;

  000d4	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR ?cmd_next_pos@?1??HshpMainThread@@9@9, 0

; 142  : 			m_CmdLine[0] = NULL;

  000de	c6 05 00 00 00
	00 00		 mov	 BYTE PTR _m_CmdLine, 0
  000e5	eb 4c		 jmp	 SHORT $LN4@HshpMainTh
$LN5@HshpMainTh:

; 143  : 		}
; 144  : 
; 145  : 		else if(KeyData.key == '\t') {

  000e7	0f b6 45 fd	 movzx	 eax, BYTE PTR _KeyData$[ebp+1]
  000eb	83 f8 09	 cmp	 eax, 9
  000ee	75 1d		 jne	 SHORT $LN3@HshpMainTh

; 146  : 			m_CmdLine[cmd_next_pos++] = ' ';

  000f0	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cmd_next_pos@?1??HshpMainThread@@9@9
  000f5	c6 80 00 00 00
	00 20		 mov	 BYTE PTR _m_CmdLine[eax], 32 ; 00000020H
  000fc	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?cmd_next_pos@?1??HshpMainThread@@9@9
  00102	83 c1 01	 add	 ecx, 1
  00105	89 0d 00 00 00
	00		 mov	 DWORD PTR ?cmd_next_pos@?1??HshpMainThread@@9@9, ecx
  0010b	eb 26		 jmp	 SHORT $LN4@HshpMainTh
$LN3@HshpMainTh:

; 147  : 		}
; 148  : 
; 149  : 		else if(KeyData.key != '\b') {

  0010d	0f b6 45 fd	 movzx	 eax, BYTE PTR _KeyData$[ebp+1]
  00111	83 f8 08	 cmp	 eax, 8
  00114	74 1d		 je	 SHORT $LN4@HshpMainTh

; 150  : 			m_CmdLine[cmd_next_pos++] = KeyData.key;

  00116	a1 00 00 00 00	 mov	 eax, DWORD PTR ?cmd_next_pos@?1??HshpMainThread@@9@9
  0011b	8a 4d fd	 mov	 cl, BYTE PTR _KeyData$[ebp+1]
  0011e	88 88 00 00 00
	00		 mov	 BYTE PTR _m_CmdLine[eax], cl
  00124	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?cmd_next_pos@?1??HshpMainThread@@9@9
  0012a	83 c2 01	 add	 edx, 1
  0012d	89 15 00 00 00
	00		 mov	 DWORD PTR ?cmd_next_pos@?1??HshpMainThread@@9@9, edx
$LN4@HshpMainTh:

; 151  : 		}
; 152  : 	}

  00133	e9 f3 fe ff ff	 jmp	 $LN11@HshpMainTh
$LN10@HshpMainTh:

; 153  : 
; 154  : 	return 0;

  00138	33 c0		 xor	 eax, eax
$LN13@HshpMainTh:

; 155  : }

  0013a	5f		 pop	 edi
  0013b	5e		 pop	 esi
  0013c	5b		 pop	 ebx
  0013d	8b e5		 mov	 esp, ebp
  0013f	5d		 pop	 ebp
  00140	c3		 ret	 0
_HshpMainThread ENDP
_TEXT	ENDS
EXTRN	_CrtPrintText:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _HshpPrintPrompt
_TEXT	SEGMENT
_HshpPrintPrompt PROC					; COMDAT

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 160  : 
; 161  : 	CrtPrintText(SHELL_PROMPT);

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_04OHLLKNHH@A?3?2?$DO?$AA@
  0000e	e8 00 00 00 00	 call	 _CrtPrintText
  00013	83 c4 04	 add	 esp, 4

; 162  : 
; 163  : }

  00016	5f		 pop	 edi
  00017	5e		 pop	 esi
  00018	5b		 pop	 ebx
  00019	8b e5		 mov	 esp, ebp
  0001b	5d		 pop	 ebp
  0001c	c3		 ret	 0
_HshpPrintPrompt ENDP
_TEXT	ENDS
EXTRN	_strcmp:PROC
EXTRN	_strupr:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _HshpParser
_TEXT	SEGMENT
_pt_parameters$ = -16					; size = 4
_pt_cmd$ = -12						; size = 4
_CmdProcessRoutine$ = -8				; size = 4
_i$ = -4						; size = 4
_HshpParser PROC					; COMDAT

; 169  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 170  : 		
; 171  : 	int i;
; 172  : 	CMD_PROCESS_ROUTINE	CmdProcessRoutine;
; 173  : 	BYTE *pt_cmd, *pt_parameters;
; 174  : 
; 175  : 	//에외처리
; 176  : 	if(m_CmdLine[0] == NULL)

  00009	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _m_CmdLine
  00010	85 c0		 test	 eax, eax
  00012	75 0a		 jne	 SHORT $LN15@HshpParser

; 177  : 		return TRUE;

  00014	b8 01 00 00 00	 mov	 eax, 1
  00019	e9 2d 01 00 00	 jmp	 $LN16@HshpParser
$LN15@HshpParser:

; 178  : 
; 179  : 	for(i=0; m_CmdLine[i] == ' '; i++);

  0001e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN14@HshpParser
$LN13@HshpParser:
  00027	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN14@HshpParser:
  00030	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00033	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _m_CmdLine[eax]
  0003a	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0003d	75 02		 jne	 SHORT $LN12@HshpParser
  0003f	eb e6		 jmp	 SHORT $LN13@HshpParser
$LN12@HshpParser:

; 180  : 
; 181  : 	//내부명령어 확인 후 처리
; 182  : 	pt_cmd = &(m_CmdLine[i]);

  00041	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00044	05 00 00 00 00	 add	 eax, OFFSET _m_CmdLine
  00049	89 45 f4	 mov	 DWORD PTR _pt_cmd$[ebp], eax

; 183  : 	for(++i; m_CmdLine[i] != NULL && m_CmdLine[i] != ' '; i++);

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0004f	83 c0 01	 add	 eax, 1
  00052	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  00055	eb 09		 jmp	 SHORT $LN11@HshpParser
$LN10@HshpParser:
  00057	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0005a	83 c0 01	 add	 eax, 1
  0005d	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN11@HshpParser:
  00060	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00063	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _m_CmdLine[eax]
  0006a	85 c9		 test	 ecx, ecx
  0006c	74 11		 je	 SHORT $LN9@HshpParser
  0006e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00071	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _m_CmdLine[eax]
  00078	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0007b	74 02		 je	 SHORT $LN9@HshpParser
  0007d	eb d8		 jmp	 SHORT $LN10@HshpParser
$LN9@HshpParser:

; 184  : 
; 185  : 	if(m_CmdLine[i] == NULL){

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00082	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _m_CmdLine[eax]
  00089	85 c9		 test	 ecx, ecx
  0008b	75 09		 jne	 SHORT $LN8@HshpParser

; 186  : 		pt_parameters = NULL;

  0008d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _pt_parameters$[ebp], 0

; 187  : 		goto $find;

  00094	eb 3a		 jmp	 SHORT $$find$947
$LN8@HshpParser:

; 188  : 	}
; 189  : 	m_CmdLine[i] = NULL;

  00096	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00099	c6 80 00 00 00
	00 00		 mov	 BYTE PTR _m_CmdLine[eax], 0

; 190  : 
; 191  : 	for(++i; m_CmdLine[i] == ' '; i++);

  000a0	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000a3	83 c0 01	 add	 eax, 1
  000a6	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
  000a9	eb 09		 jmp	 SHORT $LN7@HshpParser
$LN6@HshpParser:
  000ab	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ae	83 c0 01	 add	 eax, 1
  000b1	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN7@HshpParser:
  000b4	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000b7	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _m_CmdLine[eax]
  000be	83 f9 20	 cmp	 ecx, 32			; 00000020H
  000c1	75 02		 jne	 SHORT $LN5@HshpParser
  000c3	eb e6		 jmp	 SHORT $LN6@HshpParser
$LN5@HshpParser:

; 192  : 
; 193  : 	pt_parameters = &(m_CmdLine[i]);

  000c5	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000c8	05 00 00 00 00	 add	 eax, OFFSET _m_CmdLine
  000cd	89 45 f0	 mov	 DWORD PTR _pt_parameters$[ebp], eax
$$find$947:

; 194  : 
; 195  : $find:
; 196  : 	pt_cmd = strupr(pt_cmd);

  000d0	8b 45 f4	 mov	 eax, DWORD PTR _pt_cmd$[ebp]
  000d3	50		 push	 eax
  000d4	e8 00 00 00 00	 call	 _strupr
  000d9	83 c4 04	 add	 esp, 4
  000dc	89 45 f4	 mov	 DWORD PTR _pt_cmd$[ebp], eax

; 197  : 	for(i=0; m_InternalCmds[i].pt_cmd != NULL; i++) {

  000df	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000e6	eb 09		 jmp	 SHORT $LN4@HshpParser
$LN3@HshpParser:
  000e8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000eb	83 c0 01	 add	 eax, 1
  000ee	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN4@HshpParser:
  000f1	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000f4	83 3c c5 00 00
	00 00 00	 cmp	 DWORD PTR _m_InternalCmds[eax*8], 0
  000fc	74 3b		 je	 SHORT $LN2@HshpParser

; 198  : 		if(strcmp(pt_cmd, m_InternalCmds[i].pt_cmd) == 0 ){

  000fe	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00101	8b 0c c5 00 00
	00 00		 mov	 ecx, DWORD PTR _m_InternalCmds[eax*8]
  00108	51		 push	 ecx
  00109	8b 55 f4	 mov	 edx, DWORD PTR _pt_cmd$[ebp]
  0010c	52		 push	 edx
  0010d	e8 00 00 00 00	 call	 _strcmp
  00112	83 c4 08	 add	 esp, 8
  00115	85 c0		 test	 eax, eax
  00117	75 1e		 jne	 SHORT $LN1@HshpParser

; 199  : 			CmdProcessRoutine = m_InternalCmds[i].routine;

  00119	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0011c	8b 0c c5 04 00
	00 00		 mov	 ecx, DWORD PTR _m_InternalCmds[eax*8+4]
  00123	89 4d f8	 mov	 DWORD PTR _CmdProcessRoutine$[ebp], ecx

; 200  : 			CmdProcessRoutine(pt_parameters);

  00126	8b 45 f0	 mov	 eax, DWORD PTR _pt_parameters$[ebp]
  00129	50		 push	 eax
  0012a	ff 55 f8	 call	 DWORD PTR _CmdProcessRoutine$[ebp]
  0012d	83 c4 04	 add	 esp, 4

; 201  : 			return TRUE;

  00130	b8 01 00 00 00	 mov	 eax, 1
  00135	eb 14		 jmp	 SHORT $LN16@HshpParser
$LN1@HshpParser:

; 202  : 		}
; 203  : 	}

  00137	eb af		 jmp	 SHORT $LN3@HshpParser
$LN2@HshpParser:

; 204  : 	Hshp_CMD_excute(pt_cmd, pt_parameters);

  00139	8b 45 f0	 mov	 eax, DWORD PTR _pt_parameters$[ebp]
  0013c	50		 push	 eax
  0013d	8b 4d f4	 mov	 ecx, DWORD PTR _pt_cmd$[ebp]
  00140	51		 push	 ecx
  00141	e8 00 00 00 00	 call	 _Hshp_CMD_excute
  00146	83 c4 08	 add	 esp, 8

; 205  : 
; 206  : 
; 207  : 	return FALSE;

  00149	33 c0		 xor	 eax, eax
$LN16@HshpParser:

; 208  : }

  0014b	5f		 pop	 edi
  0014c	5e		 pop	 esi
  0014d	5b		 pop	 ebx
  0014e	8b e5		 mov	 esp, ebp
  00150	5d		 pop	 ebp
  00151	c3		 ret	 0
_HshpParser ENDP
_TEXT	ENDS
EXTRN	_PsShowTSWachdogClock:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _Hshp_CMD_toggle
_TEXT	SEGMENT
_pParameters$ = 8					; size = 4
_Hshp_CMD_toggle PROC					; COMDAT

; 213  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 214  : 
; 215  : 	static BOOL bShow = TRUE;
; 216  : 
; 217  : 	bShow = (bShow ? FALSE : TRUE);

  00009	33 c0		 xor	 eax, eax
  0000b	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?bShow@?1??Hshp_CMD_toggle@@9@9, 0
  00012	0f 94 c0	 sete	 al
  00015	a3 00 00 00 00	 mov	 DWORD PTR ?bShow@?1??Hshp_CMD_toggle@@9@9, eax

; 218  : 	PsShowTSWachdogClock(bShow);

  0001a	a1 00 00 00 00	 mov	 eax, DWORD PTR ?bShow@?1??Hshp_CMD_toggle@@9@9
  0001f	50		 push	 eax
  00020	e8 00 00 00 00	 call	 _PsShowTSWachdogClock
  00025	83 c4 04	 add	 esp, 4

; 219  : 
; 220  : 	return TRUE;

  00028	b8 01 00 00 00	 mov	 eax, 1

; 221  : 
; 222  : }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
_Hshp_CMD_toggle ENDP
_TEXT	ENDS
EXTRN	_CrtClearScreen:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _Hshp_CMD_cls
_TEXT	SEGMENT
_pParameters$ = 8					; size = 4
_Hshp_CMD_cls PROC					; COMDAT

; 226  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 227  : 
; 228  : 	CrtClearScreen();

  00009	e8 00 00 00 00	 call	 _CrtClearScreen

; 229  : 
; 230  : 	return TRUE;

  0000e	b8 01 00 00 00	 mov	 eax, 1

; 231  : 
; 232  : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_Hshp_CMD_cls ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BEG@HPGKONKG@help?7?7?3?7View?5available?5commands?5@ ; `string'
;	COMDAT ??_C@_0BEG@HPGKONKG@help?7?7?3?7View?5available?5commands?5@
CONST	SEGMENT
??_C@_0BEG@HPGKONKG@help?7?7?3?7View?5available?5commands?5@ DB 'help', 09H
	DB	09H, ':', 09H, 'View available commands and their description.'
	DB	' ', 0dH, 0aH, 'ver', 09H, 09H, ':', 09H, 'Show the version in'
	DB	'formation of the OS and OS shell. ', 0dH, 0aH, 'cls', 09H, 09H
	DB	':', 09H, 'Clear screen. ', 0dH, 0aH, 'dir', 09H, 09H, ':', 09H
	DB	'Display all files in the current directory. ', 0dH, 0aH, 'tog'
	DB	'gle', 09H, 09H, ':', 09H, 'Show/hide soft task-switching watc'
	DB	'hdog clock. ', 0dH, 0aH, 'ps', 09H, 09H, 09H, ':', 09H, 'Disp'
	DB	'lay process state. ', 0dH, 0aH, 'free', 09H, 09H, ':', 09H, 'D'
	DB	'isplay memory using state. ', 0dH, 0aH, 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _Hshp_CMD_help
_TEXT	SEGMENT
_pParameters$ = 8					; size = 4
_Hshp_CMD_help PROC					; COMDAT

; 236  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 237  : 
; 238  : 	CrtPrintText(
; 239  : 		"help		:	View available commands and their description. \r\n"
; 240  : 		"ver		:	Show the version information of the OS and OS shell. \r\n"
; 241  : 		"cls		:	Clear screen. \r\n"
; 242  : 		"dir		:	Display all files in the current directory. \r\n"
; 243  : 		"toggle		:	Show/hide soft task-switching watchdog clock. \r\n"
; 244  : 		"ps			:	Display process state. \r\n"
; 245  : 		"free		:	Display memory using state. \r\n"
; 246  : 
; 247  : 
; 248  : 		"\r\n"
; 249  : 		);

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BEG@HPGKONKG@help?7?7?3?7View?5available?5commands?5@
  0000e	e8 00 00 00 00	 call	 _CrtPrintText
  00013	83 c4 04	 add	 esp, 4

; 250  : 
; 251  : 	return TRUE;

  00016	b8 01 00 00 00	 mov	 eax, 1

; 252  : }

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
_Hshp_CMD_help ENDP
_TEXT	ENDS
PUBLIC	??_C@_0KH@IFCACION@OS?5Version?7?7?3?5mylysOS?5OS?7?$CI?$CFs?$CJ?5?$AN?6@ ; `string'
PUBLIC	??_C@_0BK@GGEDINEJ@1st?5released?4?52016?905?927?4?$AA@ ; `string'
;	COMDAT ??_C@_0KH@IFCACION@OS?5Version?7?7?3?5mylysOS?5OS?7?$CI?$CFs?$CJ?5?$AN?6@
CONST	SEGMENT
??_C@_0KH@IFCACION@OS?5Version?7?7?3?5mylysOS?5OS?7?$CI?$CFs?$CJ?5?$AN?6@ DB 'O'
	DB	'S Version', 09H, 09H, ': mylysOS OS', 09H, '(%s) ', 0dH, 0aH, 'S'
	DB	'hell Version', 09H, ': OS Shell (%s) ', 0dH, 0aH, 'Developer', 09H
	DB	09H, ': LeeYunSeong ', 0dH, 0aH, 'e-Mail', 09H, 09H, 09H, ': s'
	DB	'wack9751@naver.com', 0dH, 0aH, 'Homepage', 09H, 09H, ': dcsla'
	DB	'b.hanyang.ac.kr/lecture ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GGEDINEJ@1st?5released?4?52016?905?927?4?$AA@
CONST	SEGMENT
??_C@_0BK@GGEDINEJ@1st?5released?4?52016?905?927?4?$AA@ DB '1st released.'
	DB	' 2016-05-27.', 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _Hshp_CMD_ver
_TEXT	SEGMENT
_pParameters$ = 8					; size = 4
_Hshp_CMD_ver PROC					; COMDAT

; 258  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 259  : 
; 260  : 	CrtPrintf(
; 261  : 		"OS Version		: mylysOS OS	(%s) \r\n"
; 262  : 		"Shell Version	: OS Shell (%s) \r\n"
; 263  : 		"Developer		: LeeYunSeong \r\n"
; 264  : 		"e-Mail			: swack9751@naver.com\r\n"
; 265  : 		"Homepage		: dcslab.hanyang.ac.kr/lecture \r\n"
; 266  : 		, MYLYSOS_OS_VER, OS_SHELL_VER
; 267  : 	);

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@GGEDINEJ@1st?5released?4?52016?905?927?4?$AA@
  0000e	68 00 00 00 00	 push	 OFFSET ??_C@_0BK@GGEDINEJ@1st?5released?4?52016?905?927?4?$AA@
  00013	68 00 00 00 00	 push	 OFFSET ??_C@_0KH@IFCACION@OS?5Version?7?7?3?5mylysOS?5OS?7?$CI?$CFs?$CJ?5?$AN?6@
  00018	e8 00 00 00 00	 call	 _CrtPrintf
  0001d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 268  : 
; 269  : 	return TRUE;

  00020	b8 01 00 00 00	 mov	 eax, 1

; 270  : }

  00025	5f		 pop	 edi
  00026	5e		 pop	 esi
  00027	5b		 pop	 ebx
  00028	8b e5		 mov	 esp, ebp
  0002a	5d		 pop	 ebp
  0002b	c3		 ret	 0
_Hshp_CMD_ver ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BL@HFOAKNFG@ERROE?3?5file?5open?5error?$CB?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@GACJHGPN@ERROR?5?3?5this?5is?5not?5executable?5f@ ; `string'
PUBLIC	??_C@_03JNNAEMKE@EXE?$AA@			; `string'
PUBLIC	??_C@_04EEHPFMA@?4EXE?$AA@			; `string'
EXTRN	_PsDeleteThread:PROC
EXTRN	_PsGetThreadStatus:PROC
EXTRN	_FsCloseFile:PROC
EXTRN	_PsCreateUserThread:PROC
EXTRN	_PsGetParentProcess:PROC
EXTRN	_PsGetCurrentThread:PROC
EXTRN	_FsReadFile:PROC
EXTRN	_FsOpenFile:PROC
EXTRN	_strcat:PROC
EXTRN	_strrchr:PROC
EXTRN	_strcpy:PROC
;	COMDAT ??_C@_0BL@HFOAKNFG@ERROE?3?5file?5open?5error?$CB?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BL@HFOAKNFG@ERROE?3?5file?5open?5error?$CB?5?$AN?6?$AA@ DB 'ERROE:'
	DB	' file open error! ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@GACJHGPN@ERROR?5?3?5this?5is?5not?5executable?5f@
CONST	SEGMENT
??_C@_0CI@GACJHGPN@ERROR?5?3?5this?5is?5not?5executable?5f@ DB 'ERROR : t'
	DB	'his is not executable file. ', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03JNNAEMKE@EXE?$AA@
CONST	SEGMENT
??_C@_03JNNAEMKE@EXE?$AA@ DB 'EXE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04EEHPFMA@?4EXE?$AA@
CONST	SEGMENT
??_C@_04EEHPFMA@?4EXE?$AA@ DB '.EXE', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _Hshp_CMD_excute
_TEXT	SEGMENT
_UserThread$ = -36					; size = 4
_hFile$ = -32						; size = 4
_pPos$ = -28						; size = 4
_pAddr$ = -24						; size = 4
_buffer$ = -20						; size = 13
_length$ = -4						; size = 4
_pCmd$ = 8						; size = 4
_pParameters$ = 12					; size = 4
_Hshp_CMD_excute PROC					; COMDAT

; 274  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 275  : 	int length;
; 276  : 	BYTE buffer[8+3+1+1], *pAddr = (BYTE *)0x00100000, *pPos;

  00009	c7 45 e8 00 00
	10 00		 mov	 DWORD PTR _pAddr$[ebp], 1048576 ; 00100000H

; 277  : 	HANDLE hFile, UserThread;
; 278  : 
; 279  : 	//NULL 값 확인
; 280  : 	length = strlen(pCmd);

  00010	8b 45 08	 mov	 eax, DWORD PTR _pCmd$[ebp]
  00013	50		 push	 eax
  00014	e8 00 00 00 00	 call	 _strlen
  00019	83 c4 04	 add	 esp, 4
  0001c	89 45 fc	 mov	 DWORD PTR _length$[ebp], eax

; 281  : 	if(!length) return 0;

  0001f	83 7d fc 00	 cmp	 DWORD PTR _length$[ebp], 0
  00023	75 07		 jne	 SHORT $LN10@Hshp_CMD_e
  00025	33 c0		 xor	 eax, eax
  00027	e9 4a 01 00 00	 jmp	 $LN11@Hshp_CMD_e
$LN10@Hshp_CMD_e:

; 282  : 
; 283  : 	//buffer 초기화
; 284  : 	memset(buffer, 0, 8+3+1+1);

  0002c	6a 0d		 push	 13			; 0000000dH
  0002e	6a 00		 push	 0
  00030	8d 45 ec	 lea	 eax, DWORD PTR _buffer$[ebp]
  00033	50		 push	 eax
  00034	e8 00 00 00 00	 call	 _memset
  00039	83 c4 0c	 add	 esp, 12			; 0000000cH

; 285  : 	strcpy(buffer, pCmd);

  0003c	8b 45 08	 mov	 eax, DWORD PTR _pCmd$[ebp]
  0003f	50		 push	 eax
  00040	8d 4d ec	 lea	 ecx, DWORD PTR _buffer$[ebp]
  00043	51		 push	 ecx
  00044	e8 00 00 00 00	 call	 _strcpy
  00049	83 c4 08	 add	 esp, 8

; 286  : 	strupr(buffer);

  0004c	8d 45 ec	 lea	 eax, DWORD PTR _buffer$[ebp]
  0004f	50		 push	 eax
  00050	e8 00 00 00 00	 call	 _strupr
  00055	83 c4 04	 add	 esp, 4

; 287  : 
; 288  : 	//EXE 파일이 아닌 경우는 실행을 금지시킨다.
; 289  : 	if((pPos = strrchr(buffer, '.')) == NULL) {

  00058	6a 2e		 push	 46			; 0000002eH
  0005a	8d 45 ec	 lea	 eax, DWORD PTR _buffer$[ebp]
  0005d	50		 push	 eax
  0005e	e8 00 00 00 00	 call	 _strrchr
  00063	83 c4 08	 add	 esp, 8
  00066	89 45 e4	 mov	 DWORD PTR _pPos$[ebp], eax
  00069	83 7d e4 00	 cmp	 DWORD PTR _pPos$[ebp], 0
  0006d	75 13		 jne	 SHORT $LN9@Hshp_CMD_e

; 290  : 		strcat(buffer, ".EXE");

  0006f	68 00 00 00 00	 push	 OFFSET ??_C@_04EEHPFMA@?4EXE?$AA@
  00074	8d 45 ec	 lea	 eax, DWORD PTR _buffer$[ebp]
  00077	50		 push	 eax
  00078	e8 00 00 00 00	 call	 _strcat
  0007d	83 c4 08	 add	 esp, 8

; 291  : 	} else {

  00080	eb 32		 jmp	 SHORT $LN8@Hshp_CMD_e
$LN9@Hshp_CMD_e:

; 292  : 		if(strcmp(++pPos, "EXE")) {

  00082	8b 45 e4	 mov	 eax, DWORD PTR _pPos$[ebp]
  00085	83 c0 01	 add	 eax, 1
  00088	89 45 e4	 mov	 DWORD PTR _pPos$[ebp], eax
  0008b	68 00 00 00 00	 push	 OFFSET ??_C@_03JNNAEMKE@EXE?$AA@
  00090	8b 4d e4	 mov	 ecx, DWORD PTR _pPos$[ebp]
  00093	51		 push	 ecx
  00094	e8 00 00 00 00	 call	 _strcmp
  00099	83 c4 08	 add	 esp, 8
  0009c	85 c0		 test	 eax, eax
  0009e	74 14		 je	 SHORT $LN8@Hshp_CMD_e

; 293  : 			CrtPrintText("ERROR : this is not executable file. \r\n");

  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@GACJHGPN@ERROR?5?3?5this?5is?5not?5executable?5f@
  000a5	e8 00 00 00 00	 call	 _CrtPrintText
  000aa	83 c4 04	 add	 esp, 4

; 294  : 			return 0;

  000ad	33 c0		 xor	 eax, eax
  000af	e9 c2 00 00 00	 jmp	 $LN11@Hshp_CMD_e
$LN8@Hshp_CMD_e:

; 295  : 		}
; 296  : 	}
; 297  : 
; 298  : 	//파일 오픈
; 299  : 	hFile = FsOpenFile(buffer, OF_READ_ONLY);

  000b4	6a 01		 push	 1
  000b6	8d 45 ec	 lea	 eax, DWORD PTR _buffer$[ebp]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 _FsOpenFile
  000bf	83 c4 08	 add	 esp, 8
  000c2	89 45 e0	 mov	 DWORD PTR _hFile$[ebp], eax

; 300  : 	if(!hFile) {

  000c5	83 7d e0 00	 cmp	 DWORD PTR _hFile$[ebp], 0
  000c9	75 14		 jne	 SHORT $LN5@Hshp_CMD_e

; 301  : 		CrtPrintText("ERROE: file open error! \r\n");

  000cb	68 00 00 00 00	 push	 OFFSET ??_C@_0BL@HFOAKNFG@ERROE?3?5file?5open?5error?$CB?5?$AN?6?$AA@
  000d0	e8 00 00 00 00	 call	 _CrtPrintText
  000d5	83 c4 04	 add	 esp, 4

; 302  : 		return 0;

  000d8	33 c0		 xor	 eax, eax
  000da	e9 97 00 00 00	 jmp	 $LN11@Hshp_CMD_e
$LN5@Hshp_CMD_e:

; 303  : 	}
; 304  : 
; 305  : 	//오픈한 파일의 데이터를 읽어서 pAddr에 저장하는 함수
; 306  : 	while(FsReadFile(hFile, pAddr, 256) != 0) {

  000df	68 00 01 00 00	 push	 256			; 00000100H
  000e4	8b 45 e8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  000e7	50		 push	 eax
  000e8	8b 4d e0	 mov	 ecx, DWORD PTR _hFile$[ebp]
  000eb	51		 push	 ecx
  000ec	e8 00 00 00 00	 call	 _FsReadFile
  000f1	83 c4 0c	 add	 esp, 12			; 0000000cH
  000f4	85 c0		 test	 eax, eax
  000f6	74 0d		 je	 SHORT $LN4@Hshp_CMD_e

; 307  : 		pAddr += 256;

  000f8	8b 45 e8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  000fb	05 00 01 00 00	 add	 eax, 256		; 00000100H
  00100	89 45 e8	 mov	 DWORD PTR _pAddr$[ebp], eax

; 308  : 	}

  00103	eb da		 jmp	 SHORT $LN5@Hshp_CMD_e
$LN4@Hshp_CMD_e:

; 309  : 
; 310  : 	//해당 실행 파일을 실행 시킬 수 있도록 쓰레드 생성
; 311  : 	//유제 쓰레드 생성
; 312  : 	if(!PsCreateUserThread(&UserThread, PsGetParentProcess(PsGetCurrentThread()), NULL)) {

  00105	6a 00		 push	 0
  00107	e8 00 00 00 00	 call	 _PsGetCurrentThread
  0010c	50		 push	 eax
  0010d	e8 00 00 00 00	 call	 _PsGetParentProcess
  00112	83 c4 04	 add	 esp, 4
  00115	50		 push	 eax
  00116	8d 45 dc	 lea	 eax, DWORD PTR _UserThread$[ebp]
  00119	50		 push	 eax
  0011a	e8 00 00 00 00	 call	 _PsCreateUserThread
  0011f	83 c4 0c	 add	 esp, 12			; 0000000cH
  00122	85 c0		 test	 eax, eax
  00124	75 10		 jne	 SHORT $LN3@Hshp_CMD_e

; 313  : 		FsCloseFile(hFile);

  00126	8b 45 e0	 mov	 eax, DWORD PTR _hFile$[ebp]
  00129	50		 push	 eax
  0012a	e8 00 00 00 00	 call	 _FsCloseFile
  0012f	83 c4 04	 add	 esp, 4

; 314  : 		return 0;

  00132	33 c0		 xor	 eax, eax
  00134	eb 40		 jmp	 SHORT $LN11@Hshp_CMD_e
$LN3@Hshp_CMD_e:

; 315  : 	}
; 316  : 
; 317  : 	//쓰레드 상태 대기상태로 변경
; 318  : 	PsSetThreadStatus(UserThread, THREAD_STATUS_READY);

  00136	6a 02		 push	 2
  00138	8b 45 dc	 mov	 eax, DWORD PTR _UserThread$[ebp]
  0013b	50		 push	 eax
  0013c	e8 00 00 00 00	 call	 _PsSetThreadStatus
  00141	83 c4 08	 add	 esp, 8
$LN2@Hshp_CMD_e:

; 319  : 	while(PsGetThreadStatus(UserThread) != THREAD_STATUS_TERMINATED) {

  00144	8b 45 dc	 mov	 eax, DWORD PTR _UserThread$[ebp]
  00147	50		 push	 eax
  00148	e8 00 00 00 00	 call	 _PsGetThreadStatus
  0014d	83 c4 04	 add	 esp, 4
  00150	83 f8 01	 cmp	 eax, 1
  00153	74 07		 je	 SHORT $LN1@Hshp_CMD_e

; 320  : 		//테스크 스위칭
; 321  : 		HalTaskSwitch();

  00155	e8 00 00 00 00	 call	 _HalTaskSwitch

; 322  : 	}

  0015a	eb e8		 jmp	 SHORT $LN2@Hshp_CMD_e
$LN1@Hshp_CMD_e:

; 323  : 
; 324  : 	//쓰레드가 종료되면 유저쓰레드 삭제
; 325  : 	PsDeleteThread(UserThread);

  0015c	8b 45 dc	 mov	 eax, DWORD PTR _UserThread$[ebp]
  0015f	50		 push	 eax
  00160	e8 00 00 00 00	 call	 _PsDeleteThread
  00165	83 c4 04	 add	 esp, 4

; 326  : 
; 327  : 	//파일 닫기
; 328  : 	FsCloseFile(hFile);

  00168	8b 45 e0	 mov	 eax, DWORD PTR _hFile$[ebp]
  0016b	50		 push	 eax
  0016c	e8 00 00 00 00	 call	 _FsCloseFile
  00171	83 c4 04	 add	 esp, 4

; 329  : 
; 330  : 	return 0;

  00174	33 c0		 xor	 eax, eax
$LN11@Hshp_CMD_e:

; 331  : }

  00176	5f		 pop	 edi
  00177	5e		 pop	 esi
  00178	5b		 pop	 ebx
  00179	8b e5		 mov	 esp, ebp
  0017b	5d		 pop	 ebp
  0017c	c3		 ret	 0
_Hshp_CMD_excute ENDP
_TEXT	ENDS
PUBLIC	??_C@_02PCIJFNDE@?$AN?6?$AA@			; `string'
PUBLIC	??_C@_02DKCKIIND@?$CFs?$AA@			; `string'
PUBLIC	??_C@_0BO@FNCEECAM@ERROR?3?5?5?8?$CFs?8?5is?5not?5exist?$CB?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@BMMHEOJD@ERROR?5?3?5No?5selected?5files?4?5?$AN?6?$AA@ ; `string'
;	COMDAT ??_C@_02PCIJFNDE@?$AN?6?$AA@
CONST	SEGMENT
??_C@_02PCIJFNDE@?$AN?6?$AA@ DB 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DKCKIIND@?$CFs?$AA@
CONST	SEGMENT
??_C@_02DKCKIIND@?$CFs?$AA@ DB '%s', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@FNCEECAM@ERROR?3?5?5?8?$CFs?8?5is?5not?5exist?$CB?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BO@FNCEECAM@ERROR?3?5?5?8?$CFs?8?5is?5not?5exist?$CB?5?$AN?6?$AA@ DB 'E'
	DB	'RROR:  ''%s'' is not exist! ', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BMMHEOJD@ERROR?5?3?5No?5selected?5files?4?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BO@BMMHEOJD@ERROR?5?3?5No?5selected?5files?4?5?$AN?6?$AA@ DB 'ERRO'
	DB	'R : No selected files. ', 0dH, 0aH, 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _Hshp_CMD_type
_TEXT	SEGMENT
_buffer$ = -264						; size = 257
_hFile$ = -4						; size = 4
_pParameters$ = 8					; size = 4
_Hshp_CMD_type PROC					; COMDAT

; 376  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 48 01 00
	00		 sub	 esp, 328		; 00000148H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi

; 377  : #define TYPE_BUFFER_SIZE		256
; 378  : 	HANDLE hFile;
; 379  : 	BYTE buffer[TYPE_BUFFER_SIZE+1];
; 380  : 	buffer[TYPE_BUFFER_SIZE]='\0';

  0000c	c6 45 f8 00	 mov	 BYTE PTR _buffer$[ebp+256], 0

; 381  : 	
; 382  : 	if(pParameters == NULL || strlen(pParameters) == 0) {

  00010	83 7d 08 00	 cmp	 DWORD PTR _pParameters$[ebp], 0
  00014	74 10		 je	 SHORT $LN4@Hshp_CMD_t
  00016	8b 45 08	 mov	 eax, DWORD PTR _pParameters$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _strlen
  0001f	83 c4 04	 add	 esp, 4
  00022	85 c0		 test	 eax, eax
  00024	75 14		 jne	 SHORT $LN5@Hshp_CMD_t
$LN4@Hshp_CMD_t:

; 383  : 		CrtPrintText("ERROR : No selected files. \r\n");

  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@BMMHEOJD@ERROR?5?3?5No?5selected?5files?4?5?$AN?6?$AA@
  0002b	e8 00 00 00 00	 call	 _CrtPrintText
  00030	83 c4 04	 add	 esp, 4

; 384  : 		return FALSE;

  00033	33 c0		 xor	 eax, eax
  00035	e9 a8 00 00 00	 jmp	 $LN6@Hshp_CMD_t
$LN5@Hshp_CMD_t:

; 385  : 	}
; 386  : 
; 387  : 	//파일 오픈
; 388  : 	hFile=FsOpenFile(pParameters, OF_READ_ONLY);

  0003a	6a 01		 push	 1
  0003c	8b 45 08	 mov	 eax, DWORD PTR _pParameters$[ebp]
  0003f	50		 push	 eax
  00040	e8 00 00 00 00	 call	 _FsOpenFile
  00045	83 c4 08	 add	 esp, 8
  00048	89 45 fc	 mov	 DWORD PTR _hFile$[ebp], eax

; 389  : 	if(!hFile) {

  0004b	83 7d fc 00	 cmp	 DWORD PTR _hFile$[ebp], 0
  0004f	75 15		 jne	 SHORT $LN3@Hshp_CMD_t

; 390  : 		CrtPrintf("ERROR:  '%s' is not exist! \r\n", pParameters);

  00051	8b 45 08	 mov	 eax, DWORD PTR _pParameters$[ebp]
  00054	50		 push	 eax
  00055	68 00 00 00 00	 push	 OFFSET ??_C@_0BO@FNCEECAM@ERROR?3?5?5?8?$CFs?8?5is?5not?5exist?$CB?5?$AN?6?$AA@
  0005a	e8 00 00 00 00	 call	 _CrtPrintf
  0005f	83 c4 08	 add	 esp, 8

; 391  : 		return FALSE;

  00062	33 c0		 xor	 eax, eax
  00064	eb 7c		 jmp	 SHORT $LN6@Hshp_CMD_t
$LN3@Hshp_CMD_t:

; 392  : 	}
; 393  : 
; 394  : 	//파일 내용을 읽어온다
; 395  : 	memset(buffer, 0, TYPE_BUFFER_SIZE);

  00066	68 00 01 00 00	 push	 256			; 00000100H
  0006b	6a 00		 push	 0
  0006d	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  00073	50		 push	 eax
  00074	e8 00 00 00 00	 call	 _memset
  00079	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@Hshp_CMD_t:

; 396  : 	while(FsReadFile(hFile, buffer, TYPE_BUFFER_SIZE) != 0) {

  0007c	68 00 01 00 00	 push	 256			; 00000100H
  00081	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  00087	50		 push	 eax
  00088	8b 4d fc	 mov	 ecx, DWORD PTR _hFile$[ebp]
  0008b	51		 push	 ecx
  0008c	e8 00 00 00 00	 call	 _FsReadFile
  00091	83 c4 0c	 add	 esp, 12			; 0000000cH
  00094	85 c0		 test	 eax, eax
  00096	74 2c		 je	 SHORT $LN1@Hshp_CMD_t

; 397  : 		CrtPrintf("%s", buffer);

  00098	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  0009e	50		 push	 eax
  0009f	68 00 00 00 00	 push	 OFFSET ??_C@_02DKCKIIND@?$CFs?$AA@
  000a4	e8 00 00 00 00	 call	 _CrtPrintf
  000a9	83 c4 08	 add	 esp, 8

; 398  : 		memset(buffer, 0, TYPE_BUFFER_SIZE);

  000ac	68 00 01 00 00	 push	 256			; 00000100H
  000b1	6a 00		 push	 0
  000b3	8d 85 f8 fe ff
	ff		 lea	 eax, DWORD PTR _buffer$[ebp]
  000b9	50		 push	 eax
  000ba	e8 00 00 00 00	 call	 _memset
  000bf	83 c4 0c	 add	 esp, 12			; 0000000cH

; 399  : 	}

  000c2	eb b8		 jmp	 SHORT $LN2@Hshp_CMD_t
$LN1@Hshp_CMD_t:

; 400  : 	CrtPrintf("\r\n");

  000c4	68 00 00 00 00	 push	 OFFSET ??_C@_02PCIJFNDE@?$AN?6?$AA@
  000c9	e8 00 00 00 00	 call	 _CrtPrintf
  000ce	83 c4 04	 add	 esp, 4

; 401  : 
; 402  : 	FsCloseFile(hFile);

  000d1	8b 45 fc	 mov	 eax, DWORD PTR _hFile$[ebp]
  000d4	50		 push	 eax
  000d5	e8 00 00 00 00	 call	 _FsCloseFile
  000da	83 c4 04	 add	 esp, 4

; 403  : 
; 404  : 	return TRUE;

  000dd	b8 01 00 00 00	 mov	 eax, 1
$LN6@Hshp_CMD_t:

; 405  : }

  000e2	5f		 pop	 edi
  000e3	5e		 pop	 esi
  000e4	5b		 pop	 ebx
  000e5	8b e5		 mov	 esp, ebp
  000e7	5d		 pop	 ebp
  000e8	c3		 ret	 0
_Hshp_CMD_type ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BM@DNEELDPM@?7?7?7Total?5Directories?3?5?$CFd?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CN@CBIFEMAD@?7?7?7Total?5File?5Size?3?5?$CFd?5bytes?5?7?5?$CI@ ; `string'
EXTRN	_FsGetFileList:PROC
;	COMDAT ??_C@_0BM@DNEELDPM@?7?7?7Total?5Directories?3?5?$CFd?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BM@DNEELDPM@?7?7?7Total?5Directories?3?5?$CFd?5?$AN?6?$AA@ DB 09H, 09H
	DB	09H, 'Total Directories: %d ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@CBIFEMAD@?7?7?7Total?5File?5Size?3?5?$CFd?5bytes?5?7?5?$CI@
CONST	SEGMENT
??_C@_0CN@CBIFEMAD@?7?7?7Total?5File?5Size?3?5?$CFd?5bytes?5?7?5?$CI@ DB 09H
	DB	09H, 09H, 'Total File Size: %d bytes ', 09H, ' (%d Files) ', 0dH
	DB	0aH, 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _Hshp_CMD_dir
_TEXT	SEGMENT
_dir_cmd_context$ = -8					; size = 8
_pParameters$ = 8					; size = 4
_Hshp_CMD_dir PROC					; COMDAT

; 408  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 409  : 	DIR_CMD_CONTEXT dir_cmd_context;
; 410  : 	//초기화
; 411  : 	dir_cmd_context.dir_cnt =0;

  00009	66 c7 45 fa 00
	00		 mov	 WORD PTR _dir_cmd_context$[ebp+2], 0

; 412  : 	dir_cmd_context.file_cnt =0;

  0000f	66 c7 45 f8 00
	00		 mov	 WORD PTR _dir_cmd_context$[ebp], 0

; 413  : 	dir_cmd_context.total_file_size =0;

  00015	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dir_cmd_context$[ebp+4], 0

; 414  : 	
; 415  : 
; 416  : 	//현재 디렉토리의 파일 정보를 가지고 온다.
; 417  : 	FsGetFileList(Hshp_dir_callback, &dir_cmd_context);

  0001c	8d 45 f8	 lea	 eax, DWORD PTR _dir_cmd_context$[ebp]
  0001f	50		 push	 eax
  00020	68 00 00 00 00	 push	 OFFSET _Hshp_dir_callback
  00025	e8 00 00 00 00	 call	 _FsGetFileList
  0002a	83 c4 08	 add	 esp, 8

; 418  : 	CrtPrintf("\t\t\tTotal File Size: %d bytes \t (%d Files) \r\n",
; 419  : 		dir_cmd_context.total_file_size, dir_cmd_context.file_cnt);

  0002d	0f b7 45 f8	 movzx	 eax, WORD PTR _dir_cmd_context$[ebp]
  00031	50		 push	 eax
  00032	8b 4d fc	 mov	 ecx, DWORD PTR _dir_cmd_context$[ebp+4]
  00035	51		 push	 ecx
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_0CN@CBIFEMAD@?7?7?7Total?5File?5Size?3?5?$CFd?5bytes?5?7?5?$CI@
  0003b	e8 00 00 00 00	 call	 _CrtPrintf
  00040	83 c4 0c	 add	 esp, 12			; 0000000cH

; 420  : 	CrtPrintf("\t\t\tTotal Directories: %d \r\n", dir_cmd_context.dir_cnt);

  00043	0f b7 45 fa	 movzx	 eax, WORD PTR _dir_cmd_context$[ebp+2]
  00047	50		 push	 eax
  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0BM@DNEELDPM@?7?7?7Total?5Directories?3?5?$CFd?5?$AN?6?$AA@
  0004d	e8 00 00 00 00	 call	 _CrtPrintf
  00052	83 c4 08	 add	 esp, 8

; 421  : 
; 422  : 	return TRUE;

  00055	b8 01 00 00 00	 mov	 eax, 1

; 423  : }

  0005a	5f		 pop	 edi
  0005b	5e		 pop	 esi
  0005c	5b		 pop	 ebx
  0005d	8b e5		 mov	 esp, ebp
  0005f	5d		 pop	 ebp
  00060	c3		 ret	 0
_Hshp_CMD_dir ENDP
_TEXT	ENDS
PUBLIC	??_C@_0DA@LHPHMEJH@?$CF0d?9?$CF02d?9?$CF02d?5?7?5?$CF02d?3?$CF02d?5?$CFs?5?$CF7d@ ; `string'
PUBLIC	??_C@_05IFKLLJBC@?5?5?5?5?5?$AA@		; `string'
PUBLIC	??_C@_05FIBHJBBH@?$DMDIR?$DO?$AA@		; `string'
PUBLIC	??_C@_04GPOGLGKJ@A?4M?4?$AA@			; `string'
PUBLIC	??_C@_04DCGGAIJL@P?4M?4?$AA@			; `string'
;	COMDAT ??_C@_0DA@LHPHMEJH@?$CF0d?9?$CF02d?9?$CF02d?5?7?5?$CF02d?3?$CF02d?5?$CFs?5?$CF7d@
CONST	SEGMENT
??_C@_0DA@LHPHMEJH@?$CF0d?9?$CF02d?9?$CF02d?5?7?5?$CF02d?3?$CF02d?5?$CFs?5?$CF7d@ DB '%'
	DB	'0d-%02d-%02d ', 09H, ' %02d:%02d %s %7d bytes %s %s ', 0dH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_05IFKLLJBC@?5?5?5?5?5?$AA@
CONST	SEGMENT
??_C@_05IFKLLJBC@?5?5?5?5?5?$AA@ DB '     ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05FIBHJBBH@?$DMDIR?$DO?$AA@
CONST	SEGMENT
??_C@_05FIBHJBBH@?$DMDIR?$DO?$AA@ DB '<DIR>', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04GPOGLGKJ@A?4M?4?$AA@
CONST	SEGMENT
??_C@_04GPOGLGKJ@A?4M?4?$AA@ DB 'A.M.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04DCGGAIJL@P?4M?4?$AA@
CONST	SEGMENT
??_C@_04DCGGAIJL@P?4M?4?$AA@ DB 'P.M.', 00H		; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _Hshp_dir_callback
_TEXT	SEGMENT
_pContext$ = -36					; size = 4
_pDir$ = -32						; size = 4
_pAmPm$ = -28						; size = 4
_second$ = -24						; size = 2
_minute$ = -20						; size = 2
_hour$ = -16						; size = 2
_day$ = -12						; size = 2
_month$ = -8						; size = 2
_year$ = -4						; size = 2
_pFileInfo$ = 8						; size = 4
_Context$ = 12						; size = 4
_Hshp_dir_callback PROC					; COMDAT

; 337  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 338  : 	WORD year, month, day;
; 339  : 	WORD hour, minute, second;
; 340  : 	BYTE *pAmPm;
; 341  : 	BYTE *pDir;
; 342  : 	PDIR_CMD_CONTEXT pContext = (PDIR_CMD_CONTEXT)Context;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _Context$[ebp]
  0000c	89 45 dc	 mov	 DWORD PTR _pContext$[ebp], eax

; 343  : 
; 344  : 	second = (pFileInfo->time) & 0x001f;

  0000f	8b 45 08	 mov	 eax, DWORD PTR _pFileInfo$[ebp]
  00012	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  00016	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00019	66 89 4d e8	 mov	 WORD PTR _second$[ebp], cx

; 345  : 	minute = (pFileInfo->time >> 5) & 0x003f;

  0001d	8b 45 08	 mov	 eax, DWORD PTR _pFileInfo$[ebp]
  00020	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  00024	c1 f9 05	 sar	 ecx, 5
  00027	83 e1 3f	 and	 ecx, 63			; 0000003fH
  0002a	66 89 4d ec	 mov	 WORD PTR _minute$[ebp], cx

; 346  : 	hour = (pFileInfo->time >> 11 ) & 0x001f;

  0002e	8b 45 08	 mov	 eax, DWORD PTR _pFileInfo$[ebp]
  00031	0f b7 48 0e	 movzx	 ecx, WORD PTR [eax+14]
  00035	c1 f9 0b	 sar	 ecx, 11			; 0000000bH
  00038	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0003b	66 89 4d f0	 mov	 WORD PTR _hour$[ebp], cx

; 347  : 
; 348  : 	if(hour > 12) {

  0003f	0f b7 45 f0	 movzx	 eax, WORD PTR _hour$[ebp]
  00043	83 f8 0c	 cmp	 eax, 12			; 0000000cH
  00046	7e 14		 jle	 SHORT $LN4@Hshp_dir_c

; 349  : 		hour -=12;

  00048	0f b7 45 f0	 movzx	 eax, WORD PTR _hour$[ebp]
  0004c	83 e8 0c	 sub	 eax, 12			; 0000000cH
  0004f	66 89 45 f0	 mov	 WORD PTR _hour$[ebp], ax

; 350  : 		pAmPm = "P.M.";

  00053	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _pAmPm$[ebp], OFFSET ??_C@_04DCGGAIJL@P?4M?4?$AA@

; 351  : 	} else {

  0005a	eb 07		 jmp	 SHORT $LN3@Hshp_dir_c
$LN4@Hshp_dir_c:

; 352  : 		pAmPm = "A.M.";

  0005c	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _pAmPm$[ebp], OFFSET ??_C@_04GPOGLGKJ@A?4M?4?$AA@
$LN3@Hshp_dir_c:

; 353  : 	}
; 354  : 
; 355  : 	day = (pFileInfo->date) & 0x001f;

  00063	8b 45 08	 mov	 eax, DWORD PTR _pFileInfo$[ebp]
  00066	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  0006a	83 e1 1f	 and	 ecx, 31			; 0000001fH
  0006d	66 89 4d f4	 mov	 WORD PTR _day$[ebp], cx

; 356  : 	month = (pFileInfo->date >> 5 ) & 0x000f;

  00071	8b 45 08	 mov	 eax, DWORD PTR _pFileInfo$[ebp]
  00074	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  00078	c1 f9 05	 sar	 ecx, 5
  0007b	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0007e	66 89 4d f8	 mov	 WORD PTR _month$[ebp], cx

; 357  : 	year = (pFileInfo->date >> 9)+1980;

  00082	8b 45 08	 mov	 eax, DWORD PTR _pFileInfo$[ebp]
  00085	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  00089	c1 f9 09	 sar	 ecx, 9
  0008c	81 c1 bc 07 00
	00		 add	 ecx, 1980		; 000007bcH
  00092	66 89 4d fc	 mov	 WORD PTR _year$[ebp], cx

; 358  : 
; 359  : 	if(pFileInfo->attribute & FILE_ATTR_DIRECTORY) {

  00096	8b 45 08	 mov	 eax, DWORD PTR _pFileInfo$[ebp]
  00099	0f b6 48 0d	 movzx	 ecx, BYTE PTR [eax+13]
  0009d	83 e1 10	 and	 ecx, 16			; 00000010H
  000a0	74 1b		 je	 SHORT $LN2@Hshp_dir_c

; 360  : 		pDir = "<DIR>";

  000a2	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _pDir$[ebp], OFFSET ??_C@_05FIBHJBBH@?$DMDIR?$DO?$AA@

; 361  : 		pContext->dir_cnt++;

  000a9	8b 45 dc	 mov	 eax, DWORD PTR _pContext$[ebp]
  000ac	66 8b 48 02	 mov	 cx, WORD PTR [eax+2]
  000b0	66 83 c1 01	 add	 cx, 1
  000b4	8b 55 dc	 mov	 edx, DWORD PTR _pContext$[ebp]
  000b7	66 89 4a 02	 mov	 WORD PTR [edx+2], cx

; 362  : 	} else {

  000bb	eb 17		 jmp	 SHORT $LN1@Hshp_dir_c
$LN2@Hshp_dir_c:

; 363  : 		pDir = "     ";

  000bd	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _pDir$[ebp], OFFSET ??_C@_05IFKLLJBC@?5?5?5?5?5?$AA@

; 364  : 		pContext->file_cnt++;

  000c4	8b 45 dc	 mov	 eax, DWORD PTR _pContext$[ebp]
  000c7	66 8b 08	 mov	 cx, WORD PTR [eax]
  000ca	66 83 c1 01	 add	 cx, 1
  000ce	8b 55 dc	 mov	 edx, DWORD PTR _pContext$[ebp]
  000d1	66 89 0a	 mov	 WORD PTR [edx], cx
$LN1@Hshp_dir_c:

; 365  : 	}
; 366  : 
; 367  : 	pContext->total_file_size += pFileInfo->filesize;

  000d4	8b 45 dc	 mov	 eax, DWORD PTR _pContext$[ebp]
  000d7	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  000da	8b 55 08	 mov	 edx, DWORD PTR _pFileInfo$[ebp]
  000dd	03 4a 12	 add	 ecx, DWORD PTR [edx+18]
  000e0	8b 45 dc	 mov	 eax, DWORD PTR _pContext$[ebp]
  000e3	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 368  : 
; 369  : 	CrtPrintf("%0d-%02d-%02d \t %02d:%02d %s %7d bytes %s %s \r\n",
; 370  : 		year, month, day, hour, minute, pAmPm, pFileInfo->filesize, pDir, pFileInfo->filename);

  000e6	8b 45 08	 mov	 eax, DWORD PTR _pFileInfo$[ebp]
  000e9	50		 push	 eax
  000ea	8b 4d e0	 mov	 ecx, DWORD PTR _pDir$[ebp]
  000ed	51		 push	 ecx
  000ee	8b 55 08	 mov	 edx, DWORD PTR _pFileInfo$[ebp]
  000f1	8b 42 12	 mov	 eax, DWORD PTR [edx+18]
  000f4	50		 push	 eax
  000f5	8b 4d e4	 mov	 ecx, DWORD PTR _pAmPm$[ebp]
  000f8	51		 push	 ecx
  000f9	0f b7 55 ec	 movzx	 edx, WORD PTR _minute$[ebp]
  000fd	52		 push	 edx
  000fe	0f b7 45 f0	 movzx	 eax, WORD PTR _hour$[ebp]
  00102	50		 push	 eax
  00103	0f b7 4d f4	 movzx	 ecx, WORD PTR _day$[ebp]
  00107	51		 push	 ecx
  00108	0f b7 55 f8	 movzx	 edx, WORD PTR _month$[ebp]
  0010c	52		 push	 edx
  0010d	0f b7 45 fc	 movzx	 eax, WORD PTR _year$[ebp]
  00111	50		 push	 eax
  00112	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@LHPHMEJH@?$CF0d?9?$CF02d?9?$CF02d?5?7?5?$CF02d?3?$CF02d?5?$CFs?5?$CF7d@
  00117	e8 00 00 00 00	 call	 _CrtPrintf
  0011c	83 c4 28	 add	 esp, 40			; 00000028H

; 371  : 
; 372  : 	return TRUE;

  0011f	b8 01 00 00 00	 mov	 eax, 1

; 373  : 
; 374  : }

  00124	5f		 pop	 edi
  00125	5e		 pop	 esi
  00126	5b		 pop	 ebx
  00127	8b e5		 mov	 esp, ebp
  00129	5d		 pop	 ebp
  0012a	c3		 ret	 0
_Hshp_dir_callback ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@HHDOIDND@Process?5State?5?$AN?6?$AA@	; `string'
EXTRN	_ShellCommand_ps:PROC
;	COMDAT ??_C@_0BB@HHDOIDND@Process?5State?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BB@HHDOIDND@Process?5State?5?$AN?6?$AA@ DB 'Process State ', 0dH, 0aH
	DB	00H						; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _Hshp_CMD_ps
_TEXT	SEGMENT
_pParameters$ = 8					; size = 4
_Hshp_CMD_ps PROC					; COMDAT

; 427  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 428  : 	CrtPrintf("Process State \r\n");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@HHDOIDND@Process?5State?5?$AN?6?$AA@
  0000e	e8 00 00 00 00	 call	 _CrtPrintf
  00013	83 c4 04	 add	 esp, 4

; 429  : 	ShellCommand_ps(); //process.c에 함수를 구현해 프로세스 블럭을 사용했다.

  00016	e8 00 00 00 00	 call	 _ShellCommand_ps

; 430  : 
; 431  : 	return TRUE;

  0001b	b8 01 00 00 00	 mov	 eax, 1

; 432  : }

  00020	5f		 pop	 edi
  00021	5e		 pop	 esi
  00022	5b		 pop	 ebx
  00023	8b e5		 mov	 esp, ebp
  00025	5d		 pop	 ebp
  00026	c3		 ret	 0
_Hshp_CMD_ps ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@GAOKPDIL@Available?3?5?$CFd?5Bytes?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@ICJLNJDN@In?5use?3?5?$CFd?5Bytes?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@DLHMLAOH@Total?5Memory?5Size?3?5?$CFd?5Bytes?5?$AN?6?$AA@ ; `string'
EXTRN	_GetMemoryBlockSize:PROC
EXTRN	_GetUsedMemoryBlocks:PROC
EXTRN	_GetTotalMemoryBlocks:PROC
;	COMDAT ??_C@_0BH@GAOKPDIL@Available?3?5?$CFd?5Bytes?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BH@GAOKPDIL@Available?3?5?$CFd?5Bytes?5?$AN?6?$AA@ DB 'Available: '
	DB	'%d Bytes ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ICJLNJDN@In?5use?3?5?$CFd?5Bytes?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BE@ICJLNJDN@In?5use?3?5?$CFd?5Bytes?5?$AN?6?$AA@ DB 'In use: %d By'
	DB	'tes ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@DLHMLAOH@Total?5Memory?5Size?3?5?$CFd?5Bytes?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BP@DLHMLAOH@Total?5Memory?5Size?3?5?$CFd?5Bytes?5?$AN?6?$AA@ DB 'T'
	DB	'otal Memory Size: %d Bytes ', 0dH, 0aH, 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _Hshp_CMD_free
_TEXT	SEGMENT
_availableBytes$ = -20					; size = 4
_usedBytes$ = -16					; size = 4
_blockSize$ = -12					; size = 4
_usedBlocks$ = -8					; size = 4
_totalBytes$ = -4					; size = 4
_pParameters$ = 8					; size = 4
_Hshp_CMD_free PROC					; COMDAT

; 435  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 436  : 	DWORD totalBytes, usedBlocks, blockSize, usedBytes, availableBytes;
; 437  : 
; 438  : 	totalBytes = GetTotalMemoryBlocks();

  00009	e8 00 00 00 00	 call	 _GetTotalMemoryBlocks
  0000e	89 45 fc	 mov	 DWORD PTR _totalBytes$[ebp], eax

; 439  : 	usedBlocks = GetUsedMemoryBlocks();

  00011	e8 00 00 00 00	 call	 _GetUsedMemoryBlocks
  00016	89 45 f8	 mov	 DWORD PTR _usedBlocks$[ebp], eax

; 440  : 	blockSize = GetMemoryBlockSize();

  00019	e8 00 00 00 00	 call	 _GetMemoryBlockSize
  0001e	89 45 f4	 mov	 DWORD PTR _blockSize$[ebp], eax

; 441  : 	usedBytes = usedBlocks * blockSize;   // 사용한 메모리 크기 = 사용한 메모리 블럭 수 * 메모리 블럭 크기

  00021	8b 45 f8	 mov	 eax, DWORD PTR _usedBlocks$[ebp]
  00024	0f af 45 f4	 imul	 eax, DWORD PTR _blockSize$[ebp]
  00028	89 45 f0	 mov	 DWORD PTR _usedBytes$[ebp], eax

; 442  : 	availableBytes = totalBytes - usedBytes; // 사용가능한 메모리 공간 = 총 메모리 - 사용한 메모리

  0002b	8b 45 fc	 mov	 eax, DWORD PTR _totalBytes$[ebp]
  0002e	2b 45 f0	 sub	 eax, DWORD PTR _usedBytes$[ebp]
  00031	89 45 ec	 mov	 DWORD PTR _availableBytes$[ebp], eax

; 443  : 
; 444  : 
; 445  : 	CrtPrintf("Total Memory Size: %d Bytes \r\n", totalBytes);

  00034	8b 45 fc	 mov	 eax, DWORD PTR _totalBytes$[ebp]
  00037	50		 push	 eax
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@DLHMLAOH@Total?5Memory?5Size?3?5?$CFd?5Bytes?5?$AN?6?$AA@
  0003d	e8 00 00 00 00	 call	 _CrtPrintf
  00042	83 c4 08	 add	 esp, 8

; 446  : 	CrtPrintf("In use: %d Bytes \r\n", usedBytes);

  00045	8b 45 f0	 mov	 eax, DWORD PTR _usedBytes$[ebp]
  00048	50		 push	 eax
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@ICJLNJDN@In?5use?3?5?$CFd?5Bytes?5?$AN?6?$AA@
  0004e	e8 00 00 00 00	 call	 _CrtPrintf
  00053	83 c4 08	 add	 esp, 8

; 447  : 	CrtPrintf("Available: %d Bytes \r\n", availableBytes); 

  00056	8b 45 ec	 mov	 eax, DWORD PTR _availableBytes$[ebp]
  00059	50		 push	 eax
  0005a	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@GAOKPDIL@Available?3?5?$CFd?5Bytes?5?$AN?6?$AA@
  0005f	e8 00 00 00 00	 call	 _CrtPrintf
  00064	83 c4 08	 add	 esp, 8

; 448  : 	
; 449  : 	return TRUE;

  00067	b8 01 00 00 00	 mov	 eax, 1

; 450  : }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_Hshp_CMD_free ENDP
_TEXT	ENDS
END
