; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	c:\Users\상우\Documents\카카오톡 받은 파일\MylysOS\kbddrv.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
_m_AsciiCode DB	00H
	DB	01bH
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	030H
	DB	02dH
	DB	03dH
	DB	08H
	DB	09H
	DB	071H
	DB	077H
	DB	065H
	DB	072H
	DB	074H
	DB	079H
	DB	075H
	DB	069H
	DB	06fH
	DB	070H
	DB	05bH
	DB	05dH
	DB	0dH
	DB	00H
	DB	061H
	DB	073H
	DB	064H
	DB	066H
	DB	067H
	DB	068H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	03bH
	DB	027H
	DB	060H
	DB	00H
	DB	05cH
	DB	07aH
	DB	078H
	DB	063H
	DB	076H
	DB	062H
	DB	06eH
	DB	06dH
	DB	02cH
	DB	02eH
	DB	02fH
	DB	00H
	DB	02aH
	DB	00H
	DB	020H
	DB	00H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	08H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02dH
	DB	00H
	DB	00H
	DB	00H
	DB	02bH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	07fH
	DB	00H
	DB	00H
	DB	05cH
	DB	03H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0dH
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	07fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01bH
	DB	031H
	DB	032H
	DB	033H
	DB	034H
	DB	035H
	DB	036H
	DB	037H
	DB	038H
	DB	039H
	DB	030H
	DB	02dH
	DB	03dH
	DB	08H
	DB	09H
	DB	051H
	DB	057H
	DB	045H
	DB	052H
	DB	054H
	DB	059H
	DB	055H
	DB	049H
	DB	04fH
	DB	050H
	DB	05bH
	DB	05dH
	DB	0dH
	DB	00H
	DB	041H
	DB	053H
	DB	044H
	DB	046H
	DB	047H
	DB	048H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	03bH
	DB	027H
	DB	060H
	DB	00H
	DB	05cH
	DB	05aH
	DB	058H
	DB	043H
	DB	056H
	DB	042H
	DB	04eH
	DB	04dH
	DB	02cH
	DB	02eH
	DB	02fH
	DB	00H
	DB	02aH
	DB	00H
	DB	020H
	DB	00H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	08H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02dH
	DB	00H
	DB	00H
	DB	00H
	DB	02bH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	07fH
	DB	00H
	DB	00H
	DB	05cH
	DB	03H
	DB	03H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0dH
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	07fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01bH
	DB	021H
	DB	040H
	DB	023H
	DB	024H
	DB	025H
	DB	05eH
	DB	026H
	DB	02aH
	DB	028H
	DB	029H
	DB	05fH
	DB	02bH
	DB	07eH
	DB	07eH
	DB	051H
	DB	057H
	DB	045H
	DB	052H
	DB	054H
	DB	059H
	DB	055H
	DB	049H
	DB	04fH
	DB	050H
	DB	07bH
	DB	07dH
	DB	07eH
	DB	00H
	DB	041H
	DB	053H
	DB	044H
	DB	046H
	DB	047H
	DB	048H
	DB	04aH
	DB	04bH
	DB	04cH
	DB	03aH
	DB	027H
	DB	07eH
	DB	00H
	DB	07cH
	DB	05aH
	DB	058H
	DB	043H
	DB	056H
	DB	042H
	DB	04eH
	DB	04dH
	DB	03cH
	DB	03eH
	DB	03fH
	DB	00H
	DB	02aH
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02dH
	DB	00H
	DB	00H
	DB	00H
	DB	02bH
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	07fH
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0dH
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	07fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01bH
	DB	021H
	DB	040H
	DB	023H
	DB	024H
	DB	025H
	DB	05eH
	DB	026H
	DB	02aH
	DB	028H
	DB	029H
	DB	05fH
	DB	02bH
	DB	07eH
	DB	07eH
	DB	071H
	DB	077H
	DB	065H
	DB	072H
	DB	074H
	DB	079H
	DB	075H
	DB	069H
	DB	06fH
	DB	070H
	DB	07bH
	DB	07dH
	DB	07eH
	DB	00H
	DB	061H
	DB	073H
	DB	064H
	DB	066H
	DB	067H
	DB	068H
	DB	06aH
	DB	06bH
	DB	06cH
	DB	03aH
	DB	027H
	DB	07eH
	DB	00H
	DB	07cH
	DB	07aH
	DB	078H
	DB	063H
	DB	076H
	DB	062H
	DB	06eH
	DB	06dH
	DB	03cH
	DB	03eH
	DB	03fH
	DB	00H
	DB	02aH
	DB	00H
	DB	01H
	DB	00H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02dH
	DB	00H
	DB	00H
	DB	00H
	DB	02bH
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	07fH
	DB	00H
	DB	00H
	DB	00H
	DB	01H
	DB	01H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	0dH
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	07fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02fH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	00H
	DB	00H
	DB	07fH
	DB	07fH
	DB	011H
	DB	017H
	DB	05H
	DB	012H
	DB	014H
	DB	019H
	DB	015H
	DB	09H
	DB	0fH
	DB	010H
	DB	02H
	DB	02H
	DB	0aH
	DB	00H
	DB	01H
	DB	013H
	DB	04H
	DB	06H
	DB	07H
	DB	08H
	DB	0aH
	DB	0bH
	DB	0cH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	01aH
	DB	018H
	DB	03H
	DB	016H
	DB	02H
	DB	0eH
	DB	0dH
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	02H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
	DB	00H
_DATA	ENDS
PUBLIC	_KbdInitializeDriver
EXTRN	_PsSetThreadStatus:PROC
EXTRN	_PsCreateThread:PROC
EXTRN	_PsCreateProcess:PROC
EXTRN	_memset:PROC
_BSS	SEGMENT
_m_TranslatorThreadHandle DD 01H DUP (?)
_m_ProcessHandle DD 01H DUP (?)
_m_KbdData DB	093H DUP (?)
; Function compile flags: /Odtp /ZI
; File c:\users\상우\documents\카카오톡 받은 파일\mylysos\kbddrv.c
_BSS	ENDS
;	COMDAT _KbdInitializeDriver
_TEXT	SEGMENT
_KbdInitializeDriver PROC				; COMDAT

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 119  : 	memset(&m_KbdData, 0, sizeof(m_KbdData));

  00009	68 93 00 00 00	 push	 147			; 00000093H
  0000e	6a 00		 push	 0
  00010	68 00 00 00 00	 push	 OFFSET _m_KbdData
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 120  : 
; 121  : 	m_KbdData.indicator_status = KBD_LED_NUMLOCK;

  0001d	c6 05 00 00 00
	00 02		 mov	 BYTE PTR _m_KbdData, 2

; 122  : 
; 123  : 	KbdpResetIndicator();

  00024	e8 00 00 00 00	 call	 _KbdpResetIndicator

; 124  : 
; 125  : 	if(!PsCreateProcess(&m_ProcessHandle))

  00029	68 00 00 00 00	 push	 OFFSET _m_ProcessHandle
  0002e	e8 00 00 00 00	 call	 _PsCreateProcess
  00033	83 c4 04	 add	 esp, 4
  00036	85 c0		 test	 eax, eax
  00038	75 04		 jne	 SHORT $LN2@KbdInitial

; 126  : 		return FALSE;

  0003a	33 c0		 xor	 eax, eax
  0003c	eb 3e		 jmp	 SHORT $LN3@KbdInitial
$LN2@KbdInitial:

; 127  : 
; 128  : 	if(!PsCreateThread(&m_TranslatorThreadHandle,m_ProcessHandle, KbdpTranslatorThread, NULL, DEFAULT_STACK_SIZE, FALSE))

  0003e	6a 00		 push	 0
  00040	68 00 00 01 00	 push	 65536			; 00010000H
  00045	6a 00		 push	 0
  00047	68 00 00 00 00	 push	 OFFSET _KbdpTranslatorThread
  0004c	a1 00 00 00 00	 mov	 eax, DWORD PTR _m_ProcessHandle
  00051	50		 push	 eax
  00052	68 00 00 00 00	 push	 OFFSET _m_TranslatorThreadHandle
  00057	e8 00 00 00 00	 call	 _PsCreateThread
  0005c	83 c4 18	 add	 esp, 24			; 00000018H
  0005f	85 c0		 test	 eax, eax
  00061	75 04		 jne	 SHORT $LN1@KbdInitial

; 129  : 		return FALSE;

  00063	33 c0		 xor	 eax, eax
  00065	eb 15		 jmp	 SHORT $LN3@KbdInitial
$LN1@KbdInitial:

; 130  : 	PsSetThreadStatus(m_TranslatorThreadHandle, THREAD_STATUS_READY);

  00067	6a 02		 push	 2
  00069	a1 00 00 00 00	 mov	 eax, DWORD PTR _m_TranslatorThreadHandle
  0006e	50		 push	 eax
  0006f	e8 00 00 00 00	 call	 _PsSetThreadStatus
  00074	83 c4 08	 add	 esp, 8
$$reset$891:

; 131  : $reset:
; 132  : 	return TRUE;

  00077	b8 01 00 00 00	 mov	 eax, 1
$LN3@KbdInitial:

; 133  : 
; 134  : }

  0007c	5f		 pop	 edi
  0007d	5e		 pop	 esi
  0007e	5b		 pop	 ebx
  0007f	8b e5		 mov	 esp, ebp
  00081	5d		 pop	 ebp
  00082	c3		 ret	 0
_KbdInitializeDriver ENDP
_TEXT	ENDS
PUBLIC	_KbdGetKey
; Function compile flags: /Odtp /ZI
;	COMDAT _KbdGetKey
_TEXT	SEGMENT
_pKeyData$ = 8						; size = 4
_KbdGetKey PROC						; COMDAT

; 137  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 138  : 	return KbdpPopUserKeyData(&(m_KbdData.user_keydata_q),pKeyData);

  00009	8b 45 08	 mov	 eax, DWORD PTR _pKeyData$[ebp]
  0000c	50		 push	 eax
  0000d	68 50 00 00 00	 push	 OFFSET _m_KbdData+80
  00012	e8 00 00 00 00	 call	 _KbdpPopUserKeyData
  00017	83 c4 08	 add	 esp, 8

; 139  : }

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_KbdGetKey ENDP
_TEXT	ENDS
PUBLIC	_Kbd_IRQ_Handler
EXTRN	_READ_PORT_UCHAR:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _Kbd_IRQ_Handler
_TEXT	SEGMENT
_keyCode$ = -1						; size = 1
_Kbd_IRQ_Handler PROC					; COMDAT

; 143  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 144  : 
; 145  : 	UCHAR keyCode;
; 146  : 
; 147  : 	keyCode = READ_PORT_UCHAR((PUCHAR)0x60);

  00009	6a 60		 push	 96			; 00000060H
  0000b	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00010	83 c4 04	 add	 esp, 4
  00013	88 45 ff	 mov	 BYTE PTR _keyCode$[ebp], al

; 148  : 
; 149  : 	if(keyCode == 0xff || keyCode == 0x00) {

  00016	0f b6 45 ff	 movzx	 eax, BYTE PTR _keyCode$[ebp]
  0001a	3d ff 00 00 00	 cmp	 eax, 255		; 000000ffH
  0001f	74 08		 je	 SHORT $LN4@Kbd_IRQ_Ha
  00021	0f b6 45 ff	 movzx	 eax, BYTE PTR _keyCode$[ebp]
  00025	85 c0		 test	 eax, eax
  00027	75 04		 jne	 SHORT $LN5@Kbd_IRQ_Ha
$LN4@Kbd_IRQ_Ha:

; 150  : 		return;

  00029	eb 20		 jmp	 SHORT $LN6@Kbd_IRQ_Ha
  0002b	eb 0d		 jmp	 SHORT $LN3@Kbd_IRQ_Ha
$LN5@Kbd_IRQ_Ha:

; 151  : 	}
; 152  : 	else if(keyCode == 0xfa) {

  0002d	0f b6 45 ff	 movzx	 eax, BYTE PTR _keyCode$[ebp]
  00031	3d fa 00 00 00	 cmp	 eax, 250		; 000000faH
  00036	75 02		 jne	 SHORT $LN3@Kbd_IRQ_Ha

; 153  : 		return;

  00038	eb 11		 jmp	 SHORT $LN6@Kbd_IRQ_Ha
$LN3@Kbd_IRQ_Ha:

; 154  : 	}
; 155  : 
; 156  : 	if(!KbdpPushRawKeyData(&(m_KbdData.raw_keydata_q), keyCode)){

  0003a	8a 45 ff	 mov	 al, BYTE PTR _keyCode$[ebp]
  0003d	50		 push	 eax
  0003e	68 0d 00 00 00	 push	 OFFSET _m_KbdData+13
  00043	e8 00 00 00 00	 call	 _KbdpPushRawKeyData
  00048	83 c4 08	 add	 esp, 8
$LN6@Kbd_IRQ_Ha:

; 157  : 		return;
; 158  : 	}
; 159  : 
; 160  : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_Kbd_IRQ_Handler ENDP
_TEXT	ENDS
EXTRN	_HalTaskSwitch:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _KbdpTranslatorThread
_TEXT	SEGMENT
_key_family$ = -7					; size = 1
_indicator$ = -6					; size = 1
_raw_key$ = -5						; size = 1
_key_data$ = -4						; size = 2
_StartContext$ = 8					; size = 4
_KbdpTranslatorThread PROC				; COMDAT

; 242  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN23@KbdpTransl:

; 243  : 	KBD_KEY_DATA key_data;
; 244  : 	BYTE raw_key, indicator, key_family;
; 245  : 
; 246  : 	while(1) {

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	85 c0		 test	 eax, eax
  00010	0f 84 93 01 00
	00		 je	 $LN22@KbdpTransl

; 247  : 
; 248  : 		if(!KbdpPopRawKeyData(&(m_KbdData.raw_keydata_q), &raw_key)){

  00016	8d 45 fb	 lea	 eax, DWORD PTR _raw_key$[ebp]
  00019	50		 push	 eax
  0001a	68 0d 00 00 00	 push	 OFFSET _m_KbdData+13
  0001f	e8 00 00 00 00	 call	 _KbdpPopRawKeyData
  00024	83 c4 08	 add	 esp, 8
  00027	85 c0		 test	 eax, eax
  00029	75 07		 jne	 SHORT $LN21@KbdpTransl

; 249  : 			HalTaskSwitch();

  0002b	e8 00 00 00 00	 call	 _HalTaskSwitch

; 250  : 			continue;

  00030	eb d7		 jmp	 SHORT $LN23@KbdpTransl
$LN21@KbdpTransl:

; 251  : 		}
; 252  : 
; 253  : 		if(raw_key & 0x80) {

  00032	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  00036	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0003b	74 53		 je	 SHORT $LN20@KbdpTransl

; 254  : 			if(raw_key == 0xaa || raw_key == 0xb6)

  0003d	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  00041	3d aa 00 00 00	 cmp	 eax, 170		; 000000aaH
  00046	74 0b		 je	 SHORT $LN18@KbdpTransl
  00048	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  0004c	3d b6 00 00 00	 cmp	 eax, 182		; 000000b6H
  00051	75 0c		 jne	 SHORT $LN19@KbdpTransl
$LN18@KbdpTransl:

; 255  : 				m_KbdData.shift_key_pressed = FALSE;

  00053	c7 05 01 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_KbdData+1, 0
  0005d	eb 2c		 jmp	 SHORT $LN17@KbdpTransl
$LN19@KbdpTransl:

; 256  : 			else if(raw_key == 0xb8)

  0005f	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  00063	3d b8 00 00 00	 cmp	 eax, 184		; 000000b8H
  00068	75 0c		 jne	 SHORT $LN16@KbdpTransl

; 257  : 				m_KbdData.alt_key_pressed = FALSE;

  0006a	c7 05 09 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_KbdData+9, 0
  00074	eb 15		 jmp	 SHORT $LN17@KbdpTransl
$LN16@KbdpTransl:

; 258  : 			else if(raw_key == 0x9d)

  00076	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  0007a	3d 9d 00 00 00	 cmp	 eax, 157		; 0000009dH
  0007f	75 0a		 jne	 SHORT $LN17@KbdpTransl

; 259  : 				m_KbdData.ctrl_key_pressed = FALSE;

  00081	c7 05 05 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_KbdData+5, 0
$LN17@KbdpTransl:

; 260  : 			continue;

  0008b	e9 79 ff ff ff	 jmp	 $LN23@KbdpTransl
$LN20@KbdpTransl:

; 261  : 		}
; 262  : 
; 263  : 		if(raw_key == 0x45) {

  00090	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  00094	83 f8 45	 cmp	 eax, 69			; 00000045H
  00097	75 08		 jne	 SHORT $LN13@KbdpTransl

; 264  : 			indicator = KBD_LED_NUMLOCK;

  00099	c6 45 fa 02	 mov	 BYTE PTR _indicator$[ebp], 2
  0009d	eb 20		 jmp	 SHORT $$reset$925

; 265  : 			goto $reset;

  0009f	eb 61		 jmp	 SHORT $LN12@KbdpTransl
$LN13@KbdpTransl:

; 266  : 		} else if (raw_key == 0x3a) {

  000a1	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  000a5	83 f8 3a	 cmp	 eax, 58			; 0000003aH
  000a8	75 08		 jne	 SHORT $LN11@KbdpTransl

; 267  : 			indicator = KBD_LED_CAPSLOCK;

  000aa	c6 45 fa 04	 mov	 BYTE PTR _indicator$[ebp], 4
  000ae	eb 0f		 jmp	 SHORT $$reset$925

; 268  : 			goto $reset;

  000b0	eb 50		 jmp	 SHORT $LN12@KbdpTransl
$LN11@KbdpTransl:

; 269  : 		} else if(raw_key == 0x46) {

  000b2	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  000b6	83 f8 46	 cmp	 eax, 70			; 00000046H
  000b9	75 47		 jne	 SHORT $LN12@KbdpTransl

; 270  : 			indicator = KBD_LED_SCROLLLOCK;

  000bb	c6 45 fa 01	 mov	 BYTE PTR _indicator$[ebp], 1
$$reset$925:

; 271  : $reset:
; 272  : 			if(m_KbdData.indicator_status & indicator) {

  000bf	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _m_KbdData
  000c6	0f b6 4d fa	 movzx	 ecx, BYTE PTR _indicator$[ebp]
  000ca	23 c1		 and	 eax, ecx
  000cc	74 17		 je	 SHORT $LN8@KbdpTransl

; 273  : 				m_KbdData.indicator_status &= (~indicator);

  000ce	0f b6 45 fa	 movzx	 eax, BYTE PTR _indicator$[ebp]
  000d2	f7 d0		 not	 eax
  000d4	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _m_KbdData
  000db	23 c8		 and	 ecx, eax
  000dd	88 0d 00 00 00
	00		 mov	 BYTE PTR _m_KbdData, cl

; 274  : 			} else {

  000e3	eb 13		 jmp	 SHORT $LN7@KbdpTransl
$LN8@KbdpTransl:

; 275  : 				m_KbdData.indicator_status |= indicator;

  000e5	0f b6 45 fa	 movzx	 eax, BYTE PTR _indicator$[ebp]
  000e9	0f b6 0d 00 00
	00 00		 movzx	 ecx, BYTE PTR _m_KbdData
  000f0	0b c8		 or	 ecx, eax
  000f2	88 0d 00 00 00
	00		 mov	 BYTE PTR _m_KbdData, cl
$LN7@KbdpTransl:

; 276  : 			}
; 277  : 			KbdpResetIndicator();

  000f8	e8 00 00 00 00	 call	 _KbdpResetIndicator

; 278  : 			continue;

  000fd	e9 07 ff ff ff	 jmp	 $LN23@KbdpTransl
$LN12@KbdpTransl:

; 279  : 		}
; 280  : 
; 281  : 		if(raw_key == 0x2a || raw_key == 0x36) {

  00102	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  00106	83 f8 2a	 cmp	 eax, 42			; 0000002aH
  00109	74 09		 je	 SHORT $LN5@KbdpTransl
  0010b	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  0010f	83 f8 36	 cmp	 eax, 54			; 00000036H
  00112	75 0c		 jne	 SHORT $LN6@KbdpTransl
$LN5@KbdpTransl:

; 282  : 			m_KbdData.shift_key_pressed = TRUE;

  00114	c7 05 01 00 00
	00 01 00 00 00	 mov	 DWORD PTR _m_KbdData+1, 1
  0011e	eb 28		 jmp	 SHORT $LN4@KbdpTransl
$LN6@KbdpTransl:

; 283  : 		} else if(raw_key == 0x1d) {

  00120	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  00124	83 f8 1d	 cmp	 eax, 29			; 0000001dH
  00127	75 0c		 jne	 SHORT $LN3@KbdpTransl

; 284  : 			m_KbdData.ctrl_key_pressed = TRUE;

  00129	c7 05 05 00 00
	00 01 00 00 00	 mov	 DWORD PTR _m_KbdData+5, 1
  00133	eb 13		 jmp	 SHORT $LN4@KbdpTransl
$LN3@KbdpTransl:

; 285  : 		} else if(raw_key == 0x38) {

  00135	0f b6 45 fb	 movzx	 eax, BYTE PTR _raw_key$[ebp]
  00139	83 f8 38	 cmp	 eax, 56			; 00000038H
  0013c	75 0a		 jne	 SHORT $LN4@KbdpTransl

; 286  : 			m_KbdData.alt_key_pressed = TRUE;

  0013e	c7 05 09 00 00
	00 01 00 00 00	 mov	 DWORD PTR _m_KbdData+9, 1
$LN4@KbdpTransl:

; 287  : 		}
; 288  : 
; 289  : 		key_family = KBD_ASCII_ORG;

  00148	c6 45 f9 00	 mov	 BYTE PTR _key_family$[ebp], 0

; 290  : 		key_family |= (m_KbdData.shift_key_pressed ? KBD_ASCII_WITH_SHIFT : 0);

  0014c	a1 01 00 00 00	 mov	 eax, DWORD PTR _m_KbdData+1
  00151	f7 d8		 neg	 eax
  00153	1b c0		 sbb	 eax, eax
  00155	83 e0 02	 and	 eax, 2
  00158	0f b6 4d f9	 movzx	 ecx, BYTE PTR _key_family$[ebp]
  0015c	0b c8		 or	 ecx, eax
  0015e	88 4d f9	 mov	 BYTE PTR _key_family$[ebp], cl

; 291  : 		key_family |= (m_KbdData.indicator_status&KBD_LED_CAPSLOCK ? KBD_ASCII_WITH_CAPSLOCK : 0);

  00161	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _m_KbdData
  00168	83 e0 04	 and	 eax, 4
  0016b	f7 d8		 neg	 eax
  0016d	1b c0		 sbb	 eax, eax
  0016f	f7 d8		 neg	 eax
  00171	0f b6 4d f9	 movzx	 ecx, BYTE PTR _key_family$[ebp]
  00175	0b c8		 or	 ecx, eax
  00177	88 4d f9	 mov	 BYTE PTR _key_family$[ebp], cl

; 292  : 
; 293  : 		key_data.type = KBD_KTYPE_GENERAL;

  0017a	c6 45 fc 00	 mov	 BYTE PTR _key_data$[ebp], 0

; 294  : 		key_data.key = m_AsciiCode[key_family][raw_key];

  0017e	0f b6 45 f9	 movzx	 eax, BYTE PTR _key_family$[ebp]
  00182	c1 e0 07	 shl	 eax, 7
  00185	0f b6 4d fb	 movzx	 ecx, BYTE PTR _raw_key$[ebp]
  00189	8a 94 08 00 00
	00 00		 mov	 dl, BYTE PTR _m_AsciiCode[eax+ecx]
  00190	88 55 fd	 mov	 BYTE PTR _key_data$[ebp+1], dl

; 295  : 		KbdpPushUserKeyData(&(m_KbdData.user_keydata_q), &key_data);

  00193	8d 45 fc	 lea	 eax, DWORD PTR _key_data$[ebp]
  00196	50		 push	 eax
  00197	68 50 00 00 00	 push	 OFFSET _m_KbdData+80
  0019c	e8 00 00 00 00	 call	 _KbdpPushUserKeyData
  001a1	83 c4 08	 add	 esp, 8

; 296  : 	}

  001a4	e9 60 fe ff ff	 jmp	 $LN23@KbdpTransl
$LN22@KbdpTransl:

; 297  : 
; 298  : 	return 0;

  001a9	33 c0		 xor	 eax, eax

; 299  : }

  001ab	5f		 pop	 edi
  001ac	5e		 pop	 esi
  001ad	5b		 pop	 ebx
  001ae	8b e5		 mov	 esp, ebp
  001b0	5d		 pop	 ebp
  001b1	c3		 ret	 0
_KbdpTranslatorThread ENDP
_TEXT	ENDS
EXTRN	_WRITE_PORT_UCHAR:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _KbdpResetIndicator
_TEXT	SEGMENT
_status$ = -1						; size = 1
_KbdpResetIndicator PROC				; COMDAT

; 304  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN6@KbdpResetI:

; 305  : 	UCHAR status;
; 306  : 
; 307  : 	do { status = READ_PORT_UCHAR((PUCHAR)0x64); } while( status & 0x02);

  00009	6a 64		 push	 100			; 00000064H
  0000b	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00010	83 c4 04	 add	 esp, 4
  00013	88 45 ff	 mov	 BYTE PTR _status$[ebp], al
  00016	0f b6 45 ff	 movzx	 eax, BYTE PTR _status$[ebp]
  0001a	83 e0 02	 and	 eax, 2
  0001d	75 ea		 jne	 SHORT $LN6@KbdpResetI

; 308  : 	WRITE_PORT_UCHAR((PUCHAR)0x60, 0xed);

  0001f	68 ed 00 00 00	 push	 237			; 000000edH
  00024	6a 60		 push	 96			; 00000060H
  00026	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0002b	83 c4 08	 add	 esp, 8
$LN3@KbdpResetI:

; 309  : 
; 310  : 	do { status = READ_PORT_UCHAR((PUCHAR)0x64); } while( status & 0x02);

  0002e	6a 64		 push	 100			; 00000064H
  00030	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00035	83 c4 04	 add	 esp, 4
  00038	88 45 ff	 mov	 BYTE PTR _status$[ebp], al
  0003b	0f b6 45 ff	 movzx	 eax, BYTE PTR _status$[ebp]
  0003f	83 e0 02	 and	 eax, 2
  00042	75 ea		 jne	 SHORT $LN3@KbdpResetI

; 311  : 	WRITE_PORT_UCHAR((PUCHAR)0x60, m_KbdData.indicator_status);

  00044	a0 00 00 00 00	 mov	 al, BYTE PTR _m_KbdData
  00049	50		 push	 eax
  0004a	6a 60		 push	 96			; 00000060H
  0004c	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00051	83 c4 08	 add	 esp, 8

; 312  : 
; 313  : 	return 0;

  00054	33 c0		 xor	 eax, eax

; 314  : }

  00056	5f		 pop	 edi
  00057	5e		 pop	 esi
  00058	5b		 pop	 ebx
  00059	8b e5		 mov	 esp, ebp
  0005b	5d		 pop	 ebp
  0005c	c3		 ret	 0
_KbdpResetIndicator ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _KbdpPopRawKeyData
_TEXT	SEGMENT
_bResult$ = -4						; size = 4
_pKeyQ$ = 8						; size = 4
_pKey$ = 12						; size = 4
_KbdpPopRawKeyData PROC					; COMDAT

; 318  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 319  : 
; 320  : 	BOOL bResult = TRUE;

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 1

; 321  : 
; 322  : ENTER_CRITICAL_SECTION();

  00010	9c		 pushfd
  00011	fa		 cli

; 323  : 	{
; 324  : 		if(pKeyQ->cnt == 0) {

  00012	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00015	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00018	85 c9		 test	 ecx, ecx
  0001a	75 09		 jne	 SHORT $LN2@KbdpPopRaw

; 325  : 			bResult = FALSE;

  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0

; 326  : 			goto $exit;

  00023	eb 41		 jmp	 SHORT $$exit$958
$LN2@KbdpPopRaw:

; 327  : 		}
; 328  : 
; 329  : 		pKeyQ->cnt--;

  00025	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00028	8a 08		 mov	 cl, BYTE PTR [eax]
  0002a	80 e9 01	 sub	 cl, 1
  0002d	8b 55 08	 mov	 edx, DWORD PTR _pKeyQ$[ebp]
  00030	88 0a		 mov	 BYTE PTR [edx], cl

; 330  : 		*pKey = pKeyQ->queue[pKeyQ->head++];

  00032	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00035	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00039	8b 55 0c	 mov	 edx, DWORD PTR _pKey$[ebp]
  0003c	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  0003f	8a 4c 08 03	 mov	 cl, BYTE PTR [eax+ecx+3]
  00043	88 0a		 mov	 BYTE PTR [edx], cl
  00045	8b 55 08	 mov	 edx, DWORD PTR _pKeyQ$[ebp]
  00048	8a 42 01	 mov	 al, BYTE PTR [edx+1]
  0004b	04 01		 add	 al, 1
  0004d	8b 4d 08	 mov	 ecx, DWORD PTR _pKeyQ$[ebp]
  00050	88 41 01	 mov	 BYTE PTR [ecx+1], al

; 331  : 		if(pKeyQ->head >= RAW_KEY_DATA_Q_SIZE)

  00053	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00056	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0005a	83 f9 40	 cmp	 ecx, 64			; 00000040H
  0005d	7c 07		 jl	 SHORT $$exit$958

; 332  : 			pKeyQ->head = 0;

  0005f	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00062	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0
$$exit$958:

; 333  : 	}
; 334  : $exit:
; 335  : EXIT_CRITICAL_SECTION();

  00066	9d		 popfd

; 336  : 	return bResult;

  00067	8b 45 fc	 mov	 eax, DWORD PTR _bResult$[ebp]

; 337  : 
; 338  : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_KbdpPopRawKeyData ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _KbdpPushRawKeyData
_TEXT	SEGMENT
_bResult$ = -4						; size = 4
_pKeyQ$ = 8						; size = 4
_key$ = 12						; size = 1
_KbdpPushRawKeyData PROC				; COMDAT

; 341  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 342  : 
; 343  : 	BOOL bResult = TRUE;

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 1

; 344  : 
; 345  : ENTER_CRITICAL_SECTION();

  00010	9c		 pushfd
  00011	fa		 cli

; 346  : 	{
; 347  : 		if(pKeyQ->cnt >= RAW_KEY_DATA_Q_SIZE) {

  00012	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00015	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00018	83 f9 40	 cmp	 ecx, 64			; 00000040H
  0001b	7c 09		 jl	 SHORT $LN2@KbdpPushRa

; 348  : 			bResult = FALSE;

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0

; 349  : 			goto $exit;

  00024	eb 40		 jmp	 SHORT $$exit$967
$LN2@KbdpPushRa:

; 350  : 		}
; 351  : 
; 352  : 		pKeyQ->cnt++;

  00026	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00029	8a 08		 mov	 cl, BYTE PTR [eax]
  0002b	80 c1 01	 add	 cl, 1
  0002e	8b 55 08	 mov	 edx, DWORD PTR _pKeyQ$[ebp]
  00031	88 0a		 mov	 BYTE PTR [edx], cl

; 353  : 		pKeyQ->queue[pKeyQ->tail++] = key;

  00033	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00036	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0003a	8b 55 08	 mov	 edx, DWORD PTR _pKeyQ$[ebp]
  0003d	8a 45 0c	 mov	 al, BYTE PTR _key$[ebp]
  00040	88 44 0a 03	 mov	 BYTE PTR [edx+ecx+3], al
  00044	8b 4d 08	 mov	 ecx, DWORD PTR _pKeyQ$[ebp]
  00047	8a 51 02	 mov	 dl, BYTE PTR [ecx+2]
  0004a	80 c2 01	 add	 dl, 1
  0004d	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00050	88 50 02	 mov	 BYTE PTR [eax+2], dl

; 354  : 		if(pKeyQ->tail >= RAW_KEY_DATA_Q_SIZE)

  00053	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00056	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0005a	83 f9 40	 cmp	 ecx, 64			; 00000040H
  0005d	7c 07		 jl	 SHORT $$exit$967

; 355  : 			pKeyQ->tail=0;

  0005f	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00062	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0
$$exit$967:

; 356  : 	}
; 357  : $exit:
; 358  : EXIT_CRITICAL_SECTION();

  00066	9d		 popfd

; 359  : 	return bResult;

  00067	8b 45 fc	 mov	 eax, DWORD PTR _bResult$[ebp]

; 360  : }

  0006a	5f		 pop	 edi
  0006b	5e		 pop	 esi
  0006c	5b		 pop	 ebx
  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_KbdpPushRawKeyData ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _KbdpPopUserKeyData
_TEXT	SEGMENT
_bResult$ = -4						; size = 4
_pKeyQ$ = 8						; size = 4
_pKeyData$ = 12						; size = 4
_KbdpPopUserKeyData PROC				; COMDAT

; 365  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 366  : 	BOOL bResult = TRUE;

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 1

; 367  : 
; 368  : ENTER_CRITICAL_SECTION();

  00010	9c		 pushfd
  00011	fa		 cli

; 369  : 	{
; 370  : 		if(pKeyQ->cnt == 0) {

  00012	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00015	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00018	85 c9		 test	 ecx, ecx
  0001a	75 09		 jne	 SHORT $LN2@KbdpPopUse

; 371  : 			bResult = FALSE;

  0001c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0

; 372  : 			goto $exit;

  00023	eb 56		 jmp	 SHORT $$exit$976
$LN2@KbdpPopUse:

; 373  : 		}
; 374  : 
; 375  : 		pKeyQ->cnt--;

  00025	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00028	8a 08		 mov	 cl, BYTE PTR [eax]
  0002a	80 e9 01	 sub	 cl, 1
  0002d	8b 55 08	 mov	 edx, DWORD PTR _pKeyQ$[ebp]
  00030	88 0a		 mov	 BYTE PTR [edx], cl

; 376  : 		pKeyData->type = pKeyQ->queue[pKeyQ->head].type;

  00032	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00035	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00039	8b 55 0c	 mov	 edx, DWORD PTR _pKeyData$[ebp]
  0003c	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  0003f	8a 4c 48 03	 mov	 cl, BYTE PTR [eax+ecx*2+3]
  00043	88 0a		 mov	 BYTE PTR [edx], cl

; 377  : 		pKeyData->key  = pKeyQ->queue[pKeyQ->head].key;

  00045	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00048	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0004c	8b 55 0c	 mov	 edx, DWORD PTR _pKeyData$[ebp]
  0004f	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00052	8a 4c 48 04	 mov	 cl, BYTE PTR [eax+ecx*2+4]
  00056	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 378  : 		pKeyQ->head++;

  00059	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  0005c	8a 48 01	 mov	 cl, BYTE PTR [eax+1]
  0005f	80 c1 01	 add	 cl, 1
  00062	8b 55 08	 mov	 edx, DWORD PTR _pKeyQ$[ebp]
  00065	88 4a 01	 mov	 BYTE PTR [edx+1], cl

; 379  : 		if(pKeyQ->head >= USER_KEY_DATA_Q_SIZE)

  00068	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  0006b	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  0006f	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00072	7c 07		 jl	 SHORT $$exit$976

; 380  : 			pKeyQ->head = 0;

  00074	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00077	c6 40 01 00	 mov	 BYTE PTR [eax+1], 0
$$exit$976:

; 381  : 	}
; 382  : $exit:
; 383  : EXIT_CRITICAL_SECTION();

  0007b	9d		 popfd

; 384  : 	return bResult;

  0007c	8b 45 fc	 mov	 eax, DWORD PTR _bResult$[ebp]

; 385  : 	
; 386  : 
; 387  : }

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c3		 ret	 0
_KbdpPopUserKeyData ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _KbdpPushUserKeyData
_TEXT	SEGMENT
_bResult$ = -4						; size = 4
_pKeyQ$ = 8						; size = 4
_pKeyData$ = 12						; size = 4
_KbdpPushUserKeyData PROC				; COMDAT

; 391  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 392  : 	BOOL bResult = TRUE;

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 1

; 393  : 
; 394  : ENTER_CRITICAL_SECTION();

  00010	9c		 pushfd
  00011	fa		 cli

; 395  : 	{
; 396  : 		if(pKeyQ->cnt >= USER_KEY_DATA_Q_SIZE) {

  00012	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00015	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00018	83 f9 20	 cmp	 ecx, 32			; 00000020H
  0001b	7c 09		 jl	 SHORT $LN2@KbdpPushUs

; 397  : 			bResult = FALSE;

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0

; 398  : 			goto $exit;

  00024	eb 56		 jmp	 SHORT $$exit$985
$LN2@KbdpPushUs:

; 399  : 		}
; 400  : 
; 401  : 		pKeyQ->cnt++;

  00026	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00029	8a 08		 mov	 cl, BYTE PTR [eax]
  0002b	80 c1 01	 add	 cl, 1
  0002e	8b 55 08	 mov	 edx, DWORD PTR _pKeyQ$[ebp]
  00031	88 0a		 mov	 BYTE PTR [edx], cl

; 402  : 		pKeyQ->queue[pKeyQ->tail].type = pKeyData->type;

  00033	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00036	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0003a	8b 55 08	 mov	 edx, DWORD PTR _pKeyQ$[ebp]
  0003d	8b 45 0c	 mov	 eax, DWORD PTR _pKeyData$[ebp]
  00040	8a 00		 mov	 al, BYTE PTR [eax]
  00042	88 44 4a 03	 mov	 BYTE PTR [edx+ecx*2+3], al

; 403  : 		pKeyQ->queue[pKeyQ->tail].key  = pKeyData->key;

  00046	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00049	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0004d	8b 55 08	 mov	 edx, DWORD PTR _pKeyQ$[ebp]
  00050	8b 45 0c	 mov	 eax, DWORD PTR _pKeyData$[ebp]
  00053	8a 40 01	 mov	 al, BYTE PTR [eax+1]
  00056	88 44 4a 04	 mov	 BYTE PTR [edx+ecx*2+4], al

; 404  : 		pKeyQ->tail++;

  0005a	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  0005d	8a 48 02	 mov	 cl, BYTE PTR [eax+2]
  00060	80 c1 01	 add	 cl, 1
  00063	8b 55 08	 mov	 edx, DWORD PTR _pKeyQ$[ebp]
  00066	88 4a 02	 mov	 BYTE PTR [edx+2], cl

; 405  : 		if(pKeyQ->tail >= USER_KEY_DATA_Q_SIZE)

  00069	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  0006c	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  00070	83 f9 20	 cmp	 ecx, 32			; 00000020H
  00073	7c 07		 jl	 SHORT $$exit$985

; 406  : 			pKeyQ->tail = 0;

  00075	8b 45 08	 mov	 eax, DWORD PTR _pKeyQ$[ebp]
  00078	c6 40 02 00	 mov	 BYTE PTR [eax+2], 0
$$exit$985:

; 407  : 	}
; 408  : $exit:
; 409  : EXIT_CRITICAL_SECTION();

  0007c	9d		 popfd

; 410  : 	return bResult;

  0007d	8b 45 fc	 mov	 eax, DWORD PTR _bResult$[ebp]

; 411  : 
; 412  : }

  00080	5f		 pop	 edi
  00081	5e		 pop	 esi
  00082	5b		 pop	 ebx
  00083	8b e5		 mov	 esp, ebp
  00085	5d		 pop	 ebp
  00086	c3		 ret	 0
_KbdpPushUserKeyData ENDP
_TEXT	ENDS
END
