; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	c:\Users\상우\Documents\카카오톡 받은 파일\MylysOS\hal.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BI@NMHEANFH@Halp_IRQ_HardDrive?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@DKPJFPAC@Halp_IRQ_MathCoprocessor?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@NEDDPGBJ@Halp_IRQ_Mouse?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@IGOLJKOG@Halp_IRQ_VGA?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@MCNHIJMG@Halp_IRQ_CMOSClock?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@BMGLEMCE@Halp_IRQ_LPT1?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@CNIDFGLJ@Halp_IRQ_LPT2?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@PNONLAAJ@Halp_IRQ_COM1?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@MMAFKKJE@Halp_IRQ_COM2?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@BPMNCKPI@Halp_IRQ_ReqFromSlave8259?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@NHEAFIGN@Halp_ECT_MachineCheck?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@IIPPLJCI@Halp_ECT_AlignmentCheck?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@BAMOPHKE@Halp_ECT_FloatingPointError?$CI?$CJ?5?$AN?6@ ; `string'
PUBLIC	??_C@_0BI@ECFHJJPN@Halp_ECT_PageFault?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@BNNEHHMP@Halp_ECT_GeneralProtection?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@IPDIOMJP@Halp_ECT_StackException?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@NKBGCIFH@Halp_ECT_SegmentNotPresent?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@PELGBAAP@Halp_ECT_InvalidTSS?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@KDIHIBHF@Halp_ECT_CoprocessorOverrun?$CI?$CJ?5?$AN?6@ ; `string'
PUBLIC	??_C@_0CB@LIGLLFBG@Halp_ECT_DeviceNotAvailable?$CI?$CJ?5?$AN?6@ ; `string'
PUBLIC	??_C@_0BM@EDOCEHEB@Halp_ECT_InvaildOpcode?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@GOILIIOG@Halp_ECT_BOUNDS?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@PJNACMJH@Halp_ECT_INTO?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@CHEGJKKD@Halp_ECT_Breakpoint?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@EPIMJMAK@Halp_ECT_NMI?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@LHNLHKKE@Halp_ECT_DebugException?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@DCNBJOMK@Halp_ECT_DivideByZero?$CI?$CJ?5?$AN?6?$AA@ ; `string'
;	COMDAT ??_C@_0BI@NMHEANFH@Halp_IRQ_HardDrive?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BI@NMHEANFH@Halp_IRQ_HardDrive?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_H'
	DB	'ardDrive() ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DKPJFPAC@Halp_IRQ_MathCoprocessor?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BO@DKPJFPAC@Halp_IRQ_MathCoprocessor?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp'
	DB	'_IRQ_MathCoprocessor() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NEDDPGBJ@Halp_IRQ_Mouse?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BE@NEDDPGBJ@Halp_IRQ_Mouse?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_Mouse'
	DB	'() ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IGOLJKOG@Halp_IRQ_VGA?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BC@IGOLJKOG@Halp_IRQ_VGA?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_VGA() ', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MCNHIJMG@Halp_IRQ_CMOSClock?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BI@MCNHIJMG@Halp_IRQ_CMOSClock?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_C'
	DB	'MOSClock() ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BMGLEMCE@Halp_IRQ_LPT1?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@BMGLEMCE@Halp_IRQ_LPT1?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_LPT1()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CNIDFGLJ@Halp_IRQ_LPT2?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@CNIDFGLJ@Halp_IRQ_LPT2?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_LPT2()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PNONLAAJ@Halp_IRQ_COM1?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@PNONLAAJ@Halp_IRQ_COM1?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_COM1()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MMAFKKJE@Halp_IRQ_COM2?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@MMAFKKJE@Halp_IRQ_COM2?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_COM2()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BPMNCKPI@Halp_IRQ_ReqFromSlave8259?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BP@BPMNCKPI@Halp_IRQ_ReqFromSlave8259?$CI?$CJ?5?$AN?6?$AA@ DB 'Hal'
	DB	'p_IRQ_ReqFromSlave8259() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NHEAFIGN@Halp_ECT_MachineCheck?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BL@NHEAFIGN@Halp_ECT_MachineCheck?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_EC'
	DB	'T_MachineCheck() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IIPPLJCI@Halp_ECT_AlignmentCheck?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BN@IIPPLJCI@Halp_ECT_AlignmentCheck?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_'
	DB	'ECT_AlignmentCheck() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BAMOPHKE@Halp_ECT_FloatingPointError?$CI?$CJ?5?$AN?6@
CONST	SEGMENT
??_C@_0CB@BAMOPHKE@Halp_ECT_FloatingPointError?$CI?$CJ?5?$AN?6@ DB 'Halp_'
	DB	'ECT_FloatingPointError() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ECFHJJPN@Halp_ECT_PageFault?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BI@ECFHJJPN@Halp_ECT_PageFault?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_P'
	DB	'ageFault() ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BNNEHHMP@Halp_ECT_GeneralProtection?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0CA@BNNEHHMP@Halp_ECT_GeneralProtection?$CI?$CJ?5?$AN?6?$AA@ DB 'Ha'
	DB	'lp_ECT_GeneralProtection() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IPDIOMJP@Halp_ECT_StackException?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BN@IPDIOMJP@Halp_ECT_StackException?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_'
	DB	'ECT_StackException() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NKBGCIFH@Halp_ECT_SegmentNotPresent?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0CA@NKBGCIFH@Halp_ECT_SegmentNotPresent?$CI?$CJ?5?$AN?6?$AA@ DB 'Ha'
	DB	'lp_ECT_SegmentNotPresent() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PELGBAAP@Halp_ECT_InvalidTSS?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BJ@PELGBAAP@Halp_ECT_InvalidTSS?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_'
	DB	'InvalidTSS() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KDIHIBHF@Halp_ECT_CoprocessorOverrun?$CI?$CJ?5?$AN?6@
CONST	SEGMENT
??_C@_0CB@KDIHIBHF@Halp_ECT_CoprocessorOverrun?$CI?$CJ?5?$AN?6@ DB 'Halp_'
	DB	'ECT_CoprocessorOverrun() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LIGLLFBG@Halp_ECT_DeviceNotAvailable?$CI?$CJ?5?$AN?6@
CONST	SEGMENT
??_C@_0CB@LIGLLFBG@Halp_ECT_DeviceNotAvailable?$CI?$CJ?5?$AN?6@ DB 'Halp_'
	DB	'ECT_DeviceNotAvailable() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EDOCEHEB@Halp_ECT_InvaildOpcode?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BM@EDOCEHEB@Halp_ECT_InvaildOpcode?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_E'
	DB	'CT_InvaildOpcode() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GOILIIOG@Halp_ECT_BOUNDS?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BF@GOILIIOG@Halp_ECT_BOUNDS?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_BOUN'
	DB	'DS() ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJNACMJH@Halp_ECT_INTO?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@PJNACMJH@Halp_ECT_INTO?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_INTO()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CHEGJKKD@Halp_ECT_Breakpoint?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BJ@CHEGJKKD@Halp_ECT_Breakpoint?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_'
	DB	'Breakpoint() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EPIMJMAK@Halp_ECT_NMI?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BC@EPIMJMAK@Halp_ECT_NMI?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_NMI() ', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LHNLHKKE@Halp_ECT_DebugException?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BN@LHNLHKKE@Halp_ECT_DebugException?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_'
	DB	'ECT_DebugException() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
?msg@?1??Halp_ECT_DivideByZero@@9@9 DD FLAT:??_C@_0BL@DCNBJOMK@Halp_ECT_DivideByZero?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_DivideByZero'::`2'::msg
?msg@?1??Halp_ECT_DebugException@@9@9 DD FLAT:??_C@_0BN@LHNLHKKE@Halp_ECT_DebugException?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_DebugException'::`2'::msg
?msg@?1??Halp_ECT_NMI@@9@9 DD FLAT:??_C@_0BC@EPIMJMAK@Halp_ECT_NMI?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_NMI'::`2'::msg
?msg@?1??Halp_ECT_Breakpoint@@9@9 DD FLAT:??_C@_0BJ@CHEGJKKD@Halp_ECT_Breakpoint?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_Breakpoint'::`2'::msg
?msg@?1??Halp_ECT_INTO@@9@9 DD FLAT:??_C@_0BD@PJNACMJH@Halp_ECT_INTO?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_INTO'::`2'::msg
?msg@?1??Halp_ECT_BOUNDS@@9@9 DD FLAT:??_C@_0BF@GOILIIOG@Halp_ECT_BOUNDS?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_BOUNDS'::`2'::msg
?msg@?1??Halp_ECT_InvaildOpcode@@9@9 DD FLAT:??_C@_0BM@EDOCEHEB@Halp_ECT_InvaildOpcode?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_InvaildOpcode'::`2'::msg
?msg@?1??Halp_ECT_DeviceNotAvailable@@9@9 DD FLAT:??_C@_0CB@LIGLLFBG@Halp_ECT_DeviceNotAvailable?$CI?$CJ?5?$AN?6@ ; `Halp_ECT_DeviceNotAvailable'::`2'::msg
?msg@?1??Halp_ECT_CoprocessorOverrun@@9@9 DD FLAT:??_C@_0CB@KDIHIBHF@Halp_ECT_CoprocessorOverrun?$CI?$CJ?5?$AN?6@ ; `Halp_ECT_CoprocessorOverrun'::`2'::msg
?msg@?1??Halp_ECT_InvalidTSS@@9@9 DD FLAT:??_C@_0BJ@PELGBAAP@Halp_ECT_InvalidTSS?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_InvalidTSS'::`2'::msg
?msg@?1??Halp_ECT_SegmentNotPresent@@9@9 DD FLAT:??_C@_0CA@NKBGCIFH@Halp_ECT_SegmentNotPresent?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_SegmentNotPresent'::`2'::msg
?msg@?1??Halp_ECT_StackException@@9@9 DD FLAT:??_C@_0BN@IPDIOMJP@Halp_ECT_StackException?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_StackException'::`2'::msg
?msg@?1??Halp_ECT_GeneralProtection@@9@9 DD FLAT:??_C@_0CA@BNNEHHMP@Halp_ECT_GeneralProtection?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_GeneralProtection'::`2'::msg
?msg@?1??Halp_ECT_PageFault@@9@9 DD FLAT:??_C@_0BI@ECFHJJPN@Halp_ECT_PageFault?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_PageFault'::`2'::msg
?msg@?1??Halp_ECT_FloatingPointError@@9@9 DD FLAT:??_C@_0CB@BAMOPHKE@Halp_ECT_FloatingPointError?$CI?$CJ?5?$AN?6@ ; `Halp_ECT_FloatingPointError'::`2'::msg
?msg@?1??Halp_ECT_AlignmentCheck@@9@9 DD FLAT:??_C@_0BN@IIPPLJCI@Halp_ECT_AlignmentCheck?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_AlignmentCheck'::`2'::msg
?msg@?1??Halp_ECT_MachineCheck@@9@9 DD FLAT:??_C@_0BL@NHEAFIGN@Halp_ECT_MachineCheck?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_MachineCheck'::`2'::msg
?msg@?1??Halp_IRQ_ReqFromSlave8259@@9@9 DD FLAT:??_C@_0BP@BPMNCKPI@Halp_IRQ_ReqFromSlave8259?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_ReqFromSlave8259'::`2'::msg
?msg@?1??Halp_IRQ_COM2@@9@9 DD FLAT:??_C@_0BD@MMAFKKJE@Halp_IRQ_COM2?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_COM2'::`2'::msg
?msg@?1??Halp_IRQ_COM1@@9@9 DD FLAT:??_C@_0BD@PNONLAAJ@Halp_IRQ_COM1?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_COM1'::`2'::msg
?msg@?1??Halp_IRQ_LPT2@@9@9 DD FLAT:??_C@_0BD@CNIDFGLJ@Halp_IRQ_LPT2?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_LPT2'::`2'::msg
?msg@?1??Halp_IRQ_LPT1@@9@9 DD FLAT:??_C@_0BD@BMGLEMCE@Halp_IRQ_LPT1?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_LPT1'::`2'::msg
?msg@?1??Halp_IRQ_CMOSClock@@9@9 DD FLAT:??_C@_0BI@MCNHIJMG@Halp_IRQ_CMOSClock?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_CMOSClock'::`2'::msg
?msg@?1??Halp_IRQ_VGA@@9@9 DD FLAT:??_C@_0BC@IGOLJKOG@Halp_IRQ_VGA?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_VGA'::`2'::msg
?msg@?1??Halp_IRQ_Mouse@@9@9 DD FLAT:??_C@_0BE@NEDDPGBJ@Halp_IRQ_Mouse?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_Mouse'::`2'::msg
?msg@?1??Halp_IRQ_MathCoprocessor@@9@9 DD FLAT:??_C@_0BO@DKPJFPAC@Halp_IRQ_MathCoprocessor?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_MathCoprocessor'::`2'::msg
?msg@?1??Halp_IRQ_HardDrive@@9@9 DD FLAT:??_C@_0BI@NMHEANFH@Halp_IRQ_HardDrive?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_HardDrive'::`2'::msg
	ORG $+4
_m_IntHandlers DB 00H
	DD	FLAT:_Halp_ECT_DivideByZero
	DW	08e00H
	DB	01H
	DD	FLAT:_Halp_ECT_DebugException
	DW	08e00H
	DB	02H
	DD	FLAT:_Halp_ECT_NMI
	DW	08e00H
	DB	03H
	DD	FLAT:_Halp_ECT_Breakpoint
	DW	08e00H
	DB	04H
	DD	FLAT:_Halp_ECT_INTO
	DW	08e00H
	DB	05H
	DD	FLAT:_Halp_ECT_BOUNDS
	DW	08e00H
	DB	06H
	DD	FLAT:_Halp_ECT_InvaildOpcode
	DW	08e00H
	DB	07H
	DD	FLAT:_Halp_ECT_DeviceNotAvailable
	DW	08e00H
	DB	08H
	DD	FLAT:_Halp_ECT_DoubleFault
	DW	08e00H
	DB	09H
	DD	FLAT:_Halp_ECT_CoprocessorOverrun
	DW	08e00H
	DB	0aH
	DD	FLAT:_Halp_ECT_InvalidTSS
	DW	08e00H
	DB	0bH
	DD	FLAT:_Halp_ECT_SegmentNotPresent
	DW	08e00H
	DB	0cH
	DD	FLAT:_Halp_ECT_StackException
	DW	08e00H
	DB	0dH
	DD	FLAT:_Halp_ECT_GeneralProtection
	DW	08e00H
	DB	0eH
	DD	FLAT:_Halp_ECT_PageFault
	DW	08e00H
	DB	010H
	DD	FLAT:_Halp_ECT_FloatingPointError
	DW	08e00H
	DB	011H
	DD	FLAT:_Halp_ECT_AlignmentCheck
	DW	08e00H
	DB	012H
	DD	FLAT:_Halp_ECT_MachineCheck
	DW	08e00H
	DB	021H
	DD	FLAT:_Halp_IRQ_Keyboard
	DW	08e00H
	DB	022H
	DD	FLAT:_Halp_IRQ_ReqFromSlave8259
	DW	08e00H
	DB	023H
	DD	FLAT:_Halp_IRQ_COM2
	DW	08e00H
	DB	024H
	DD	FLAT:_Halp_IRQ_COM1
	DW	08e00H
	DB	025H
	DD	FLAT:_Halp_IRQ_LPT2
	DW	08e00H
	DB	026H
	DD	FLAT:_Halp_IRQ_FloppyDisk
	DW	08e00H
	DB	027H
	DD	FLAT:_Halp_IRQ_LPT1
	DW	08e00H
	DB	028H
	DD	FLAT:_Halp_IRQ_CMOSClock
	DW	08e00H
	DB	029H
	DD	FLAT:_Halp_IRQ_VGA
	DW	08e00H
	DB	02cH
	DD	FLAT:_Halp_IRQ_Mouse
	DW	08e00H
	DB	02dH
	DD	FLAT:_Halp_IRQ_MathCoprocessor
	DW	08e00H
	DB	02eH
	DD	FLAT:_Halp_IRQ_HardDrive
	DW	08e00H
	DB	020H
	DD	038H
	DW	08500H
	DB	030H
	DD	040H
	DW	08500H
	DB	00H
	DD	00H
	DW	00H
_DATA	ENDS
;	COMDAT ??_C@_0BL@DCNBJOMK@Halp_ECT_DivideByZero?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BL@DCNBJOMK@Halp_ECT_DivideByZero?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_EC'
	DB	'T_DivideByZero() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
PUBLIC	??_C@_0CP@DIODDKOF@HalpInitializeProcessor?$CI?$CJ?5return@ ; `string'
PUBLIC	_HalInitializeHal
EXTRN	_CrtPrintf:PROC
;	COMDAT ??_C@_0CP@DIODDKOF@HalpInitializeProcessor?$CI?$CJ?5return@
; File c:\users\상우\documents\카카오톡 받은 파일\mylysos\hal.c
CONST	SEGMENT
??_C@_0CP@DIODDKOF@HalpInitializeProcessor?$CI?$CJ?5return@ DB 'HalpIniti'
	DB	'alizeProcessor() returned an error.', 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _HalInitializeHal
_TEXT	SEGMENT
_HalInitializeHal PROC					; COMDAT

; 41   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 42   : 	//실질적인 하드웨어 초기화 함수 호출
; 43   : 	if(!HalpInitializeProcessor()) {

  00009	e8 00 00 00 00	 call	 _HalpInitializeProcessor
  0000e	85 c0		 test	 eax, eax
  00010	75 11		 jne	 SHORT $LN1@HalInitial

; 44   : 		DbgPrint("HalpInitializeProcessor() returned an error.\r\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@DIODDKOF@HalpInitializeProcessor?$CI?$CJ?5return@
  00017	e8 00 00 00 00	 call	 _CrtPrintf
  0001c	83 c4 04	 add	 esp, 4

; 45   : 		return FALSE;

  0001f	33 c0		 xor	 eax, eax
  00021	eb 05		 jmp	 SHORT $LN2@HalInitial
$LN1@HalInitial:

; 46   : 	}
; 47   : 
; 48   : 	return TRUE;

  00023	b8 01 00 00 00	 mov	 eax, 1
$LN2@HalInitial:

; 49   : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_HalInitializeHal ENDP
_TEXT	ENDS
PUBLIC	_HalSetupTaskSwitchingEnv
PUBLIC	_HalSetupTSS
EXTRN	_SysGetSyscallStackPtr:PROC
EXTRN	_SysGetSyscallStackSize:PROC
EXTRN	_memset:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _HalSetupTSS
_TEXT	SEGMENT
_stack$ = -8						; size = 4
_dwEFLAGS$ = -4						; size = 4
_pTss32$ = 8						; size = 4
_IsKernelTSS$ = 12					; size = 4
_EntryPoint$ = 16					; size = 4
_pStackBase$ = 20					; size = 4
_StackSize$ = 24					; size = 4
_HalSetupTSS PROC					; COMDAT

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 57   : 	DWORD dwEFLAGS;
; 58   : 	int stack = (int)pStackBase + StackSize - 1;

  00009	8b 45 18	 mov	 eax, DWORD PTR _StackSize$[ebp]
  0000c	8b 4d 14	 mov	 ecx, DWORD PTR _pStackBase$[ebp]
  0000f	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  00013	89 55 f8	 mov	 DWORD PTR _stack$[ebp], edx

; 59   : 
; 60   : 	memset(pTss32, NULL, sizeof(TSS_32));

  00016	6a 68		 push	 104			; 00000068H
  00018	6a 00		 push	 0
  0001a	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _memset
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 61   : 
; 62   : 	_asm {
; 63   : 		push		eax

  00026	50		 push	 eax

; 64   : 		
; 65   : 		pushfd

  00027	9c		 pushfd

; 66   : 		pop			eax

  00028	58		 pop	 eax

; 67   : 		or			ah, 02h		; IF

  00029	80 cc 02	 or	 ah, 2

; 68   : 		mov			dwEFLAGS, eax

  0002c	89 45 fc	 mov	 DWORD PTR _dwEFLAGS$[ebp], eax

; 69   : 
; 70   : 		pop			eax

  0002f	58		 pop	 eax

; 71   : 	}
; 72   : 	if(IsKernelTSS) {

  00030	83 7d 0c 00	 cmp	 DWORD PTR _IsKernelTSS$[ebp], 0
  00034	74 1d		 je	 SHORT $LN2@HalSetupTS

; 73   : 		pTss32->cs				= KERNEL_CS;

  00036	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00039	66 c7 40 4c 08
	00		 mov	 WORD PTR [eax+76], 8

; 74   : 		pTss32->ds				= KERNEL_DS;

  0003f	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00042	66 c7 40 54 10
	00		 mov	 WORD PTR [eax+84], 16	; 00000010H

; 75   : 		pTss32->ss				= KERNEL_SS;

  00048	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0004b	66 c7 40 50 10
	00		 mov	 WORD PTR [eax+80], 16	; 00000010H

; 76   : 	} else {

  00051	eb 1b		 jmp	 SHORT $LN1@HalSetupTS
$LN2@HalSetupTS:

; 77   : 		pTss32->cs				= USER_CS;

  00053	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00056	66 c7 40 4c 1b
	00		 mov	 WORD PTR [eax+76], 27	; 0000001bH

; 78   : 		pTss32->ds				= USER_DS;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0005f	66 c7 40 54 23
	00		 mov	 WORD PTR [eax+84], 35	; 00000023H

; 79   : 		pTss32->ss				= USER_SS;

  00065	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00068	66 c7 40 50 23
	00		 mov	 WORD PTR [eax+80], 35	; 00000023H
$LN1@HalSetupTS:

; 80   : 	}
; 81   : 	pTss32->es					= pTss32->ds;

  0006e	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _pTss32$[ebp]
  00074	66 8b 51 54	 mov	 dx, WORD PTR [ecx+84]
  00078	66 89 50 48	 mov	 WORD PTR [eax+72], dx

; 82   : 	pTss32->fs					= pTss32->ds;

  0007c	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _pTss32$[ebp]
  00082	66 8b 51 54	 mov	 dx, WORD PTR [ecx+84]
  00086	66 89 50 58	 mov	 WORD PTR [eax+88], dx

; 83   : 	pTss32->gs					= pTss32->ds;

  0008a	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _pTss32$[ebp]
  00090	66 8b 51 54	 mov	 dx, WORD PTR [ecx+84]
  00094	66 89 50 5c	 mov	 WORD PTR [eax+92], dx

; 84   : 
; 85   : 	pTss32->eflags				= dwEFLAGS;

  00098	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _dwEFLAGS$[ebp]
  0009e	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 86   : 	pTss32->eip					= EntryPoint;

  000a1	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  000a4	8b 4d 10	 mov	 ecx, DWORD PTR _EntryPoint$[ebp]
  000a7	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 87   : 	pTss32->esp					= (DWORD)stack;

  000aa	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  000ad	8b 4d f8	 mov	 ecx, DWORD PTR _stack$[ebp]
  000b0	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 88   : 
; 89   : 	pTss32->ss0					= KERNEL_SS;

  000b3	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  000b6	66 c7 40 08 10
	00		 mov	 WORD PTR [eax+8], 16	; 00000010H

; 90   : 	pTss32->esp0				= ((DWORD)((BYTE *)SysGetSyscallStackPtr)+SysGetSyscallStackSize()-1);

  000bc	e8 00 00 00 00	 call	 _SysGetSyscallStackSize
  000c1	b9 00 00 00 00	 mov	 ecx, OFFSET _SysGetSyscallStackPtr
  000c6	c1 e1 02	 shl	 ecx, 2
  000c9	8d 54 08 fc	 lea	 edx, DWORD PTR [eax+ecx-4]
  000cd	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  000d0	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 91   : 
; 92   : 	HalSetupTaskSwitchingEnv(pTss32);

  000d3	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  000d6	50		 push	 eax
  000d7	e8 00 00 00 00	 call	 _HalSetupTaskSwitchingEnv
  000dc	83 c4 04	 add	 esp, 4

; 93   : 
; 94   : 	return TRUE;

  000df	b8 01 00 00 00	 mov	 eax, 1

; 95   : }

  000e4	5f		 pop	 edi
  000e5	5e		 pop	 esi
  000e6	5b		 pop	 ebx
  000e7	8b e5		 mov	 esp, ebp
  000e9	5d		 pop	 ebp
  000ea	c3		 ret	 0
_HalSetupTSS ENDP
_TEXT	ENDS
PUBLIC	_HalChangeTssBusyBit
; Function compile flags: /Odtp /ZI
;	COMDAT _HalSetupTaskSwitchingEnv
_TEXT	SEGMENT
_stack$ = -4						; size = 4
_pTss32$ = 8						; size = 4
_HalSetupTaskSwitchingEnv PROC				; COMDAT

; 98   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 99   : 	int stack;
; 100  : 
; 101  : ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 102  : 	stack = pTss32->esp;

  0000b	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0000e	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00011	89 4d fc	 mov	 DWORD PTR _stack$[ebp], ecx

; 103  : 	stack -= sizeof(int);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _stack$[ebp]
  00017	83 e8 04	 sub	 eax, 4
  0001a	89 45 fc	 mov	 DWORD PTR _stack$[ebp], eax

; 104  : 	*((int *)stack) = pTss32->eflags;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _stack$[ebp]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _pTss32$[ebp]
  00023	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00026	89 10		 mov	 DWORD PTR [eax], edx

; 105  : 	stack -= sizeof(int);

  00028	8b 45 fc	 mov	 eax, DWORD PTR _stack$[ebp]
  0002b	83 e8 04	 sub	 eax, 4
  0002e	89 45 fc	 mov	 DWORD PTR _stack$[ebp], eax

; 106  : 	*((int *)stack) = pTss32->cs;

  00031	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00034	0f b7 48 4c	 movzx	 ecx, WORD PTR [eax+76]
  00038	8b 55 fc	 mov	 edx, DWORD PTR _stack$[ebp]
  0003b	89 0a		 mov	 DWORD PTR [edx], ecx

; 107  : 	stack -= sizeof(int);

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _stack$[ebp]
  00040	83 e8 04	 sub	 eax, 4
  00043	89 45 fc	 mov	 DWORD PTR _stack$[ebp], eax

; 108  : 	*((int *)stack) = pTss32->eip;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _stack$[ebp]
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _pTss32$[ebp]
  0004c	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0004f	89 10		 mov	 DWORD PTR [eax], edx

; 109  : 	pTss32->esp = stack;

  00051	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _stack$[ebp]
  00057	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 110  : EXIT_CRITICAL_SECTION();

  0005a	9d		 popfd

; 111  : 
; 112  : 	HalChangeTssBusyBit(TASK_SW_SEG, TRUE);

  0005b	6a 01		 push	 1
  0005d	6a 28		 push	 40			; 00000028H
  0005f	e8 00 00 00 00	 call	 _HalChangeTssBusyBit
  00064	83 c4 08	 add	 esp, 8

; 113  : 
; 114  : 	return TRUE;

  00067	b8 01 00 00 00	 mov	 eax, 1

; 115  : }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_HalSetupTaskSwitchingEnv ENDP
_TEXT	ENDS
PUBLIC	_HalSetupTaskLink
; Function compile flags: /Odtp /ZI
;	COMDAT _HalSetupTaskLink
_TEXT	SEGMENT
_pTss32$ = 8						; size = 4
_TaskLink$ = 12						; size = 2
_HalSetupTaskLink PROC					; COMDAT

; 118  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 119  : ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 120  : 	pTss32->eflags |= 0x4000;

  0000b	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0000e	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00011	81 c9 00 40 00
	00		 or	 ecx, 16384		; 00004000H
  00017	8b 55 08	 mov	 edx, DWORD PTR _pTss32$[ebp]
  0001a	89 4a 24	 mov	 DWORD PTR [edx+36], ecx

; 121  : 	pTss32->prev_task_link = TaskLink;

  0001d	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00020	66 8b 4d 0c	 mov	 cx, WORD PTR _TaskLink$[ebp]
  00024	66 89 08	 mov	 WORD PTR [eax], cx

; 122  : EXIT_CRITICAL_SECTION();

  00027	9d		 popfd

; 123  : 
; 124  : 	return TRUE;

  00028	b8 01 00 00 00	 mov	 eax, 1

; 125  : }

  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	8b e5		 mov	 esp, ebp
  00032	5d		 pop	 ebp
  00033	c3		 ret	 0
_HalSetupTaskLink ENDP
_TEXT	ENDS
PUBLIC	_HalWriteTssIntoGdt
EXTRN	_m_GdtTable:BYTE
; Function compile flags: /Odtp /ZI
;	COMDAT _HalWriteTssIntoGdt
_TEXT	SEGMENT
_pTss32$ = 8						; size = 4
_TssSize$ = 12						; size = 4
_TssNumber$ = 16					; size = 4
_SetBusy$ = 20						; size = 4
_HalWriteTssIntoGdt PROC				; COMDAT

; 128  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 129  : ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 130  : 	m_GdtTable[TssNumber>>3].limit_1		=  (BYTE)(TssSize & 0x000000ff);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR _TssSize$[ebp]
  0000e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00013	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  00016	c1 e9 03	 shr	 ecx, 3
  00019	88 04 cd 00 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8], al

; 131  : 	m_GdtTable[TssNumber>>3].limit_2		= (BYTE)((TssSize & 0x0000ff00) >> 8);

  00020	8b 45 0c	 mov	 eax, DWORD PTR _TssSize$[ebp]
  00023	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00028	c1 e8 08	 shr	 eax, 8
  0002b	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  0002e	c1 e9 03	 shr	 ecx, 3
  00031	88 04 cd 01 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+1], al

; 132  : 	m_GdtTable[TssNumber>>3].glimit_3		= (BYTE)((TssSize & 0x000f0000) >> 16);

  00038	8b 45 0c	 mov	 eax, DWORD PTR _TssSize$[ebp]
  0003b	25 00 00 0f 00	 and	 eax, 983040		; 000f0000H
  00040	c1 e8 10	 shr	 eax, 16			; 00000010H
  00043	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  00046	c1 e9 03	 shr	 ecx, 3
  00049	88 04 cd 06 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+6], al

; 133  : 	m_GdtTable[TssNumber>>3].base_1			=  (BYTE)(((int)pTss32) & 0x000000ff);

  00050	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00053	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00058	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  0005b	c1 e9 03	 shr	 ecx, 3
  0005e	88 04 cd 02 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+2], al

; 134  : 	m_GdtTable[TssNumber>>3].base_2			= (BYTE)((((int)pTss32) & 0x0000ff00) >> 8);

  00065	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00068	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0006d	c1 f8 08	 sar	 eax, 8
  00070	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  00073	c1 e9 03	 shr	 ecx, 3
  00076	88 04 cd 03 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+3], al

; 135  : 	m_GdtTable[TssNumber>>3].base_3			= (BYTE)((((int)pTss32) & 0x00ff0000) >> 16);

  0007d	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00080	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  00085	c1 f8 10	 sar	 eax, 16			; 00000010H
  00088	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  0008b	c1 e9 03	 shr	 ecx, 3
  0008e	88 04 cd 04 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+4], al

; 136  : 	m_GdtTable[TssNumber>>3].base_4			= (BYTE)((((int)pTss32) & 0xff000000) >> 24);

  00095	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00098	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  0009d	c1 e8 18	 shr	 eax, 24			; 00000018H
  000a0	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  000a3	c1 e9 03	 shr	 ecx, 3
  000a6	88 04 cd 07 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+7], al

; 137  : 	m_GdtTable[TssNumber>>3].type			= (SetBusy ? 0x8b : 0x89);

  000ad	33 c0		 xor	 eax, eax
  000af	83 7d 14 00	 cmp	 DWORD PTR _SetBusy$[ebp], 0
  000b3	0f 95 c0	 setne	 al
  000b6	8d 84 00 89 00
	00 00		 lea	 eax, DWORD PTR [eax+eax+137]
  000bd	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  000c0	c1 e9 03	 shr	 ecx, 3
  000c3	88 04 cd 05 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+5], al

; 138  : EXIT_CRITICAL_SECTION();

  000ca	9d		 popfd

; 139  : 
; 140  : 	return TRUE;

  000cb	b8 01 00 00 00	 mov	 eax, 1

; 141  : }

  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
_HalWriteTssIntoGdt ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _HalChangeTssBusyBit
_TEXT	SEGMENT
_TssSeg$ = 8						; size = 2
_SetBit$ = 12						; size = 4
_HalChangeTssBusyBit PROC				; COMDAT

; 144  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 145  : ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 146  : 	if(SetBit) {

  0000b	83 7d 0c 00	 cmp	 DWORD PTR _SetBit$[ebp], 0
  0000f	74 22		 je	 SHORT $LN2@HalChangeT

; 147  : 		m_GdtTable[TssSeg>>3].type |= 0x02;

  00011	0f b7 45 08	 movzx	 eax, WORD PTR _TssSeg$[ebp]
  00015	c1 f8 03	 sar	 eax, 3
  00018	0f b6 0c c5 05
	00 00 00	 movzx	 ecx, BYTE PTR _m_GdtTable[eax*8+5]
  00020	83 c9 02	 or	 ecx, 2
  00023	0f b7 55 08	 movzx	 edx, WORD PTR _TssSeg$[ebp]
  00027	c1 fa 03	 sar	 edx, 3
  0002a	88 0c d5 05 00
	00 00		 mov	 BYTE PTR _m_GdtTable[edx*8+5], cl

; 148  : 	} else {

  00031	eb 23		 jmp	 SHORT $LN1@HalChangeT
$LN2@HalChangeT:

; 149  : 		m_GdtTable[TssSeg>>3].type &= 0xfd;

  00033	0f b7 45 08	 movzx	 eax, WORD PTR _TssSeg$[ebp]
  00037	c1 f8 03	 sar	 eax, 3
  0003a	0f b6 0c c5 05
	00 00 00	 movzx	 ecx, BYTE PTR _m_GdtTable[eax*8+5]
  00042	81 e1 fd 00 00
	00		 and	 ecx, 253		; 000000fdH
  00048	0f b7 55 08	 movzx	 edx, WORD PTR _TssSeg$[ebp]
  0004c	c1 fa 03	 sar	 edx, 3
  0004f	88 0c d5 05 00
	00 00		 mov	 BYTE PTR _m_GdtTable[edx*8+5], cl
$LN1@HalChangeT:

; 150  : 	}
; 151  : EXIT_CRITICAL_SECTION();

  00056	9d		 popfd

; 152  : }

  00057	5f		 pop	 edi
  00058	5e		 pop	 esi
  00059	5b		 pop	 ebx
  0005a	8b e5		 mov	 esp, ebp
  0005c	5d		 pop	 ebp
  0005d	c3		 ret	 0
_HalChangeTssBusyBit ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@FBKHEGHB@Interrupt?5Service?5is?5installed?$CB?$CB@ ; `string'
PUBLIC	??_C@_0CL@KJAKIFMC@HalpStartIntService?$CI?$CJ?5returned?5a@ ; `string'
PUBLIC	??_C@_0BP@OLPBBHME@SystemTimer?5is?5initialized?$CB?$CB?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@HNIFLDMK@HalpInitSysTimer?$CI?$CJ?5returned?5an?5e@ ; `string'
PUBLIC	??_C@_0BD@GMFGECEC@PIC?5is?5success?$CB?$CB?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@GOIDGDAA@HalpInitPIC?$CI?$CJ?5returned?5an?5error?4@ ; `string'
PUBLIC	??_C@_0BI@MIIPFAGL@A20?5line?5is?5success?$CB?$CB?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CF@GHKHCIHI@HalpEnableA20?$CI?$CJ?5returned?5an?5erro@ ; `string'
;	COMDAT ??_C@_0CD@FBKHEGHB@Interrupt?5Service?5is?5installed?$CB?$CB@
CONST	SEGMENT
??_C@_0CD@FBKHEGHB@Interrupt?5Service?5is?5installed?$CB?$CB@ DB 'Interru'
	DB	'pt Service is installed!!', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KJAKIFMC@HalpStartIntService?$CI?$CJ?5returned?5a@
CONST	SEGMENT
??_C@_0CL@KJAKIFMC@HalpStartIntService?$CI?$CJ?5returned?5a@ DB 'HalpStar'
	DB	'tIntService() returned an error.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OLPBBHME@SystemTimer?5is?5initialized?$CB?$CB?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BP@OLPBBHME@SystemTimer?5is?5initialized?$CB?$CB?$AN?6?$AA@ DB 'Sy'
	DB	'stemTimer is initialized!!', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HNIFLDMK@HalpInitSysTimer?$CI?$CJ?5returned?5an?5e@
CONST	SEGMENT
??_C@_0CI@HNIFLDMK@HalpInitSysTimer?$CI?$CJ?5returned?5an?5e@ DB 'HalpIni'
	DB	'tSysTimer() returned an error.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GMFGECEC@PIC?5is?5success?$CB?$CB?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@GMFGECEC@PIC?5is?5success?$CB?$CB?$AN?6?$AA@ DB 'PIC is success'
	DB	'!!', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GOIDGDAA@HalpInitPIC?$CI?$CJ?5returned?5an?5error?4@
CONST	SEGMENT
??_C@_0CD@GOIDGDAA@HalpInitPIC?$CI?$CJ?5returned?5an?5error?4@ DB 'HalpIn'
	DB	'itPIC() returned an error.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MIIPFAGL@A20?5line?5is?5success?$CB?$CB?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BI@MIIPFAGL@A20?5line?5is?5success?$CB?$CB?$AN?6?$AA@ DB 'A20 line'
	DB	' is success!!', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GHKHCIHI@HalpEnableA20?$CI?$CJ?5returned?5an?5erro@
CONST	SEGMENT
??_C@_0CF@GHKHCIHI@HalpEnableA20?$CI?$CJ?5returned?5an?5erro@ DB 'HalpEna'
	DB	'bleA20() returned an error.', 0dH, 0aH, 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _HalpInitializeProcessor
_TEXT	SEGMENT
_HalpInitializeProcessor PROC				; COMDAT

; 156  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 157  : 	//A20 Line 활성화 함수
; 158  : 	if(!HalpEnableA20()) {

  00009	e8 00 00 00 00	 call	 _HalpEnableA20
  0000e	85 c0		 test	 eax, eax
  00010	75 14		 jne	 SHORT $LN4@HalpInitia

; 159  : 		DbgPrint("HalpEnableA20() returned an error.\r\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@GHKHCIHI@HalpEnableA20?$CI?$CJ?5returned?5an?5erro@
  00017	e8 00 00 00 00	 call	 _CrtPrintf
  0001c	83 c4 04	 add	 esp, 4

; 160  : 		return FALSE;

  0001f	33 c0		 xor	 eax, eax
  00021	e9 8c 00 00 00	 jmp	 $LN5@HalpInitia
$LN4@HalpInitia:

; 161  : 	}
; 162  : 	DbgPrint("A20 line is success!!\r\n");

  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@MIIPFAGL@A20?5line?5is?5success?$CB?$CB?$AN?6?$AA@
  0002b	e8 00 00 00 00	 call	 _CrtPrintf
  00030	83 c4 04	 add	 esp, 4

; 163  : 
; 164  : 	//PIC 초기화 함수
; 165  : 	if(!HalpInitPIC()) {

  00033	e8 00 00 00 00	 call	 _HalpInitPIC
  00038	85 c0		 test	 eax, eax
  0003a	75 11		 jne	 SHORT $LN3@HalpInitia

; 166  : 		DbgPrint("HalpInitPIC() returned an error.\r\n");

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@GOIDGDAA@HalpInitPIC?$CI?$CJ?5returned?5an?5error?4@
  00041	e8 00 00 00 00	 call	 _CrtPrintf
  00046	83 c4 04	 add	 esp, 4

; 167  : 		return FALSE;

  00049	33 c0		 xor	 eax, eax
  0004b	eb 65		 jmp	 SHORT $LN5@HalpInitia
$LN3@HalpInitia:

; 168  : 	}
; 169  : 	DbgPrint("PIC is success!!\r\n");

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@GMFGECEC@PIC?5is?5success?$CB?$CB?$AN?6?$AA@
  00052	e8 00 00 00 00	 call	 _CrtPrintf
  00057	83 c4 04	 add	 esp, 4

; 170  : 
; 171  : 	//TIMER 초기화 함수
; 172  : 	if(!HalpInitSysTimer(TIMEOUT_PER_SECOND)) {

  0005a	6a 32		 push	 50			; 00000032H
  0005c	e8 00 00 00 00	 call	 _HalpInitSysTimer
  00061	83 c4 04	 add	 esp, 4
  00064	85 c0		 test	 eax, eax
  00066	75 11		 jne	 SHORT $LN2@HalpInitia

; 173  : 		DbgPrint("HalpInitSysTimer() returned an error.\r\n");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HNIFLDMK@HalpInitSysTimer?$CI?$CJ?5returned?5an?5e@
  0006d	e8 00 00 00 00	 call	 _CrtPrintf
  00072	83 c4 04	 add	 esp, 4

; 174  : 		return FALSE;

  00075	33 c0		 xor	 eax, eax
  00077	eb 39		 jmp	 SHORT $LN5@HalpInitia
$LN2@HalpInitia:

; 175  : 	}
; 176  : 	DbgPrint("SystemTimer is initialized!!\r\n");

  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OLPBBHME@SystemTimer?5is?5initialized?$CB?$CB?$AN?6?$AA@
  0007e	e8 00 00 00 00	 call	 _CrtPrintf
  00083	83 c4 04	 add	 esp, 4

; 177  : 
; 178  : 	//INTERRUPT 초기화 함수 
; 179  : 	if(!HalpStartIntService()) {

  00086	e8 00 00 00 00	 call	 _HalpStartIntService
  0008b	85 c0		 test	 eax, eax
  0008d	75 11		 jne	 SHORT $LN1@HalpInitia

; 180  : 		DbgPrint("HalpStartIntService() returned an error.\r\n");

  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@KJAKIFMC@HalpStartIntService?$CI?$CJ?5returned?5a@
  00094	e8 00 00 00 00	 call	 _CrtPrintf
  00099	83 c4 04	 add	 esp, 4

; 181  : 		return FALSE;

  0009c	33 c0		 xor	 eax, eax
  0009e	eb 12		 jmp	 SHORT $LN5@HalpInitia
$LN1@HalpInitia:

; 182  : 	}
; 183  : 	DbgPrint("Interrupt Service is installed!!\r\n");

  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@FBKHEGHB@Interrupt?5Service?5is?5installed?$CB?$CB@
  000a5	e8 00 00 00 00	 call	 _CrtPrintf
  000aa	83 c4 04	 add	 esp, 4

; 184  : 
; 185  : 
; 186  : 	return TRUE;

  000ad	b8 01 00 00 00	 mov	 eax, 1
$LN5@HalpInitia:

; 187  : }

  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
_HalpInitializeProcessor ENDP
_TEXT	ENDS
EXTRN	_WRITE_PORT_UCHAR:PROC
EXTRN	_READ_PORT_UCHAR:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _HalpEnableA20
_TEXT	SEGMENT
_flag$ = -18						; size = 1
_status$ = -17						; size = 1
_test_2_buf$ = -16					; size = 4
_test_2$ = -12						; size = 4
_test_1_buf$ = -8					; size = 4
_test_1$ = -4						; size = 4
_HalpEnableA20 PROC					; COMDAT

; 189  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 190  : 	int *test_1 = (int *)0x00000000, test_1_buf;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _test_1$[ebp], 0

; 191  : 	int *test_2 = (int *)0x00100000, test_2_buf;

  00010	c7 45 f4 00 00
	10 00		 mov	 DWORD PTR _test_2$[ebp], 1048576 ; 00100000H
$LN16@HalpEnable:

; 192  : 	UCHAR status, flag;
; 193  : 
; 194  : 	//Status Register(0x64)를 읽어서 입력 버퍼에 데이터가 없을 때까지 대기.
; 195  : 	do { status = READ_PORT_UCHAR((PUCHAR)0x64); }

  00017	6a 64		 push	 100			; 00000064H
  00019	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  0001e	83 c4 04	 add	 esp, 4
  00021	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 196  : 	while( status & 0x02 );

  00024	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  00028	83 e0 02	 and	 eax, 2
  0002b	75 ea		 jne	 SHORT $LN16@HalpEnable

; 197  : 	//Control Register에 데이터를 쓰는 과정
; 198  : 	//output port에서 데이터를 읽어서 출력 버퍼(0x60)에 데이터를 저장하라는 명령.
; 199  : 		WRITE_PORT_UCHAR((PUCHAR)0x64, 0xd0);

  0002d	68 d0 00 00 00	 push	 208			; 000000d0H
  00032	6a 64		 push	 100			; 00000064H
  00034	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00039	83 c4 08	 add	 esp, 8
$LN13@HalpEnable:

; 200  : 
; 201  : 	//Status Register(Ox64)를 읽어서 출력 버퍼(Ox60)에 데이터가 들어올때 까지 대기.
; 202  : 	do { status = READ_PORT_UCHAR((PUCHAR)0x64); }

  0003c	6a 64		 push	 100			; 00000064H
  0003e	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00043	83 c4 04	 add	 esp, 4
  00046	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 203  : 	while( !(status&0x01) );

  00049	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  0004d	83 e0 01	 and	 eax, 1
  00050	74 ea		 je	 SHORT $LN13@HalpEnable

; 204  : 	//출력 버퍼(Ox60)에서 데이터를 읽은 후에 A20 GATE(두 번째 비트)활성화 	
; 205  : 	flag = READ_PORT_UCHAR((PUCHAR)0x60);

  00052	6a 60		 push	 96			; 00000060H
  00054	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00059	83 c4 04	 add	 esp, 4
  0005c	88 45 ee	 mov	 BYTE PTR _flag$[ebp], al

; 206  : 	flag |= 0x02; // A20 line 활성화

  0005f	0f b6 45 ee	 movzx	 eax, BYTE PTR _flag$[ebp]
  00063	83 c8 02	 or	 eax, 2
  00066	88 45 ee	 mov	 BYTE PTR _flag$[ebp], al
$LN10@HalpEnable:

; 207  : 
; 208  : 	//flag값을 Register에 써넣어 A20 활성화
; 209  : 	do { status = READ_PORT_UCHAR((PUCHAR)0x64); }

  00069	6a 64		 push	 100			; 00000064H
  0006b	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00070	83 c4 04	 add	 esp, 4
  00073	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 210  : 	while( status & 0x02 );

  00076	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  0007a	83 e0 02	 and	 eax, 2
  0007d	75 ea		 jne	 SHORT $LN10@HalpEnable

; 211  : 	WRITE_PORT_UCHAR((PUCHAR)0x64, 0xd1);

  0007f	68 d1 00 00 00	 push	 209			; 000000d1H
  00084	6a 64		 push	 100			; 00000064H
  00086	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0008b	83 c4 08	 add	 esp, 8
$LN7@HalpEnable:

; 212  : 
; 213  : 	do { status = READ_PORT_UCHAR((PUCHAR)0x64); } 

  0008e	6a 64		 push	 100			; 00000064H
  00090	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00095	83 c4 04	 add	 esp, 4
  00098	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 214  : 	while( status & 0x02 );

  0009b	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  0009f	83 e0 02	 and	 eax, 2
  000a2	75 ea		 jne	 SHORT $LN7@HalpEnable

; 215  : 	WRITE_PORT_UCHAR((PUCHAR)0x60, flag); 

  000a4	8a 45 ee	 mov	 al, BYTE PTR _flag$[ebp]
  000a7	50		 push	 eax
  000a8	6a 60		 push	 96			; 00000060H
  000aa	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  000af	83 c4 08	 add	 esp, 8
$LN4@HalpEnable:

; 216  : 
; 217  : 	do { status = READ_PORT_UCHAR((PUCHAR)0x64); } 

  000b2	6a 64		 push	 100			; 00000064H
  000b4	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  000b9	83 c4 04	 add	 esp, 4
  000bc	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 218  : 	while( status & 0x02 );

  000bf	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  000c3	83 e0 02	 and	 eax, 2
  000c6	75 ea		 jne	 SHORT $LN4@HalpEnable

; 219  : 
; 220  : 	//Test A20 line
; 221  : 	test_1_buf = *test_1;

  000c8	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  000cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cd	89 4d f8	 mov	 DWORD PTR _test_1_buf$[ebp], ecx

; 222  : 	test_2_buf = *test_2;

  000d0	8b 45 f4	 mov	 eax, DWORD PTR _test_2$[ebp]
  000d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d5	89 4d f0	 mov	 DWORD PTR _test_2_buf$[ebp], ecx

; 223  : 	*test_1 = 0xff00ccaa;

  000d8	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  000db	c7 00 aa cc 00
	ff		 mov	 DWORD PTR [eax], -16724822 ; ff00ccaaH

; 224  : 	*test_2 = 0x22cc11dd;

  000e1	8b 45 f4	 mov	 eax, DWORD PTR _test_2$[ebp]
  000e4	c7 00 dd 11 cc
	22		 mov	 DWORD PTR [eax], 583799261 ; 22cc11ddH

; 225  : 	if(*test_1 == *test_2) {

  000ea	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  000ed	8b 4d f4	 mov	 ecx, DWORD PTR _test_2$[ebp]
  000f0	8b 10		 mov	 edx, DWORD PTR [eax]
  000f2	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000f4	75 0c		 jne	 SHORT $LN1@HalpEnable

; 226  : 		*test_1 = test_1_buf;

  000f6	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  000f9	8b 4d f8	 mov	 ecx, DWORD PTR _test_1_buf$[ebp]
  000fc	89 08		 mov	 DWORD PTR [eax], ecx

; 227  : 		return FALSE;

  000fe	33 c0		 xor	 eax, eax
  00100	eb 15		 jmp	 SHORT $LN17@HalpEnable
$LN1@HalpEnable:

; 228  : 	}
; 229  : 	//A20 line이 활성화 되었다면, test_1과 test_2의 값이 달라야 한다.
; 230  : 	*test_1 = test_1_buf;

  00102	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  00105	8b 4d f8	 mov	 ecx, DWORD PTR _test_1_buf$[ebp]
  00108	89 08		 mov	 DWORD PTR [eax], ecx

; 231  : 	*test_2 = test_2_buf;

  0010a	8b 45 f4	 mov	 eax, DWORD PTR _test_2$[ebp]
  0010d	8b 4d f0	 mov	 ecx, DWORD PTR _test_2_buf$[ebp]
  00110	89 08		 mov	 DWORD PTR [eax], ecx

; 232  : 
; 233  : 	return TRUE;

  00112	b8 01 00 00 00	 mov	 eax, 1
$LN17@HalpEnable:

; 234  : }

  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
_HalpEnableA20 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _HalpInitPIC
_TEXT	SEGMENT
_HalpInitPIC PROC					; COMDAT

; 244  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 245  : 	// Master PIC
; 246  : 	WRITE_PORT_UCHAR((PUCHAR)0x20, 0x11); //ICW1 : Cascade mode, ICW4 

  00009	6a 11		 push	 17			; 00000011H
  0000b	6a 20		 push	 32			; 00000020H
  0000d	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00012	83 c4 08	 add	 esp, 8

; 247  : 	WRITE_PORT_UCHAR((PUCHAR)0x21, 0x20); //ICW2 : 인터럽트 시작 값 INT vector 20h 

  00015	6a 20		 push	 32			; 00000020H
  00017	6a 21		 push	 33			; 00000021H
  00019	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0001e	83 c4 08	 add	 esp, 8

; 248  : 	WRITE_PORT_UCHAR((PUCHAR)0x21, 0x04); //ICW3  

  00021	6a 04		 push	 4
  00023	6a 21		 push	 33			; 00000021H
  00025	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0002a	83 c4 08	 add	 esp, 8

; 249  : 	WRITE_PORT_UCHAR((PUCHAR)0x21, 0x01); //ICW4 

  0002d	6a 01		 push	 1
  0002f	6a 21		 push	 33			; 00000021H
  00031	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00036	83 c4 08	 add	 esp, 8

; 250  : 	WRITE_PORT_UCHAR((PUCHAR)0x21, 0x00);

  00039	6a 00		 push	 0
  0003b	6a 21		 push	 33			; 00000021H
  0003d	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00042	83 c4 08	 add	 esp, 8

; 251  : 
; 252  : 	// Slave PIC 
; 253  : 	WRITE_PORT_UCHAR((PUCHAR)0xa0, 0x11); //ICW1 : Cascade mode, ICW4 

  00045	6a 11		 push	 17			; 00000011H
  00047	68 a0 00 00 00	 push	 160			; 000000a0H
  0004c	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00051	83 c4 08	 add	 esp, 8

; 254  : 	WRITE_PORT_UCHAR((PUCHAR)0xa1, 0x28); //ICW2 : 인터럽트 시작 값 INT vector 28h 

  00054	6a 28		 push	 40			; 00000028H
  00056	68 a1 00 00 00	 push	 161			; 000000a1H
  0005b	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00060	83 c4 08	 add	 esp, 8

; 255  : 	WRITE_PORT_UCHAR((PUCHAR)0xa1, 0x02); //ICW3  

  00063	6a 02		 push	 2
  00065	68 a1 00 00 00	 push	 161			; 000000a1H
  0006a	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0006f	83 c4 08	 add	 esp, 8

; 256  : 	WRITE_PORT_UCHAR((PUCHAR)0xa1, 0x01); //ICW4 

  00072	6a 01		 push	 1
  00074	68 a1 00 00 00	 push	 161			; 000000a1H
  00079	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0007e	83 c4 08	 add	 esp, 8

; 257  : 	WRITE_PORT_UCHAR((PUCHAR)0xa1, 0x00);

  00081	6a 00		 push	 0
  00083	68 a1 00 00 00	 push	 161			; 000000a1H
  00088	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0008d	83 c4 08	 add	 esp, 8

; 258  : 
; 259  : 	return TRUE;

  00090	b8 01 00 00 00	 mov	 eax, 1

; 260  : }

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
_HalpInitPIC ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _HalpInitSysTimer
_TEXT	SEGMENT
_timeout$ = -4						; size = 2
_timeoutPerSecond$ = 8					; size = 1
_HalpInitSysTimer PROC					; COMDAT

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 264  : 	//새로운 counter 값 입력
; 265  : 	WORD timeout = (WORD)(1193180/timeoutPerSecond);

  00009	0f b6 4d 08	 movzx	 ecx, BYTE PTR _timeoutPerSecond$[ebp]
  0000d	b8 dc 34 12 00	 mov	 eax, 1193180		; 001234dcH
  00012	99		 cdq
  00013	f7 f9		 idiv	 ecx
  00015	66 89 45 fc	 mov	 WORD PTR _timeout$[ebp], ax

; 266  : 
; 267  : 	WRITE_PORT_UCHAR((PUCHAR)0x43, 0x34);

  00019	6a 34		 push	 52			; 00000034H
  0001b	6a 43		 push	 67			; 00000043H
  0001d	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00022	83 c4 08	 add	 esp, 8

; 268  : 
; 269  : 	//COUNTER 0 Register의 Low, High byte 값 설정
; 270  : 	WRITE_PORT_UCHAR((PUCHAR)0x40, (UCHAR)(timeout & 0xff));

  00025	0f b7 45 fc	 movzx	 eax, WORD PTR _timeout$[ebp]
  00029	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002e	50		 push	 eax
  0002f	6a 40		 push	 64			; 00000040H
  00031	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00036	83 c4 08	 add	 esp, 8

; 271  : 	WRITE_PORT_UCHAR((PUCHAR)0x40, (UCHAR)(timeout >> 8));

  00039	0f b7 45 fc	 movzx	 eax, WORD PTR _timeout$[ebp]
  0003d	c1 f8 08	 sar	 eax, 8
  00040	50		 push	 eax
  00041	6a 40		 push	 64			; 00000040H
  00043	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00048	83 c4 08	 add	 esp, 8

; 272  : 
; 273  : 	return TRUE;

  0004b	b8 01 00 00 00	 mov	 eax, 1

; 274  : }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_HalpInitSysTimer ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_DivideByZero
_TEXT	SEGMENT
_Halp_ECT_DivideByZero PROC				; COMDAT

; 280  : 	static char *msg = "Halp_ECT_DivideByZero() \r\n";
; 281  : 	_asm {
; 282  : 		pushad

  00000	60		 pushad

; 283  : 
; 284  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_DivideByZero@@9@9

; 285  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 286  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 287  : 
; 288  : 		popad

  0000f	61		 popad

; 289  : 		iretd

  00010	cf		 iretd
_Halp_ECT_DivideByZero ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_DebugException
_TEXT	SEGMENT
_Halp_ECT_DebugException PROC				; COMDAT

; 295  : 	static char *msg = "Halp_ECT_DebugException() \r\n";
; 296  : 	_asm {
; 297  : 		pushad

  00000	60		 pushad

; 298  : 
; 299  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_DebugException@@9@9

; 300  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 301  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 302  : 
; 303  : 		popad

  0000f	61		 popad

; 304  : 		iretd

  00010	cf		 iretd
_Halp_ECT_DebugException ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_NMI
_TEXT	SEGMENT
_Halp_ECT_NMI PROC					; COMDAT

; 310  : 	static char *msg = "Halp_ECT_NMI() \r\n";
; 311  : 	_asm {
; 312  : 		pushad

  00000	60		 pushad

; 313  : 
; 314  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_NMI@@9@9

; 315  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 316  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 317  : 
; 318  : 		popad

  0000f	61		 popad

; 319  : 		iretd

  00010	cf		 iretd
_Halp_ECT_NMI ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@FJNLJOKK@bp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@ ; `string'
_BSS	SEGMENT
?dwESP@?1??Halp_ECT_Breakpoint@@9@9 DD 01H DUP (?)	; `Halp_ECT_Breakpoint'::`2'::dwESP
_BSS	ENDS
;	COMDAT ??_C@_0CB@FJNLJOKK@bp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@
CONST	SEGMENT
??_C@_0CB@FJNLJOKK@bp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@ DB 'b'
	DB	'p, #1:0x%x, #2:0x%x, #3:0x%x ', 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _Halp_ECT_Breakpoint
_TEXT	SEGMENT
_Halp_ECT_Breakpoint PROC				; COMDAT

; 325  : 	static char *msg = "Halp_ECT_Breakpoint() \r\n";
; 326  : 	static int dwESP;
; 327  : 	_asm {
; 328  : 		cli

  00000	fa		 cli

; 329  : 		mov	dwESP, esp

  00001	89 25 00 00 00
	00		 mov	 DWORD PTR ?dwESP@?1??Halp_ECT_Breakpoint@@9@9, esp

; 330  : 		pushad

  00007	60		 pushad

; 331  : 	}
; 332  : 
; 333  : 	DbgPrint("bp, #1:0x%x, #2:0x%x, #3:0x%x \r\n", *((int *)dwESP), *((int *)dwESP+1), *((int *)dwESP+2));

  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwESP@?1??Halp_ECT_Breakpoint@@9@9
  0000d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00010	51		 push	 ecx
  00011	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?dwESP@?1??Halp_ECT_Breakpoint@@9@9
  00017	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001a	50		 push	 eax
  0001b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?dwESP@?1??Halp_ECT_Breakpoint@@9@9
  00021	8b 11		 mov	 edx, DWORD PTR [ecx]
  00023	52		 push	 edx
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@FJNLJOKK@bp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@
  00029	e8 00 00 00 00	 call	 _CrtPrintf
  0002e	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@Halp_ECT_B:

; 334  : 	while(1) ;

  00031	b8 01 00 00 00	 mov	 eax, 1
  00036	85 c0		 test	 eax, eax
  00038	74 02		 je	 SHORT $LN1@Halp_ECT_B
  0003a	eb f5		 jmp	 SHORT $LN2@Halp_ECT_B
$LN1@Halp_ECT_B:

; 335  : 
; 336  : 	_asm {
; 337  : 		popad

  0003c	61		 popad

; 338  : 		iretd

  0003d	cf		 iretd
_Halp_ECT_Breakpoint ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_INTO
_TEXT	SEGMENT
_Halp_ECT_INTO PROC					; COMDAT

; 344  : 	static char *msg = "Halp_ECT_INTO() \r\n";
; 345  : 	_asm {
; 346  : 		pushad

  00000	60		 pushad

; 347  : 
; 348  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_INTO@@9@9

; 349  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 350  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 351  : 
; 352  : 		popad

  0000f	61		 popad

; 353  : 		iretd

  00010	cf		 iretd
_Halp_ECT_INTO ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_BOUNDS
_TEXT	SEGMENT
_Halp_ECT_BOUNDS PROC					; COMDAT

; 359  : 	static char *msg = "Halp_ECT_BOUNDS() \r\n";
; 360  : 	_asm {
; 361  : 		pushad

  00000	60		 pushad

; 362  : 
; 363  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_BOUNDS@@9@9

; 364  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 365  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 366  : 
; 367  : 		popad

  0000f	61		 popad

; 368  : 		iretd

  00010	cf		 iretd
_Halp_ECT_BOUNDS ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_InvaildOpcode
_TEXT	SEGMENT
_Halp_ECT_InvaildOpcode PROC				; COMDAT

; 374  : 	static char *msg = "Halp_ECT_InvaildOpcode() \r\n";
; 375  : 	_asm {
; 376  : 		pushad

  00000	60		 pushad

; 377  : 
; 378  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_InvaildOpcode@@9@9

; 379  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 380  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4
$infinate$1163:

; 381  : 
; 382  : infinate:
; 383  : 		jmp		infinate

  0000f	eb fe		 jmp	 SHORT $infinate$1163

; 384  : 
; 385  : 		popad

  00011	61		 popad

; 386  : 		iretd

  00012	cf		 iretd
_Halp_ECT_InvaildOpcode ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_DeviceNotAvailable
_TEXT	SEGMENT
_Halp_ECT_DeviceNotAvailable PROC			; COMDAT

; 392  : 	static char *msg = "Halp_ECT_DeviceNotAvailable() \r\n";
; 393  : 	_asm {
; 394  : 		pushad

  00000	60		 pushad

; 395  : 
; 396  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_DeviceNotAvailable@@9@9

; 397  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 398  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 399  : 
; 400  : 		popad

  0000f	61		 popad

; 401  : 		iretd

  00010	cf		 iretd
_Halp_ECT_DeviceNotAvailable ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_DoubleFault
_TEXT	SEGMENT
_Halp_ECT_DoubleFault PROC				; COMDAT

; 407  : 	_asm {
; 408  : 		mov		ebx, 0b8000h

  00000	bb 00 80 0b 00	 mov	 ebx, 753664		; 000b8000H

; 409  : 		mov		ecx, 80*25

  00005	b9 d0 07 00 00	 mov	 ecx, 2000		; 000007d0H
$fault_loop$1173:

; 410  : 
; 411  : fault_loop:
; 412  : 		mov		byte ptr [ebx], '#'

  0000a	c6 03 23	 mov	 BYTE PTR [ebx], 35	; 00000023H

; 413  : 		mov		byte ptr [ebx+1], 7

  0000d	c6 43 01 07	 mov	 BYTE PTR [ebx+1], 7

; 414  : 		add		ebx, 2

  00011	83 c3 02	 add	 ebx, 2

; 415  : 		loop	fault_loop

  00014	e2 f4		 loop	 $fault_loop$1173
$infinate$1174:

; 416  : 
; 417  : infinate:
; 418  : 		jmp		infinate

  00016	eb fe		 jmp	 SHORT $infinate$1174
_Halp_ECT_DoubleFault ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_CoprocessorOverrun
_TEXT	SEGMENT
_Halp_ECT_CoprocessorOverrun PROC			; COMDAT

; 424  : 	static char *msg = "Halp_ECT_CoprocessorOverrun() \r\n";
; 425  : 	_asm {
; 426  : 		pushad

  00000	60		 pushad

; 427  : 
; 428  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_CoprocessorOverrun@@9@9

; 429  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 430  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 431  : 
; 432  : 		popad

  0000f	61		 popad

; 433  : 		iretd

  00010	cf		 iretd
_Halp_ECT_CoprocessorOverrun ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_InvalidTSS
_TEXT	SEGMENT
_Halp_ECT_InvalidTSS PROC				; COMDAT

; 439  : 	static char *msg = "Halp_ECT_InvalidTSS() \r\n";
; 440  : 	_asm {
; 441  : 		pushad

  00000	60		 pushad

; 442  : 
; 443  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_InvalidTSS@@9@9

; 444  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 445  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 446  : 
; 447  : 		popad

  0000f	61		 popad

; 448  : 		iretd

  00010	cf		 iretd
_Halp_ECT_InvalidTSS ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_SegmentNotPresent
_TEXT	SEGMENT
_Halp_ECT_SegmentNotPresent PROC			; COMDAT

; 454  : 	static char *msg = "Halp_ECT_SegmentNotPresent() \r\n";
; 455  : 	_asm {
; 456  : 		pushad

  00000	60		 pushad

; 457  : 
; 458  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_SegmentNotPresent@@9@9

; 459  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 460  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 461  : 
; 462  : 		popad

  0000f	61		 popad

; 463  : 		iretd

  00010	cf		 iretd
_Halp_ECT_SegmentNotPresent ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_StackException
_TEXT	SEGMENT
_Halp_ECT_StackException PROC				; COMDAT

; 469  : 	static char *msg = "Halp_ECT_StackException() \r\n";
; 470  : 	_asm {
; 471  : 		pushad

  00000	60		 pushad

; 472  : 
; 473  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_StackException@@9@9

; 474  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 475  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 476  : 
; 477  : 		popad

  0000f	61		 popad

; 478  : 		iretd

  00010	cf		 iretd
_Halp_ECT_StackException ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@LEODENJF@gp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@ ; `string'
_BSS	SEGMENT
?dwESP@?1??Halp_ECT_GeneralProtection@@9@9 DD 01H DUP (?) ; `Halp_ECT_GeneralProtection'::`2'::dwESP
_BSS	ENDS
;	COMDAT ??_C@_0CB@LEODENJF@gp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@
CONST	SEGMENT
??_C@_0CB@LEODENJF@gp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@ DB 'g'
	DB	'p, #1:0x%x, #2:0x%x, #3:0x%x ', 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _Halp_ECT_GeneralProtection
_TEXT	SEGMENT
_Halp_ECT_GeneralProtection PROC			; COMDAT

; 484  : 	static char *msg = "Halp_ECT_GeneralProtection() \r\n";
; 485  : 	static int dwESP;
; 486  : 	_asm {
; 487  : 		mov		dwESP, esp

  00000	89 25 00 00 00
	00		 mov	 DWORD PTR ?dwESP@?1??Halp_ECT_GeneralProtection@@9@9, esp

; 488  : 		pushad

  00006	60		 pushad

; 489  : 
; 490  : 		push	msg

  00007	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_GeneralProtection@@9@9

; 491  : 		call	CrtPrintf

  0000d	e8 00 00 00 00	 call	 _CrtPrintf

; 492  : 		add		esp, 4

  00012	83 c4 04	 add	 esp, 4

; 493  : 	}
; 494  : 
; 495  : 	DbgPrint("gp, #1:0x%x, #2:0x%x, #3:0x%x \r\n", *((int *)dwESP+0), *((int *)dwESP+1), *((int *)dwESP+2));

  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwESP@?1??Halp_ECT_GeneralProtection@@9@9
  0001a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001d	51		 push	 ecx
  0001e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?dwESP@?1??Halp_ECT_GeneralProtection@@9@9
  00024	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00027	50		 push	 eax
  00028	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?dwESP@?1??Halp_ECT_GeneralProtection@@9@9
  0002e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00030	52		 push	 edx
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@LEODENJF@gp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@
  00036	e8 00 00 00 00	 call	 _CrtPrintf
  0003b	83 c4 10	 add	 esp, 16			; 00000010H
$infinate$1211:

; 496  : 
; 497  : 	_asm {
; 498  : infinate:
; 499  : 		jmp		infinate

  0003e	eb fe		 jmp	 SHORT $infinate$1211

; 500  : 
; 501  : 		popad

  00040	61		 popad

; 502  : 		iretd

  00041	cf		 iretd
_Halp_ECT_GeneralProtection ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_PageFault
_TEXT	SEGMENT
_Halp_ECT_PageFault PROC				; COMDAT

; 508  : 	static char *msg = "Halp_ECT_PageFault() \r\n";
; 509  : 	_asm {
; 510  : 		pushad

  00000	60		 pushad

; 511  : 
; 512  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_PageFault@@9@9

; 513  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 514  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 515  : 
; 516  : 		popad

  0000f	61		 popad

; 517  : 		iretd

  00010	cf		 iretd
_Halp_ECT_PageFault ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_FloatingPointError
_TEXT	SEGMENT
_Halp_ECT_FloatingPointError PROC			; COMDAT

; 523  : 	static char *msg = "Halp_ECT_FloatingPointError() \r\n";
; 524  : 	_asm {
; 525  : 		pushad

  00000	60		 pushad

; 526  : 
; 527  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_FloatingPointError@@9@9

; 528  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 529  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 530  : 
; 531  : 		popad

  0000f	61		 popad

; 532  : 		iretd

  00010	cf		 iretd
_Halp_ECT_FloatingPointError ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_AlignmentCheck
_TEXT	SEGMENT
_Halp_ECT_AlignmentCheck PROC				; COMDAT

; 538  : 	static char *msg = "Halp_ECT_AlignmentCheck() \r\n";
; 539  : 	_asm {
; 540  : 		pushad

  00000	60		 pushad

; 541  : 
; 542  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_AlignmentCheck@@9@9

; 543  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 544  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 545  : 
; 546  : 		popad

  0000f	61		 popad

; 547  : 		iretd

  00010	cf		 iretd
_Halp_ECT_AlignmentCheck ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_MachineCheck
_TEXT	SEGMENT
_Halp_ECT_MachineCheck PROC				; COMDAT

; 553  : 	static char *msg = "Halp_ECT_MachineCheck() \r\n";
; 554  : 	_asm {
; 555  : 		pushad

  00000	60		 pushad

; 556  : 
; 557  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_MachineCheck@@9@9

; 558  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 559  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 560  : 
; 561  : 		popad

  0000f	61		 popad

; 562  : 		iretd

  00010	cf		 iretd
_Halp_ECT_MachineCheck ENDP
_TEXT	ENDS
EXTRN	_Kbd_IRQ_Handler:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _Halp_IRQ_Keyboard
_TEXT	SEGMENT
_Halp_IRQ_Keyboard PROC					; COMDAT

; 571  : 	_asm {
; 572  : 		pushad

  00000	60		 pushad

; 573  : 		pushfd

  00001	9c		 pushfd

; 574  : 
; 575  : 		push	ds

  00002	1e		 push	 ds

; 576  : 		push	es

  00003	06		 push	 es

; 577  : 		push	fs

  00004	0f a0		 push	 fs

; 578  : 		push	gs

  00006	0f a8		 push	 gs

; 579  : 
; 580  : 		mov		ax, KERNEL_DS		; change to kernel data segment from user-mode(sometimes) data segment

  00008	66 b8 10 00	 mov	 ax, 16			; 00000010H

; 581  : 		mov		ds, ax

  0000c	66 8e d8	 mov	 ds, ax

; 582  : 		mov		es, ax

  0000f	66 8e c0	 mov	 es, ax

; 583  : 		mov		fs, ax

  00012	66 8e e0	 mov	 fs, ax

; 584  : 		mov		gs, ax

  00015	66 8e e8	 mov	 gs, ax

; 585  : 	} 
; 586  : 	Kbd_IRQ_Handler();

  00018	e8 00 00 00 00	 call	 _Kbd_IRQ_Handler

; 587  : 	WRITE_PORT_UCHAR((PUCHAR)0x20, 0x20);

  0001d	6a 20		 push	 32			; 00000020H
  0001f	6a 20		 push	 32			; 00000020H
  00021	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00026	83 c4 08	 add	 esp, 8

; 588  : 
; 589  : 	_asm {
; 590  : 		pop		gs

  00029	0f a9		 pop	 gs

; 591  : 		pop		fs

  0002b	0f a1		 pop	 fs

; 592  : 		pop		es

  0002d	07		 pop	 es

; 593  : 		pop		ds

  0002e	1f		 pop	 ds

; 594  : 
; 595  : 		popfd

  0002f	9d		 popfd

; 596  : 		popad

  00030	61		 popad

; 597  : 		iretd

  00031	cf		 iretd
_Halp_IRQ_Keyboard ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_ReqFromSlave8259
_TEXT	SEGMENT
_Halp_IRQ_ReqFromSlave8259 PROC				; COMDAT

; 603  : 	static char *msg = "Halp_IRQ_ReqFromSlave8259() \r\n";
; 604  : 	_asm {
; 605  : 		pushad

  00000	60		 pushad

; 606  : 
; 607  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_ReqFromSlave8259@@9@9

; 608  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 609  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 610  : 
; 611  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 612  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 613  : 
; 614  : 		popad

  00013	61		 popad

; 615  : 		iretd

  00014	cf		 iretd
_Halp_IRQ_ReqFromSlave8259 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_COM2
_TEXT	SEGMENT
_Halp_IRQ_COM2 PROC					; COMDAT

; 621  : 	static char *msg = "Halp_IRQ_COM2() \r\n";
; 622  : 	_asm {
; 623  : 		pushad

  00000	60		 pushad

; 624  : 
; 625  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_COM2@@9@9

; 626  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 627  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 628  : 
; 629  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 630  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 631  : 
; 632  : 		popad

  00013	61		 popad

; 633  : 		iretd

  00014	cf		 iretd
_Halp_IRQ_COM2 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_COM1
_TEXT	SEGMENT
_Halp_IRQ_COM1 PROC					; COMDAT

; 639  : 	static char *msg = "Halp_IRQ_COM1() \r\n";
; 640  : 	_asm {
; 641  : 		pushad

  00000	60		 pushad

; 642  : 
; 643  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_COM1@@9@9

; 644  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 645  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 646  : 
; 647  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 648  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 649  : 
; 650  : 		popad

  00013	61		 popad

; 651  : 		iretd

  00014	cf		 iretd
_Halp_IRQ_COM1 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_LPT2
_TEXT	SEGMENT
_Halp_IRQ_LPT2 PROC					; COMDAT

; 657  : 	static char *msg = "Halp_IRQ_LPT2() \r\n";
; 658  : 	_asm {
; 659  : 		pushad

  00000	60		 pushad

; 660  : 
; 661  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_LPT2@@9@9

; 662  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 663  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 664  : 
; 665  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 666  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 667  : 
; 668  : 		popad

  00013	61		 popad

; 669  : 		iretd

  00014	cf		 iretd
_Halp_IRQ_LPT2 ENDP
_TEXT	ENDS
EXTRN	_Fdd_IRQ_Handler:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _Halp_IRQ_FloppyDisk
_TEXT	SEGMENT
_Halp_IRQ_FloppyDisk PROC				; COMDAT

; 675  : 
; 676  : 	_asm {
; 677  : 		pushad

  00000	60		 pushad

; 678  : 		pushfd

  00001	9c		 pushfd

; 679  : 
; 680  : 		push	ds

  00002	1e		 push	 ds

; 681  : 		push	es

  00003	06		 push	 es

; 682  : 		push	fs

  00004	0f a0		 push	 fs

; 683  : 		push	gs

  00006	0f a8		 push	 gs

; 684  : 
; 685  : 		mov		ax, KERNEL_DS		; change to kernel data segment from user-mode(sometimes) data segment

  00008	66 b8 10 00	 mov	 ax, 16			; 00000010H

; 686  : 		mov		ds, ax

  0000c	66 8e d8	 mov	 ds, ax

; 687  : 		mov		es, ax

  0000f	66 8e c0	 mov	 es, ax

; 688  : 		mov		fs, ax

  00012	66 8e e0	 mov	 fs, ax

; 689  : 		mov		gs, ax

  00015	66 8e e8	 mov	 gs, ax

; 690  : 	}
; 691  : 
; 692  : 	Fdd_IRQ_Handler();

  00018	e8 00 00 00 00	 call	 _Fdd_IRQ_Handler

; 693  : 	WRITE_PORT_UCHAR((PUCHAR)0x20, 0x20);

  0001d	6a 20		 push	 32			; 00000020H
  0001f	6a 20		 push	 32			; 00000020H
  00021	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00026	83 c4 08	 add	 esp, 8

; 694  : 
; 695  : 
; 696  : 	_asm {
; 697  : 		pop		gs

  00029	0f a9		 pop	 gs

; 698  : 		pop		fs

  0002b	0f a1		 pop	 fs

; 699  : 		pop		es

  0002d	07		 pop	 es

; 700  : 		pop		ds

  0002e	1f		 pop	 ds

; 701  : 
; 702  : 		popfd

  0002f	9d		 popfd

; 703  : 		popad

  00030	61		 popad

; 704  : 		iretd

  00031	cf		 iretd
_Halp_IRQ_FloppyDisk ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_LPT1
_TEXT	SEGMENT
_Halp_IRQ_LPT1 PROC					; COMDAT

; 710  : 	static char *msg = "Halp_IRQ_LPT1() \r\n";
; 711  : 	_asm {
; 712  : 		pushad

  00000	60		 pushad

; 713  : 
; 714  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_LPT1@@9@9

; 715  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 716  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 717  : 
; 718  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 719  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 720  : 
; 721  : 		popad

  00013	61		 popad

; 722  : 		iretd

  00014	cf		 iretd
_Halp_IRQ_LPT1 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_CMOSClock
_TEXT	SEGMENT
_Halp_IRQ_CMOSClock PROC				; COMDAT

; 728  : 	static char *msg = "Halp_IRQ_CMOSClock() \r\n";
; 729  : 	_asm {
; 730  : 		pushad

  00000	60		 pushad

; 731  : 
; 732  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_CMOSClock@@9@9

; 733  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 734  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 735  : 
; 736  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 737  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 738  : 		out		0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 739  : 
; 740  : 		popad

  00015	61		 popad

; 741  : 		iretd

  00016	cf		 iretd
_Halp_IRQ_CMOSClock ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_VGA
_TEXT	SEGMENT
_Halp_IRQ_VGA PROC					; COMDAT

; 747  : 	static char *msg = "Halp_IRQ_VGA() \r\n";
; 748  : 	_asm {
; 749  : 		pushad

  00000	60		 pushad

; 750  : 
; 751  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_VGA@@9@9

; 752  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 753  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 754  : 
; 755  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 756  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 757  : 		out		0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 758  : 
; 759  : 		popad

  00015	61		 popad

; 760  : 		iretd

  00016	cf		 iretd
_Halp_IRQ_VGA ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_Mouse
_TEXT	SEGMENT
_Halp_IRQ_Mouse PROC					; COMDAT

; 766  : 	static char *msg = "Halp_IRQ_Mouse() \r\n";
; 767  : 	_asm {
; 768  : 		pushad

  00000	60		 pushad

; 769  : 
; 770  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_Mouse@@9@9

; 771  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 772  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 773  : 
; 774  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 775  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 776  : 		out		0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 777  : 
; 778  : 		popad

  00015	61		 popad

; 779  : 		iretd

  00016	cf		 iretd
_Halp_IRQ_Mouse ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_MathCoprocessor
_TEXT	SEGMENT
_Halp_IRQ_MathCoprocessor PROC				; COMDAT

; 785  : 	static char *msg = "Halp_IRQ_MathCoprocessor() \r\n";
; 786  : 	_asm {
; 787  : 		pushad

  00000	60		 pushad

; 788  : 
; 789  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_MathCoprocessor@@9@9

; 790  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 791  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 792  : 
; 793  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 794  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 795  : 		out		0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 796  : 
; 797  : 		popad

  00015	61		 popad

; 798  : 		iretd

  00016	cf		 iretd
_Halp_IRQ_MathCoprocessor ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_HardDrive
_TEXT	SEGMENT
_Halp_IRQ_HardDrive PROC				; COMDAT

; 804  : 	static char *msg = "Halp_IRQ_HardDrive() \r\n";
; 805  : 	_asm {
; 806  : 		pushad

  00000	60		 pushad

; 807  : 
; 808  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_HardDrive@@9@9

; 809  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 810  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 811  : 
; 812  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 813  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 814  : 		out		0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 815  : 
; 816  : 		popad

  00015	61		 popad

; 817  : 		iretd

  00016	cf		 iretd
_Halp_IRQ_HardDrive ENDP
_TEXT	ENDS
EXTRN	_HalpEnableInterrupt:PROC
_BSS	SEGMENT
_m_IdtrDesc DF	01H DUP (?)
	ALIGN	8

_m_IdtGate DQ	040H DUP (?)
; Function compile flags: /Odtp /ZI
_BSS	ENDS
;	COMDAT _HalpStartIntService
_TEXT	SEGMENT
_i$ = -4						; size = 4
_HalpStartIntService PROC				; COMDAT

; 886  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 887  : 	int i;
; 888  : 
; 889  : 	//메모리 초기화
; 890  : 	memset(m_IdtGate, 0, MAX_IDT*sizeof(IDT_GATE));

  00009	68 00 02 00 00	 push	 512			; 00000200H
  0000e	6a 00		 push	 0
  00010	68 00 00 00 00	 push	 OFFSET _m_IdtGate
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 891  : 
; 892  : 	//IDT Table 만들기
; 893  : 	for(i=0; i<MAX_IDT; i++) 

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00024	eb 09		 jmp	 SHORT $LN6@HalpStartI
$LN5@HalpStartI:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN6@HalpStartI:
  0002f	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  00033	0f 8d 01 01 00
	00		 jge	 $LN4@HalpStartI

; 894  : 	{
; 895  : 		if(m_IntHandlers[i].offset == 0)

  00039	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003c	6b c0 07	 imul	 eax, 7
  0003f	83 b8 01 00 00
	00 00		 cmp	 DWORD PTR _m_IntHandlers[eax+1], 0
  00046	75 05		 jne	 SHORT $LN3@HalpStartI

; 896  : 			break;

  00048	e9 ed 00 00 00	 jmp	 $LN4@HalpStartI
$LN3@HalpStartI:

; 897  : 		
; 898  : 		if((m_IntHandlers[i].type & IDTC_TASKGATE) == IDTC_TASKGATE)

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00050	6b c0 07	 imul	 eax, 7
  00053	0f b7 88 05 00
	00 00		 movzx	 ecx, WORD PTR _m_IntHandlers[eax+5]
  0005a	81 e1 00 05 00
	00		 and	 ecx, 1280		; 00000500H
  00060	81 f9 00 05 00
	00		 cmp	 ecx, 1280		; 00000500H
  00066	75 49		 jne	 SHORT $LN2@HalpStartI

; 899  : 		{
; 900  : 			m_IdtGate[m_IntHandlers[i].number].selector		= (WORD)(m_IntHandlers[i].offset);

  00068	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0006b	6b c0 07	 imul	 eax, 7
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00071	6b c9 07	 imul	 ecx, 7
  00074	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _m_IntHandlers[ecx]
  0007b	66 8b 80 01 00
	00 00		 mov	 ax, WORD PTR _m_IntHandlers[eax+1]
  00082	66 89 04 d5 02
	00 00 00	 mov	 WORD PTR _m_IdtGate[edx*8+2], ax

; 901  : 			m_IdtGate[m_IntHandlers[i].number].type			= m_IntHandlers[i].type;

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0008d	6b c0 07	 imul	 eax, 7
  00090	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00093	6b c9 07	 imul	 ecx, 7
  00096	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _m_IntHandlers[ecx]
  0009d	66 8b 80 05 00
	00 00		 mov	 ax, WORD PTR _m_IntHandlers[eax+5]
  000a4	66 89 04 d5 04
	00 00 00	 mov	 WORD PTR _m_IdtGate[edx*8+4], ax

; 902  : 		}
; 903  : 		else

  000ac	e9 84 00 00 00	 jmp	 $LN1@HalpStartI
$LN2@HalpStartI:

; 904  : 		{
; 905  : 			m_IdtGate[m_IntHandlers[i].number].selector		= KERNEL_CS;

  000b1	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000b4	6b c0 07	 imul	 eax, 7
  000b7	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _m_IntHandlers[eax]
  000be	66 c7 04 cd 02
	00 00 00 08 00	 mov	 WORD PTR _m_IdtGate[ecx*8+2], 8

; 906  : 			m_IdtGate[m_IntHandlers[i].number].type			= m_IntHandlers[i].type;

  000c8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000cb	6b c0 07	 imul	 eax, 7
  000ce	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000d1	6b c9 07	 imul	 ecx, 7
  000d4	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _m_IntHandlers[ecx]
  000db	66 8b 80 05 00
	00 00		 mov	 ax, WORD PTR _m_IntHandlers[eax+5]
  000e2	66 89 04 d5 04
	00 00 00	 mov	 WORD PTR _m_IdtGate[edx*8+4], ax

; 907  : 			m_IdtGate[m_IntHandlers[i].number].offset_high	= (WORD)(m_IntHandlers[i].offset >> 16);

  000ea	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ed	6b c0 07	 imul	 eax, 7
  000f0	8b 88 01 00 00
	00		 mov	 ecx, DWORD PTR _m_IntHandlers[eax+1]
  000f6	c1 f9 10	 sar	 ecx, 16			; 00000010H
  000f9	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000fc	6b d2 07	 imul	 edx, 7
  000ff	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _m_IntHandlers[edx]
  00106	66 89 0c c5 06
	00 00 00	 mov	 WORD PTR _m_IdtGate[eax*8+6], cx

; 908  : 			m_IdtGate[m_IntHandlers[i].number].offset_low	= (WORD)(m_IntHandlers[i].offset & 0xffff);

  0010e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00111	6b c0 07	 imul	 eax, 7
  00114	8b 88 01 00 00
	00		 mov	 ecx, DWORD PTR _m_IntHandlers[eax+1]
  0011a	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00120	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00123	6b d2 07	 imul	 edx, 7
  00126	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _m_IntHandlers[edx]
  0012d	66 89 0c c5 00
	00 00 00	 mov	 WORD PTR _m_IdtGate[eax*8], cx
$LN1@HalpStartI:

; 909  : 		}
; 910  : 	}

  00135	e9 ec fe ff ff	 jmp	 $LN5@HalpStartI
$LN4@HalpStartI:

; 911  : 
; 912  : 	//IDTR 설정
; 913  : 	//IDT크기와 시작 Physical Address 설정 
; 914  : 	m_IdtrDesc.address	= (int)&m_IdtGate;

  0013a	c7 05 02 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_IdtrDesc+2, OFFSET _m_IdtGate

; 915  : 	m_IdtrDesc.size		= (WORD)(MAX_IDT*sizeof(IDT_GATE));

  00144	66 c7 05 00 00
	00 00 00 02	 mov	 WORD PTR _m_IdtrDesc, 512 ; 00000200H

; 916  : 	//IDTR 포인터를 HalpEnableInterrupt로 전달 -> CPU가 IDT 테이블을 인식
; 917  : 	HalpEnableInterrupt((PIDTR_DESC)&m_IdtrDesc);

  0014d	68 00 00 00 00	 push	 OFFSET _m_IdtrDesc
  00152	e8 00 00 00 00	 call	 _HalpEnableInterrupt
  00157	83 c4 04	 add	 esp, 4

; 918  : 
; 919  : 	return TRUE;

  0015a	b8 01 00 00 00	 mov	 eax, 1

; 920  : }

  0015f	5f		 pop	 edi
  00160	5e		 pop	 esi
  00161	5b		 pop	 ebx
  00162	8b e5		 mov	 esp, ebp
  00164	5d		 pop	 ebp
  00165	c3		 ret	 0
_HalpStartIntService ENDP
_TEXT	ENDS
END
