; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	c:\Users\상우\Documents\카카오톡 받은 파일\MylysOS\string.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	_memset
; Function compile flags: /Odtp /ZI
; File c:\users\상우\documents\카카오톡 받은 파일\mylysos\string.c
;	COMDAT _memset
_TEXT	SEGMENT
_i$ = -4						; size = 4
_pSource$ = 8						; size = 4
_ch$ = 12						; size = 4
_size$ = 16						; size = 4
_memset	PROC						; COMDAT

; 8    : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 9    : 	size_t i;
; 10   : 
; 11   : 	for( i=0; i<size; i++)

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN3@memset
$LN2@memset:
  00012	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN3@memset:
  0001b	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0001e	3b 45 10	 cmp	 eax, DWORD PTR _size$[ebp]
  00021	73 0d		 jae	 SHORT $LN1@memset

; 12   : 		*(((char *)pSource)+i ) = (char)ch;

  00023	8b 45 08	 mov	 eax, DWORD PTR _pSource$[ebp]
  00026	03 45 fc	 add	 eax, DWORD PTR _i$[ebp]
  00029	8a 4d 0c	 mov	 cl, BYTE PTR _ch$[ebp]
  0002c	88 08		 mov	 BYTE PTR [eax], cl
  0002e	eb e2		 jmp	 SHORT $LN2@memset
$LN1@memset:

; 13   : 
; 14   : 	return pSource;

  00030	8b 45 08	 mov	 eax, DWORD PTR _pSource$[ebp]

; 15   : }

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_memset	ENDP
_TEXT	ENDS
PUBLIC	_strupr
; Function compile flags: /Odtp /ZI
;	COMDAT _strupr
_TEXT	SEGMENT
_cp$ = -4						; size = 4
_str$ = 8						; size = 4
_strupr	PROC						; COMDAT

; 19   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 20   : 	char *cp = str;

  00009	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax
$LN3@strupr:

; 21   : 
; 22   : 	while(*cp != '\0') {

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _cp$[ebp]
  00012	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00015	85 c9		 test	 ecx, ecx
  00017	74 2f		 je	 SHORT $LN2@strupr

; 23   : 		if(*cp >= 'a' && *cp <= 'z')

  00019	8b 45 fc	 mov	 eax, DWORD PTR _cp$[ebp]
  0001c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0001f	83 f9 61	 cmp	 ecx, 97			; 00000061H
  00022	7c 19		 jl	 SHORT $LN1@strupr
  00024	8b 45 fc	 mov	 eax, DWORD PTR _cp$[ebp]
  00027	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0002a	83 f9 7a	 cmp	 ecx, 122		; 0000007aH
  0002d	7f 0e		 jg	 SHORT $LN1@strupr

; 24   : 			*cp = *cp-'a' + 'A';

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _cp$[ebp]
  00032	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00035	83 e9 20	 sub	 ecx, 32			; 00000020H
  00038	8b 55 fc	 mov	 edx, DWORD PTR _cp$[ebp]
  0003b	88 0a		 mov	 BYTE PTR [edx], cl
$LN1@strupr:

; 25   : 		cp++;

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _cp$[ebp]
  00040	83 c0 01	 add	 eax, 1
  00043	89 45 fc	 mov	 DWORD PTR _cp$[ebp], eax

; 26   : 	}

  00046	eb c7		 jmp	 SHORT $LN3@strupr
$LN2@strupr:

; 27   : 
; 28   : 	return str;

  00048	8b 45 08	 mov	 eax, DWORD PTR _str$[ebp]

; 29   : }

  0004b	5f		 pop	 edi
  0004c	5e		 pop	 esi
  0004d	5b		 pop	 ebx
  0004e	8b e5		 mov	 esp, ebp
  00050	5d		 pop	 ebp
  00051	c3		 ret	 0
_strupr	ENDP
_TEXT	ENDS
PUBLIC	_strcmp
; Function compile flags: /Odtp /ZI
;	COMDAT _strcmp
_TEXT	SEGMENT
___res$ = -1						; size = 1
_cs$ = 8						; size = 4
_ct$ = 12						; size = 4
_strcmp	PROC						; COMDAT

; 33   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN4@strcmp:

; 34   : 	char __res;
; 35   : 
; 36   : 	while(1) {

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	85 c0		 test	 eax, eax
  00010	74 39		 je	 SHORT $LN3@strcmp

; 37   : 		if((__res = *cs - *ct++ ) != 0 || !*cs++)

  00012	8b 45 08	 mov	 eax, DWORD PTR _cs$[ebp]
  00015	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00018	8b 55 0c	 mov	 edx, DWORD PTR _ct$[ebp]
  0001b	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0001e	2b c8		 sub	 ecx, eax
  00020	88 4d ff	 mov	 BYTE PTR ___res$[ebp], cl
  00023	0f be 4d ff	 movsx	 ecx, BYTE PTR ___res$[ebp]
  00027	8b 55 0c	 mov	 edx, DWORD PTR _ct$[ebp]
  0002a	83 c2 01	 add	 edx, 1
  0002d	89 55 0c	 mov	 DWORD PTR _ct$[ebp], edx
  00030	85 c9		 test	 ecx, ecx
  00032	75 13		 jne	 SHORT $LN1@strcmp
  00034	8b 45 08	 mov	 eax, DWORD PTR _cs$[ebp]
  00037	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0003a	8b 55 08	 mov	 edx, DWORD PTR _cs$[ebp]
  0003d	83 c2 01	 add	 edx, 1
  00040	89 55 08	 mov	 DWORD PTR _cs$[ebp], edx
  00043	85 c9		 test	 ecx, ecx
  00045	75 02		 jne	 SHORT $LN2@strcmp
$LN1@strcmp:

; 38   : 			break;

  00047	eb 02		 jmp	 SHORT $LN3@strcmp
$LN2@strcmp:

; 39   : 	}

  00049	eb be		 jmp	 SHORT $LN4@strcmp
$LN3@strcmp:

; 40   : 
; 41   : 	return __res;

  0004b	0f be 45 ff	 movsx	 eax, BYTE PTR ___res$[ebp]

; 42   : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_strcmp	ENDP
_TEXT	ENDS
PUBLIC	_strlen
; Function compile flags: /Odtp /ZI
;	COMDAT _strlen
_TEXT	SEGMENT
_sc$ = -4						; size = 4
_s$ = 8							; size = 4
_strlen	PROC						; COMDAT

; 46   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 47   : 	const char *sc;
; 48   : 
; 49   : 	for(sc = s; *sc != '\0'; ++sc);

  00009	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _sc$[ebp], eax
  0000f	eb 09		 jmp	 SHORT $LN3@strlen
$LN2@strlen:
  00011	8b 45 fc	 mov	 eax, DWORD PTR _sc$[ebp]
  00014	83 c0 01	 add	 eax, 1
  00017	89 45 fc	 mov	 DWORD PTR _sc$[ebp], eax
$LN3@strlen:
  0001a	8b 45 fc	 mov	 eax, DWORD PTR _sc$[ebp]
  0001d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00020	85 c9		 test	 ecx, ecx
  00022	74 02		 je	 SHORT $LN1@strlen
  00024	eb eb		 jmp	 SHORT $LN2@strlen
$LN1@strlen:

; 50   : 
; 51   : 	return sc - s;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _sc$[ebp]
  00029	2b 45 08	 sub	 eax, DWORD PTR _s$[ebp]

; 52   : }

  0002c	5f		 pop	 edi
  0002d	5e		 pop	 esi
  0002e	5b		 pop	 ebx
  0002f	8b e5		 mov	 esp, ebp
  00031	5d		 pop	 ebp
  00032	c3		 ret	 0
_strlen	ENDP
_TEXT	ENDS
PUBLIC	_memcpy
; Function compile flags: /Odtp /ZI
;	COMDAT _memcpy
_TEXT	SEGMENT
_s$ = -8						; size = 4
_tmp$ = -4						; size = 4
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_count$ = 16						; size = 4
_memcpy	PROC						; COMDAT

; 56   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 57   : 	char *tmp = (char *) dest, *s = (char *) src;

  00009	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _tmp$[ebp], eax
  0000f	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00012	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax
$LN2@memcpy:

; 58   : 
; 59   : 	while (count--)

  00015	8b 45 10	 mov	 eax, DWORD PTR _count$[ebp]
  00018	8b 4d 10	 mov	 ecx, DWORD PTR _count$[ebp]
  0001b	83 e9 01	 sub	 ecx, 1
  0001e	89 4d 10	 mov	 DWORD PTR _count$[ebp], ecx
  00021	85 c0		 test	 eax, eax
  00023	74 1e		 je	 SHORT $LN1@memcpy

; 60   : 		*tmp++ = *s++;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _tmp$[ebp]
  00028	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  0002b	8a 11		 mov	 dl, BYTE PTR [ecx]
  0002d	88 10		 mov	 BYTE PTR [eax], dl
  0002f	8b 45 fc	 mov	 eax, DWORD PTR _tmp$[ebp]
  00032	83 c0 01	 add	 eax, 1
  00035	89 45 fc	 mov	 DWORD PTR _tmp$[ebp], eax
  00038	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  0003b	83 c1 01	 add	 ecx, 1
  0003e	89 4d f8	 mov	 DWORD PTR _s$[ebp], ecx
  00041	eb d2		 jmp	 SHORT $LN2@memcpy
$LN1@memcpy:

; 61   : 
; 62   : 	return dest;

  00043	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]

; 63   : }

  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
_memcpy	ENDP
_TEXT	ENDS
PUBLIC	_strrchr
; Function compile flags: /Odtp /ZI
;	COMDAT _strrchr
_TEXT	SEGMENT
_p$ = -4						; size = 4
_s$ = 8							; size = 4
_c$ = 12						; size = 4
_strrchr PROC						; COMDAT

; 67   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 68   : 	const char *p = s + strlen(s);

  00009	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _strlen
  00012	83 c4 04	 add	 esp, 4
  00015	03 45 08	 add	 eax, DWORD PTR _s$[ebp]
  00018	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax
$LN4@strrchr:

; 69   : 	do {
; 70   : 		if (*p == (char)c )

  0001b	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0001e	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00021	0f be 55 0c	 movsx	 edx, BYTE PTR _c$[ebp]
  00025	3b ca		 cmp	 ecx, edx
  00027	75 05		 jne	 SHORT $LN3@strrchr

; 71   : 			return (char *)p;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0002c	eb 13		 jmp	 SHORT $LN5@strrchr
$LN3@strrchr:

; 72   : 	} while(--p >= s);

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  00031	83 e8 01	 sub	 eax, 1
  00034	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax
  00037	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0003a	3b 4d 08	 cmp	 ecx, DWORD PTR _s$[ebp]
  0003d	73 dc		 jae	 SHORT $LN4@strrchr

; 73   : 	return NULL;

  0003f	33 c0		 xor	 eax, eax
$LN5@strrchr:

; 74   : }

  00041	5f		 pop	 edi
  00042	5e		 pop	 esi
  00043	5b		 pop	 ebx
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
_strrchr ENDP
_TEXT	ENDS
PUBLIC	_strcpy
; Function compile flags: /Odtp /ZI
;	COMDAT _strcpy
_TEXT	SEGMENT
_tmp$ = -4						; size = 4
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_strcpy	PROC						; COMDAT

; 78   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 79   : 	char *tmp = dest;

  00009	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _tmp$[ebp], eax
$LN2@strcpy:

; 80   : 
; 81   : 	while ((*dest++ = *src++) != '\0');

  0000f	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00012	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  00015	8a 11		 mov	 dl, BYTE PTR [ecx]
  00017	88 10		 mov	 BYTE PTR [eax], dl
  00019	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0001c	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0001f	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  00022	83 c2 01	 add	 edx, 1
  00025	89 55 08	 mov	 DWORD PTR _dest$[ebp], edx
  00028	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  0002b	83 c0 01	 add	 eax, 1
  0002e	89 45 0c	 mov	 DWORD PTR _src$[ebp], eax
  00031	85 c9		 test	 ecx, ecx
  00033	74 02		 je	 SHORT $LN1@strcpy
  00035	eb d8		 jmp	 SHORT $LN2@strcpy
$LN1@strcpy:

; 82   : 
; 83   : 	return tmp;

  00037	8b 45 fc	 mov	 eax, DWORD PTR _tmp$[ebp]

; 84   : }

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
_strcpy	ENDP
_TEXT	ENDS
PUBLIC	_strcat
; Function compile flags: /Odtp /ZI
;	COMDAT _strcat
_TEXT	SEGMENT
_tmp$ = -4						; size = 4
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_strcat	PROC						; COMDAT

; 88   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 89   : 	char *tmp = dest;

  00009	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _tmp$[ebp], eax
$LN4@strcat:

; 90   : 
; 91   : 	while(*dest)

  0000f	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00012	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00015	85 c9		 test	 ecx, ecx
  00017	74 0b		 je	 SHORT $LN2@strcat

; 92   : 		dest++;

  00019	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  0001c	83 c0 01	 add	 eax, 1
  0001f	89 45 08	 mov	 DWORD PTR _dest$[ebp], eax
  00022	eb eb		 jmp	 SHORT $LN4@strcat
$LN2@strcat:

; 93   : 	while ((*dest++ = *src++) != '\0');

  00024	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00027	8b 4d 0c	 mov	 ecx, DWORD PTR _src$[ebp]
  0002a	8a 11		 mov	 dl, BYTE PTR [ecx]
  0002c	88 10		 mov	 BYTE PTR [eax], dl
  0002e	8b 45 08	 mov	 eax, DWORD PTR _dest$[ebp]
  00031	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00034	8b 55 08	 mov	 edx, DWORD PTR _dest$[ebp]
  00037	83 c2 01	 add	 edx, 1
  0003a	89 55 08	 mov	 DWORD PTR _dest$[ebp], edx
  0003d	8b 45 0c	 mov	 eax, DWORD PTR _src$[ebp]
  00040	83 c0 01	 add	 eax, 1
  00043	89 45 0c	 mov	 DWORD PTR _src$[ebp], eax
  00046	85 c9		 test	 ecx, ecx
  00048	74 02		 je	 SHORT $LN1@strcat
  0004a	eb d8		 jmp	 SHORT $LN2@strcat
$LN1@strcat:

; 94   : 
; 95   : 	return tmp;

  0004c	8b 45 fc	 mov	 eax, DWORD PTR _tmp$[ebp]

; 96   : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_strcat	ENDP
_TEXT	ENDS
END
