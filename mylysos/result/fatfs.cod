; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	c:\Users\상우\Documents\카카오톡 받은 파일\MylysOS\fatfs.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CI@EAEBLLGL@FspLoadDirEntry?$CI?$CJ?5returned?5an?5er@ ; `string'
PUBLIC	??_C@_0CD@KKIBFCFD@FspLoadFAT?$CI?$CJ?5returned?5an?5error?4?5@ ; `string'
PUBLIC	_FsInitializeModule
EXTRN	_CrtPrintf:PROC
;	COMDAT ??_C@_0CI@EAEBLLGL@FspLoadDirEntry?$CI?$CJ?5returned?5an?5er@
; File c:\users\상우\documents\카카오톡 받은 파일\mylysos\fatfs.c
CONST	SEGMENT
??_C@_0CI@EAEBLLGL@FspLoadDirEntry?$CI?$CJ?5returned?5an?5er@ DB 'FspLoad'
	DB	'DirEntry() returned an error. ', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@KKIBFCFD@FspLoadFAT?$CI?$CJ?5returned?5an?5error?4?5@
CONST	SEGMENT
??_C@_0CD@KKIBFCFD@FspLoadFAT?$CI?$CJ?5returned?5an?5error?4?5@ DB 'FspLo'
	DB	'adFAT() returned an error. ', 0dH, 0aH, 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _FsInitializeModule
_TEXT	SEGMENT
_FsInitializeModule PROC				; COMDAT

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 76   : 
; 77   : 	//디스크의 FAT테이블을 읽어오는 함수
; 78   : 	if(!FspLoadFAT()) { 

  00009	e8 00 00 00 00	 call	 _FspLoadFAT
  0000e	85 c0		 test	 eax, eax
  00010	75 11		 jne	 SHORT $LN2@FsInitiali

; 79   : 		DbgPrint("FspLoadFAT() returned an error. \r\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@KKIBFCFD@FspLoadFAT?$CI?$CJ?5returned?5an?5error?4?5@
  00017	e8 00 00 00 00	 call	 _CrtPrintf
  0001c	83 c4 04	 add	 esp, 4

; 80   : 		return FALSE;

  0001f	33 c0		 xor	 eax, eax
  00021	eb 1f		 jmp	 SHORT $LN3@FsInitiali
$LN2@FsInitiali:

; 81   : 	}
; 82   : 
; 83   : 	//Root Directory Entry를 읽어와서 저장하는 함수
; 84   : 	if(!FspLoadDirEntry()) {

  00023	e8 00 00 00 00	 call	 _FspLoadDirEntry
  00028	85 c0		 test	 eax, eax
  0002a	75 11		 jne	 SHORT $LN1@FsInitiali

; 85   : 		DbgPrint("FspLoadDirEntry() returned an error. \r\n");

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@EAEBLLGL@FspLoadDirEntry?$CI?$CJ?5returned?5an?5er@
  00031	e8 00 00 00 00	 call	 _CrtPrintf
  00036	83 c4 04	 add	 esp, 4

; 86   : 		return FALSE;

  00039	33 c0		 xor	 eax, eax
  0003b	eb 05		 jmp	 SHORT $LN3@FsInitiali
$LN1@FsInitiali:

; 87   : 	}
; 88   : 
; 89   : 	return TRUE;

  0003d	b8 01 00 00 00	 mov	 eax, 1
$LN3@FsInitiali:

; 90   : }

  00042	5f		 pop	 edi
  00043	5e		 pop	 esi
  00044	5b		 pop	 ebx
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c3		 ret	 0
_FsInitializeModule ENDP
_TEXT	ENDS
PUBLIC	_FsGetFileList
_BSS	SEGMENT
_m_DirEntry DB	01c00H DUP (?)
; Function compile flags: /Odtp /ZI
_BSS	ENDS
;	COMDAT _FsGetFileList
_TEXT	SEGMENT
_k$ = -36						; size = 4
_j$ = -32						; size = 4
_i$ = -28						; size = 4
_FileInfo$ = -24					; size = 24
_CallBack$ = 8						; size = 4
_Context$ = 12						; size = 4
_FsGetFileList PROC					; COMDAT

; 95   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 64	 sub	 esp, 100		; 00000064H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 96   : 	
; 97   : 	FILE_INFO FileInfo;
; 98   : 	int i, j, k;
; 99   : 
; 100  : 	//Root Directory Entry 를 for문으로 탐색
; 101  : 	for(i=0; i<NUMBER_OF_DIR_ENTRIES; i++) {

  00009	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN10@FsGetFileL
$LN9@FsGetFileL:
  00012	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 e4	 mov	 DWORD PTR _i$[ebp], eax
$LN10@FsGetFileL:
  0001b	81 7d e4 e0 00
	00 00		 cmp	 DWORD PTR _i$[ebp], 224	; 000000e0H
  00022	0f 8d 41 01 00
	00		 jge	 $LN11@FsGetFileL

; 102  : 		if(m_DirEntry[i].filename[0] == 0xe5 || m_DirEntry[i].filename[0] == NULL)

  00028	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  0002b	c1 e0 05	 shl	 eax, 5
  0002e	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _m_DirEntry[eax]
  00035	81 f9 e5 00 00
	00		 cmp	 ecx, 229		; 000000e5H
  0003b	74 11		 je	 SHORT $LN6@FsGetFileL
  0003d	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  00040	c1 e0 05	 shl	 eax, 5
  00043	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _m_DirEntry[eax]
  0004a	85 c9		 test	 ecx, ecx
  0004c	75 02		 jne	 SHORT $LN7@FsGetFileL
$LN6@FsGetFileL:

; 103  : 			continue;

  0004e	eb c2		 jmp	 SHORT $LN9@FsGetFileL
$LN7@FsGetFileL:

; 104  : 
; 105  : 		j=0;

  00050	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
$LN5@FsGetFileL:

; 106  : 		while(m_DirEntry[i].filename[j] != ' ' && j<8) {

  00057	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  0005a	c1 e0 05	 shl	 eax, 5
  0005d	8b 4d e0	 mov	 ecx, DWORD PTR _j$[ebp]
  00060	0f b6 94 08 00
	00 00 00	 movzx	 edx, BYTE PTR _m_DirEntry[eax+ecx]
  00068	83 fa 20	 cmp	 edx, 32			; 00000020H
  0006b	74 28		 je	 SHORT $LN4@FsGetFileL
  0006d	83 7d e0 08	 cmp	 DWORD PTR _j$[ebp], 8
  00071	7d 22		 jge	 SHORT $LN4@FsGetFileL

; 107  : 			FileInfo.filename[j] = m_DirEntry[i].filename[j];

  00073	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  00076	c1 e0 05	 shl	 eax, 5
  00079	8b 4d e0	 mov	 ecx, DWORD PTR _j$[ebp]
  0007c	8b 55 e0	 mov	 edx, DWORD PTR _j$[ebp]
  0007f	8a 84 10 00 00
	00 00		 mov	 al, BYTE PTR _m_DirEntry[eax+edx]
  00086	88 44 0d e8	 mov	 BYTE PTR _FileInfo$[ebp+ecx], al

; 108  : 			j++;

  0008a	8b 45 e0	 mov	 eax, DWORD PTR _j$[ebp]
  0008d	83 c0 01	 add	 eax, 1
  00090	89 45 e0	 mov	 DWORD PTR _j$[ebp], eax

; 109  : 		}

  00093	eb c2		 jmp	 SHORT $LN5@FsGetFileL
$LN4@FsGetFileL:

; 110  : 		FileInfo.filename[j++] = '.';

  00095	8b 45 e0	 mov	 eax, DWORD PTR _j$[ebp]
  00098	c6 44 05 e8 2e	 mov	 BYTE PTR _FileInfo$[ebp+eax], 46 ; 0000002eH
  0009d	8b 4d e0	 mov	 ecx, DWORD PTR _j$[ebp]
  000a0	83 c1 01	 add	 ecx, 1
  000a3	89 4d e0	 mov	 DWORD PTR _j$[ebp], ecx

; 111  : 
; 112  : 		k=j;

  000a6	8b 45 e0	 mov	 eax, DWORD PTR _j$[ebp]
  000a9	89 45 dc	 mov	 DWORD PTR _k$[ebp], eax

; 113  : 		j=0;

  000ac	c7 45 e0 00 00
	00 00		 mov	 DWORD PTR _j$[ebp], 0
$LN3@FsGetFileL:

; 114  : 		while(m_DirEntry[i].extension[j] != ' ' && j<3) {

  000b3	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  000b6	c1 e0 05	 shl	 eax, 5
  000b9	8b 4d e0	 mov	 ecx, DWORD PTR _j$[ebp]
  000bc	0f b6 94 08 08
	00 00 00	 movzx	 edx, BYTE PTR _m_DirEntry[eax+ecx+8]
  000c4	83 fa 20	 cmp	 edx, 32			; 00000020H
  000c7	74 2b		 je	 SHORT $LN2@FsGetFileL
  000c9	83 7d e0 03	 cmp	 DWORD PTR _j$[ebp], 3
  000cd	7d 25		 jge	 SHORT $LN2@FsGetFileL

; 115  : 			FileInfo.filename[j+k] = m_DirEntry[i].extension[j];

  000cf	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  000d2	c1 e0 05	 shl	 eax, 5
  000d5	8b 4d e0	 mov	 ecx, DWORD PTR _j$[ebp]
  000d8	03 4d dc	 add	 ecx, DWORD PTR _k$[ebp]
  000db	8b 55 e0	 mov	 edx, DWORD PTR _j$[ebp]
  000de	8a 84 10 08 00
	00 00		 mov	 al, BYTE PTR _m_DirEntry[eax+edx+8]
  000e5	88 44 0d e8	 mov	 BYTE PTR _FileInfo$[ebp+ecx], al

; 116  : 			j++;

  000e9	8b 45 e0	 mov	 eax, DWORD PTR _j$[ebp]
  000ec	83 c0 01	 add	 eax, 1
  000ef	89 45 e0	 mov	 DWORD PTR _j$[ebp], eax

; 117  : 		}

  000f2	eb bf		 jmp	 SHORT $LN3@FsGetFileL
$LN2@FsGetFileL:

; 118  : 		FileInfo.filename[j+k] = '\0';

  000f4	8b 45 e0	 mov	 eax, DWORD PTR _j$[ebp]
  000f7	03 45 dc	 add	 eax, DWORD PTR _k$[ebp]
  000fa	c6 44 05 e8 00	 mov	 BYTE PTR _FileInfo$[ebp+eax], 0

; 119  : 		
; 120  : 		//fileinfo 구조체에 복사해 넣은 후, 우리가 찾고자하는 파일이 맞는지를 확인
; 121  : 		FileInfo.attribute = m_DirEntry[i].attribute;

  000ff	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  00102	c1 e0 05	 shl	 eax, 5
  00105	8a 88 0b 00 00
	00		 mov	 cl, BYTE PTR _m_DirEntry[eax+11]
  0010b	88 4d f5	 mov	 BYTE PTR _FileInfo$[ebp+13], cl

; 122  : 		FileInfo.time = m_DirEntry[i].time;

  0010e	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  00111	c1 e0 05	 shl	 eax, 5
  00114	66 8b 88 16 00
	00 00		 mov	 cx, WORD PTR _m_DirEntry[eax+22]
  0011b	66 89 4d f6	 mov	 WORD PTR _FileInfo$[ebp+14], cx

; 123  : 		FileInfo.date = m_DirEntry[i].date;

  0011f	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  00122	c1 e0 05	 shl	 eax, 5
  00125	66 8b 88 18 00
	00 00		 mov	 cx, WORD PTR _m_DirEntry[eax+24]
  0012c	66 89 4d f8	 mov	 WORD PTR _FileInfo$[ebp+16], cx

; 124  : 		FileInfo.filesize = m_DirEntry[i].filesize;

  00130	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  00133	c1 e0 05	 shl	 eax, 5
  00136	8b 88 1c 00 00
	00		 mov	 ecx, DWORD PTR _m_DirEntry[eax+28]
  0013c	89 4d fa	 mov	 DWORD PTR _FileInfo$[ebp+18], ecx

; 125  : 		FileInfo.start_cluster = m_DirEntry[i].cluster;

  0013f	8b 45 e4	 mov	 eax, DWORD PTR _i$[ebp]
  00142	c1 e0 05	 shl	 eax, 5
  00145	66 8b 88 1a 00
	00 00		 mov	 cx, WORD PTR _m_DirEntry[eax+26]
  0014c	66 89 4d fe	 mov	 WORD PTR _FileInfo$[ebp+22], cx

; 126  : 
; 127  : 		//Callback 함수에 Fileinfo 구조체의 첫 번째 인자를 넣어서 파일이 맞는지 확인
; 128  : 		if(!CallBack(&FileInfo, Context))

  00150	8b 45 0c	 mov	 eax, DWORD PTR _Context$[ebp]
  00153	50		 push	 eax
  00154	8d 4d e8	 lea	 ecx, DWORD PTR _FileInfo$[ebp]
  00157	51		 push	 ecx
  00158	ff 55 08	 call	 DWORD PTR _CallBack$[ebp]
  0015b	83 c4 08	 add	 esp, 8
  0015e	85 c0		 test	 eax, eax
  00160	75 02		 jne	 SHORT $LN1@FsGetFileL

; 129  : 			break;

  00162	eb 05		 jmp	 SHORT $LN11@FsGetFileL
$LN1@FsGetFileL:

; 130  : 	}

  00164	e9 a9 fe ff ff	 jmp	 $LN9@FsGetFileL
$LN11@FsGetFileL:

; 131  : }

  00169	5f		 pop	 edi
  0016a	5e		 pop	 esi
  0016b	5b		 pop	 ebx
  0016c	8b e5		 mov	 esp, ebp
  0016e	5d		 pop	 ebp
  0016f	c3		 ret	 0
_FsGetFileList ENDP
_TEXT	ENDS
PUBLIC	_FsCloseFile
PUBLIC	_FsOpenFile
EXTRN	_FddReadSector:PROC
EXTRN	_MmAllocateNonCachedMemory:PROC
EXTRN	_strupr:PROC
EXTRN	_strlen:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _FsOpenFile
_TEXT	SEGMENT
_pt_block$ = -4						; size = 4
_pFilename$ = 8						; size = 4
_Attribute$ = 12					; size = 4
_FsOpenFile PROC					; COMDAT

; 152  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 153  : 	
; 154  : 	PFILE_CONTROL_BLOCK pt_block;
; 155  : 
; 156  : 	//파일 이름 확인
; 157  : 	if(pFilename == NULL || strlen(pFilename) == 0)

  00009	83 7d 08 00	 cmp	 DWORD PTR _pFilename$[ebp], 0
  0000d	74 10		 je	 SHORT $LN4@FsOpenFile
  0000f	8b 45 08	 mov	 eax, DWORD PTR _pFilename$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _strlen
  00018	83 c4 04	 add	 esp, 4
  0001b	85 c0		 test	 eax, eax
  0001d	75 07		 jne	 SHORT $LN5@FsOpenFile
$LN4@FsOpenFile:

; 158  : 		return NULL;

  0001f	33 c0		 xor	 eax, eax
  00021	e9 aa 00 00 00	 jmp	 $LN6@FsOpenFile
$LN5@FsOpenFile:

; 159  : 	strupr(pFilename);

  00026	8b 45 08	 mov	 eax, DWORD PTR _pFilename$[ebp]
  00029	50		 push	 eax
  0002a	e8 00 00 00 00	 call	 _strupr
  0002f	83 c4 04	 add	 esp, 4

; 160  : 
; 161  : 	//메모리 할당
; 162  : 	pt_block = MmAllocateNonCachedMemory(sizeof(FILE_CONTROL_BLOCK));

  00032	68 16 02 00 00	 push	 534			; 00000216H
  00037	e8 00 00 00 00	 call	 _MmAllocateNonCachedMemory
  0003c	83 c4 04	 add	 esp, 4
  0003f	89 45 fc	 mov	 DWORD PTR _pt_block$[ebp], eax

; 163  : 	if(pt_block == NULL) return NULL;

  00042	83 7d fc 00	 cmp	 DWORD PTR _pt_block$[ebp], 0
  00046	75 07		 jne	 SHORT $LN3@FsOpenFile
  00048	33 c0		 xor	 eax, eax
  0004a	e9 81 00 00 00	 jmp	 $LN6@FsOpenFile
$LN3@FsOpenFile:

; 164  : 
; 165  : 	pt_block->found			= FALSE;

  0004f	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  00052	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 166  : 	pt_block->pt_filename	= pFilename;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  0005b	8b 4d 08	 mov	 ecx, DWORD PTR _pFilename$[ebp]
  0005e	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 167  : 	pt_block->attribute		= Attribute;

  00061	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  00064	8b 4d 0c	 mov	 ecx, DWORD PTR _Attribute$[ebp]
  00067	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 168  : 	pt_block->bytesread		= 0;

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  0006d	c7 40 12 00 00
	00 00		 mov	 DWORD PTR [eax+18], 0

; 169  : 
; 170  : 	//파일 시스템 내에서 파일을 탐색
; 171  : 	FsGetFileList(Fsp_of_callback, pt_block);

  00074	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  00077	50		 push	 eax
  00078	68 00 00 00 00	 push	 OFFSET _Fsp_of_callback
  0007d	e8 00 00 00 00	 call	 _FsGetFileList
  00082	83 c4 08	 add	 esp, 8

; 172  : 	if(!pt_block->found) {

  00085	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  00088	83 38 00	 cmp	 DWORD PTR [eax], 0
  0008b	75 10		 jne	 SHORT $LN2@FsOpenFile

; 173  : 		FsCloseFile((HANDLE)pt_block);

  0008d	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  00090	50		 push	 eax
  00091	e8 00 00 00 00	 call	 _FsCloseFile
  00096	83 c4 04	 add	 esp, 4

; 174  : 		return NULL;

  00099	33 c0		 xor	 eax, eax
  0009b	eb 33		 jmp	 SHORT $LN6@FsOpenFile
$LN2@FsOpenFile:

; 175  : 	}
; 176  : 
; 177  : 	//파일의 데이터를 FCB의 buffer로 읽어들인다.
; 178  : 	//pt_block->cur_cluster+CLUSTER_OFFSET ->우리가 찾고자 하는 데이터의 위치
; 179  : 	if(!FddReadSector(pt_block->cur_cluster+CLUSTER_OFFSET, 1, pt_block->buffer)) {

  0009d	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  000a0	83 c0 16	 add	 eax, 22			; 00000016H
  000a3	50		 push	 eax
  000a4	6a 01		 push	 1
  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _pt_block$[ebp]
  000a9	0f b7 51 10	 movzx	 edx, WORD PTR [ecx+16]
  000ad	83 c2 1f	 add	 edx, 31			; 0000001fH
  000b0	52		 push	 edx
  000b1	e8 00 00 00 00	 call	 _FddReadSector
  000b6	83 c4 0c	 add	 esp, 12			; 0000000cH
  000b9	85 c0		 test	 eax, eax
  000bb	75 10		 jne	 SHORT $LN1@FsOpenFile

; 180  : 		FsCloseFile((HANDLE)pt_block);

  000bd	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  000c0	50		 push	 eax
  000c1	e8 00 00 00 00	 call	 _FsCloseFile
  000c6	83 c4 04	 add	 esp, 4

; 181  : 		return NULL;

  000c9	33 c0		 xor	 eax, eax
  000cb	eb 03		 jmp	 SHORT $LN6@FsOpenFile
$LN1@FsOpenFile:

; 182  : 	}
; 183  : 
; 184  : 	return (HANDLE)pt_block;

  000cd	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
$LN6@FsOpenFile:

; 185  : }

  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
_FsOpenFile ENDP
_TEXT	ENDS
EXTRN	_strcmp:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _Fsp_of_callback
_TEXT	SEGMENT
_pContext$ = -4						; size = 4
_pFileInfo$ = 8						; size = 4
_Context$ = 12						; size = 4
_Fsp_of_callback PROC					; COMDAT

; 136  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 137  : 
; 138  : 	PFILE_CONTROL_BLOCK pContext = (PFILE_CONTROL_BLOCK)Context;

  00009	8b 45 0c	 mov	 eax, DWORD PTR _Context$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _pContext$[ebp], eax

; 139  : 
; 140  : 	if(!strcmp(pFileInfo->filename, pContext->pt_filename)) {

  0000f	8b 45 fc	 mov	 eax, DWORD PTR _pContext$[ebp]
  00012	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00015	51		 push	 ecx
  00016	8b 55 08	 mov	 edx, DWORD PTR _pFileInfo$[ebp]
  00019	52		 push	 edx
  0001a	e8 00 00 00 00	 call	 _strcmp
  0001f	83 c4 08	 add	 esp, 8
  00022	85 c0		 test	 eax, eax
  00024	75 27		 jne	 SHORT $LN1@Fsp_of_cal

; 141  : 		pContext->cur_cluster = pFileInfo->start_cluster;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _pContext$[ebp]
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _pFileInfo$[ebp]
  0002c	66 8b 51 16	 mov	 dx, WORD PTR [ecx+22]
  00030	66 89 50 10	 mov	 WORD PTR [eax+16], dx

; 142  : 		pContext->filesize = pFileInfo->filesize;

  00034	8b 45 fc	 mov	 eax, DWORD PTR _pContext$[ebp]
  00037	8b 4d 08	 mov	 ecx, DWORD PTR _pFileInfo$[ebp]
  0003a	8b 51 12	 mov	 edx, DWORD PTR [ecx+18]
  0003d	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 143  : 		pContext->found = TRUE;

  00040	8b 45 fc	 mov	 eax, DWORD PTR _pContext$[ebp]
  00043	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 144  : 	return FALSE;

  00049	33 c0		 xor	 eax, eax
  0004b	eb 05		 jmp	 SHORT $LN2@Fsp_of_cal
$LN1@Fsp_of_cal:

; 145  : }
; 146  : 
; 147  : return TRUE;

  0004d	b8 01 00 00 00	 mov	 eax, 1
$LN2@Fsp_of_cal:

; 148  : 
; 149  : }

  00052	5f		 pop	 edi
  00053	5e		 pop	 esi
  00054	5b		 pop	 ebx
  00055	8b e5		 mov	 esp, ebp
  00057	5d		 pop	 ebp
  00058	c3		 ret	 0
_Fsp_of_callback ENDP
_TEXT	ENDS
EXTRN	_MmFreeNonCachedMemory:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _FsCloseFile
_TEXT	SEGMENT
_FileHandle$ = 8					; size = 4
_FsCloseFile PROC					; COMDAT

; 191  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 192  : 	
; 193  : 	MmFreeNonCachedMemory(FileHandle);

  00009	8b 45 08	 mov	 eax, DWORD PTR _FileHandle$[ebp]
  0000c	50		 push	 eax
  0000d	e8 00 00 00 00	 call	 _MmFreeNonCachedMemory
  00012	83 c4 04	 add	 esp, 4

; 194  : 
; 195  : 	return TRUE;

  00015	b8 01 00 00 00	 mov	 eax, 1

; 196  : 
; 197  : }

  0001a	5f		 pop	 edi
  0001b	5e		 pop	 esi
  0001c	5b		 pop	 ebx
  0001d	8b e5		 mov	 esp, ebp
  0001f	5d		 pop	 ebp
  00020	c3		 ret	 0
_FsCloseFile ENDP
_TEXT	ENDS
PUBLIC	_FsReadFile
EXTRN	_memcpy:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _FsReadFile
_TEXT	SEGMENT
_pos_of_buffer$ = -24					; size = 4
_pos_of_userdata$ = -20					; size = 4
_cur_read_bytes$ = -16					; size = 4
_bytes_to_read$ = -12					; size = 4
_bytes_read$ = -8					; size = 4
_pt_block$ = -4						; size = 4
_FileHandle$ = 8					; size = 4
_pData$ = 12						; size = 4
_NumberOfBytesToRead$ = 16				; size = 4
_FsReadFile PROC					; COMDAT

; 200  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 201  : 	
; 202  : 	PFILE_CONTROL_BLOCK pt_block = (PFILE_CONTROL_BLOCK)FileHandle;

  00009	8b 45 08	 mov	 eax, DWORD PTR _FileHandle$[ebp]
  0000c	89 45 fc	 mov	 DWORD PTR _pt_block$[ebp], eax

; 203  : 	DWORD bytes_read, bytes_to_read, cur_read_bytes;
; 204  : 	DWORD pos_of_userdata, pos_of_buffer;
; 205  : 
; 206  : 	//인자로넘어온 파일의 핸들을 검사
; 207  : 	if(FileHandle == NULL || pData == NULL || NumberOfBytesToRead == 0) return 0;

  0000f	83 7d 08 00	 cmp	 DWORD PTR _FileHandle$[ebp], 0
  00013	74 0c		 je	 SHORT $LN12@FsReadFile
  00015	83 7d 0c 00	 cmp	 DWORD PTR _pData$[ebp], 0
  00019	74 06		 je	 SHORT $LN12@FsReadFile
  0001b	83 7d 10 00	 cmp	 DWORD PTR _NumberOfBytesToRead$[ebp], 0
  0001f	75 07		 jne	 SHORT $LN13@FsReadFile
$LN12@FsReadFile:
  00021	33 c0		 xor	 eax, eax
  00023	e9 40 01 00 00	 jmp	 $LN14@FsReadFile
$LN13@FsReadFile:

; 208  : 
; 209  : 	//파일의 크기를 통해 사용자가 읽으려는 바이트를 계산
; 210  : 	if(pt_block->filesize <= pt_block->bytesread) {

  00028	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  0002b	8b 4d fc	 mov	 ecx, DWORD PTR _pt_block$[ebp]
  0002e	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00031	3b 51 12	 cmp	 edx, DWORD PTR [ecx+18]
  00034	77 09		 ja	 SHORT $LN11@FsReadFile

; 211  : 		return 0;

  00036	33 c0		 xor	 eax, eax
  00038	e9 2b 01 00 00	 jmp	 $LN14@FsReadFile
  0003d	eb 28		 jmp	 SHORT $LN10@FsReadFile
$LN11@FsReadFile:

; 212  : 	} else if(pt_block->bytesread+NumberOfBytesToRead < pt_block->filesize) {

  0003f	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  00042	8b 48 12	 mov	 ecx, DWORD PTR [eax+18]
  00045	03 4d 10	 add	 ecx, DWORD PTR _NumberOfBytesToRead$[ebp]
  00048	8b 55 fc	 mov	 edx, DWORD PTR _pt_block$[ebp]
  0004b	3b 4a 0c	 cmp	 ecx, DWORD PTR [edx+12]
  0004e	73 08		 jae	 SHORT $LN9@FsReadFile

; 213  : 		bytes_to_read = NumberOfBytesToRead;

  00050	8b 45 10	 mov	 eax, DWORD PTR _NumberOfBytesToRead$[ebp]
  00053	89 45 f4	 mov	 DWORD PTR _bytes_to_read$[ebp], eax

; 214  : 	} else {

  00056	eb 0f		 jmp	 SHORT $LN10@FsReadFile
$LN9@FsReadFile:

; 215  : 		bytes_to_read = pt_block->filesize - pt_block->bytesread;

  00058	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  0005b	8b 4d fc	 mov	 ecx, DWORD PTR _pt_block$[ebp]
  0005e	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  00061	2b 51 12	 sub	 edx, DWORD PTR [ecx+18]
  00064	89 55 f4	 mov	 DWORD PTR _bytes_to_read$[ebp], edx
$LN10@FsReadFile:

; 216  : 	}
; 217  : 
; 218  : 	pos_of_userdata = 0; //인자를 넘겨준 버퍼의 offset

  00067	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _pos_of_userdata$[ebp], 0

; 219  : 	bytes_read = 0; //파일에서 최종 읽어드린 바이트 수를 저장하는 변수

  0006e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _bytes_read$[ebp], 0
$LN7@FsReadFile:

; 220  : 
; 221  : 	//루프를 통래 읽어야 될 총 바이트를 다 읽을떄까지 반복
; 222  : 	while(bytes_to_read != 0) {

  00075	83 7d f4 00	 cmp	 DWORD PTR _bytes_to_read$[ebp], 0
  00079	0f 84 e6 00 00
	00		 je	 $LN6@FsReadFile

; 223  : 		pos_of_buffer = pt_block->bytesread % BYTES_PER_SECTOR;

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  00082	8b 40 12	 mov	 eax, DWORD PTR [eax+18]
  00085	33 d2		 xor	 edx, edx
  00087	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  0008c	f7 f1		 div	 ecx
  0008e	89 55 e8	 mov	 DWORD PTR _pos_of_buffer$[ebp], edx

; 224  : 		cur_read_bytes = BYTES_PER_SECTOR - pos_of_buffer;

  00091	b8 00 02 00 00	 mov	 eax, 512		; 00000200H
  00096	2b 45 e8	 sub	 eax, DWORD PTR _pos_of_buffer$[ebp]
  00099	89 45 f0	 mov	 DWORD PTR _cur_read_bytes$[ebp], eax

; 225  : 
; 226  : 		//FCB의 buffer에 남아있는 바이트 수를 넘겨받는다
; 227  : 		if(cur_read_bytes > bytes_to_read)

  0009c	8b 45 f0	 mov	 eax, DWORD PTR _cur_read_bytes$[ebp]
  0009f	3b 45 f4	 cmp	 eax, DWORD PTR _bytes_to_read$[ebp]
  000a2	76 06		 jbe	 SHORT $LN5@FsReadFile

; 228  : 			cur_read_bytes = bytes_to_read;

  000a4	8b 45 f4	 mov	 eax, DWORD PTR _bytes_to_read$[ebp]
  000a7	89 45 f0	 mov	 DWORD PTR _cur_read_bytes$[ebp], eax
$LN5@FsReadFile:

; 229  : 
; 230  : 		//복사 후 연산에 연산된 변구들을 업데이트
; 231  : 		memcpy((pData+pos_of_userdata), (pt_block->buffer+pos_of_buffer), cur_read_bytes);

  000aa	8b 45 f0	 mov	 eax, DWORD PTR _cur_read_bytes$[ebp]
  000ad	50		 push	 eax
  000ae	8b 4d e8	 mov	 ecx, DWORD PTR _pos_of_buffer$[ebp]
  000b1	8b 55 fc	 mov	 edx, DWORD PTR _pt_block$[ebp]
  000b4	8d 44 0a 16	 lea	 eax, DWORD PTR [edx+ecx+22]
  000b8	50		 push	 eax
  000b9	8b 4d 0c	 mov	 ecx, DWORD PTR _pData$[ebp]
  000bc	03 4d ec	 add	 ecx, DWORD PTR _pos_of_userdata$[ebp]
  000bf	51		 push	 ecx
  000c0	e8 00 00 00 00	 call	 _memcpy
  000c5	83 c4 0c	 add	 esp, 12			; 0000000cH

; 232  : 
; 233  : 		bytes_read += cur_read_bytes;

  000c8	8b 45 f8	 mov	 eax, DWORD PTR _bytes_read$[ebp]
  000cb	03 45 f0	 add	 eax, DWORD PTR _cur_read_bytes$[ebp]
  000ce	89 45 f8	 mov	 DWORD PTR _bytes_read$[ebp], eax

; 234  : 		bytes_to_read -= cur_read_bytes;

  000d1	8b 45 f4	 mov	 eax, DWORD PTR _bytes_to_read$[ebp]
  000d4	2b 45 f0	 sub	 eax, DWORD PTR _cur_read_bytes$[ebp]
  000d7	89 45 f4	 mov	 DWORD PTR _bytes_to_read$[ebp], eax

; 235  : 		pt_block->bytesread += cur_read_bytes;

  000da	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  000dd	8b 48 12	 mov	 ecx, DWORD PTR [eax+18]
  000e0	03 4d f0	 add	 ecx, DWORD PTR _cur_read_bytes$[ebp]
  000e3	8b 55 fc	 mov	 edx, DWORD PTR _pt_block$[ebp]
  000e6	89 4a 12	 mov	 DWORD PTR [edx+18], ecx

; 236  : 		pos_of_userdata += cur_read_bytes;

  000e9	8b 45 ec	 mov	 eax, DWORD PTR _pos_of_userdata$[ebp]
  000ec	03 45 f0	 add	 eax, DWORD PTR _cur_read_bytes$[ebp]
  000ef	89 45 ec	 mov	 DWORD PTR _pos_of_userdata$[ebp], eax

; 237  : 
; 238  : 		//다음 클러스터로 넘어가고, 디스크에서 다음섹터를 읽는다
; 239  : 		if(pt_block->bytesread%BYTES_PER_SECTOR)

  000f2	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  000f5	8b 40 12	 mov	 eax, DWORD PTR [eax+18]
  000f8	33 d2		 xor	 edx, edx
  000fa	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  000ff	f7 f1		 div	 ecx
  00101	85 d2		 test	 edx, edx
  00103	74 05		 je	 SHORT $LN4@FsReadFile

; 240  : 			continue;

  00105	e9 6b ff ff ff	 jmp	 $LN7@FsReadFile
$LN4@FsReadFile:

; 241  : 
; 242  : 		//다음 클러스터가 Bad 클러스터일 경우 중단, 아닐경우 클러스트를 디스크로부터 buffer로 로딩
; 243  : 		pt_block->cur_cluster = FspGetNextCluster(pt_block->cur_cluster);

  0010a	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  0010d	66 8b 48 10	 mov	 cx, WORD PTR [eax+16]
  00111	51		 push	 ecx
  00112	e8 00 00 00 00	 call	 _FspGetNextCluster
  00117	83 c4 04	 add	 esp, 4
  0011a	8b 55 fc	 mov	 edx, DWORD PTR _pt_block$[ebp]
  0011d	66 89 42 10	 mov	 WORD PTR [edx+16], ax

; 244  : 		if(pt_block->cur_cluster < 0x2 || pt_block->cur_cluster > 0xfef)

  00121	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  00124	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  00128	83 f9 02	 cmp	 ecx, 2
  0012b	7c 0f		 jl	 SHORT $LN2@FsReadFile
  0012d	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  00130	0f b7 48 10	 movzx	 ecx, WORD PTR [eax+16]
  00134	81 f9 ef 0f 00
	00		 cmp	 ecx, 4079		; 00000fefH
  0013a	7e 02		 jle	 SHORT $LN3@FsReadFile
$LN2@FsReadFile:

; 245  : 			break;

  0013c	eb 27		 jmp	 SHORT $LN6@FsReadFile
$LN3@FsReadFile:

; 246  : 		if(!FddReadSector(pt_block->cur_cluster+CLUSTER_OFFSET, 1, pt_block->buffer))

  0013e	8b 45 fc	 mov	 eax, DWORD PTR _pt_block$[ebp]
  00141	83 c0 16	 add	 eax, 22			; 00000016H
  00144	50		 push	 eax
  00145	6a 01		 push	 1
  00147	8b 4d fc	 mov	 ecx, DWORD PTR _pt_block$[ebp]
  0014a	0f b7 51 10	 movzx	 edx, WORD PTR [ecx+16]
  0014e	83 c2 1f	 add	 edx, 31			; 0000001fH
  00151	52		 push	 edx
  00152	e8 00 00 00 00	 call	 _FddReadSector
  00157	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015a	85 c0		 test	 eax, eax
  0015c	75 02		 jne	 SHORT $LN1@FsReadFile

; 247  : 			break;

  0015e	eb 05		 jmp	 SHORT $LN6@FsReadFile
$LN1@FsReadFile:

; 248  : 	}

  00160	e9 10 ff ff ff	 jmp	 $LN7@FsReadFile
$LN6@FsReadFile:

; 249  : 
; 250  : 	return bytes_read;

  00165	8b 45 f8	 mov	 eax, DWORD PTR _bytes_read$[ebp]
$LN14@FsReadFile:

; 251  : }

  00168	5f		 pop	 edi
  00169	5e		 pop	 esi
  0016a	5b		 pop	 ebx
  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c3		 ret	 0
_FsReadFile ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BH@DBHHHLIF@Reading?5FAT?5Table?4?4?4?$AN?6?$AA@ ; `string'
EXTRN	_CrtPrintText:PROC
_BSS	SEGMENT
_m_FAT	DB	01200H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0BH@DBHHHLIF@Reading?5FAT?5Table?4?4?4?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BH@DBHHHLIF@Reading?5FAT?5Table?4?4?4?$AN?6?$AA@ DB 'Reading FAT T'
	DB	'able...', 0dH, 0aH, 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _FspLoadFAT
_TEXT	SEGMENT
_FspLoadFAT PROC					; COMDAT

; 257  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 258  : 
; 259  : 	CrtPrintText("Reading FAT Table...\r\n");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0BH@DBHHHLIF@Reading?5FAT?5Table?4?4?4?$AN?6?$AA@
  0000e	e8 00 00 00 00	 call	 _CrtPrintText
  00013	83 c4 04	 add	 esp, 4

; 260  : 	return FddReadSector(0x01, 9, m_FAT);

  00016	68 00 00 00 00	 push	 OFFSET _m_FAT
  0001b	6a 09		 push	 9
  0001d	6a 01		 push	 1
  0001f	e8 00 00 00 00	 call	 _FddReadSector
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 261  : }

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_FspLoadFAT ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CA@EIKHPAPI@Reading?5Directory?5Entries?4?4?4?5?$AN?6?$AA@ ; `string'
;	COMDAT ??_C@_0CA@EIKHPAPI@Reading?5Directory?5Entries?4?4?4?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0CA@EIKHPAPI@Reading?5Directory?5Entries?4?4?4?5?$AN?6?$AA@ DB 'Rea'
	DB	'ding Directory Entries... ', 0dH, 0aH, 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _FspLoadDirEntry
_TEXT	SEGMENT
_FspLoadDirEntry PROC					; COMDAT

; 265  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 266  : 
; 267  : 	CrtPrintText("Reading Directory Entries... \r\n");

  00009	68 00 00 00 00	 push	 OFFSET ??_C@_0CA@EIKHPAPI@Reading?5Directory?5Entries?4?4?4?5?$AN?6?$AA@
  0000e	e8 00 00 00 00	 call	 _CrtPrintText
  00013	83 c4 04	 add	 esp, 4

; 268  : 	return FddReadSector(0x13, 14, (BYTE *)m_DirEntry);

  00016	68 00 00 00 00	 push	 OFFSET _m_DirEntry
  0001b	6a 0e		 push	 14			; 0000000eH
  0001d	6a 13		 push	 19			; 00000013H
  0001f	e8 00 00 00 00	 call	 _FddReadSector
  00024	83 c4 0c	 add	 esp, 12			; 0000000cH

; 269  : 
; 270  : }

  00027	5f		 pop	 edi
  00028	5e		 pop	 esi
  00029	5b		 pop	 ebx
  0002a	8b e5		 mov	 esp, ebp
  0002c	5d		 pop	 ebp
  0002d	c3		 ret	 0
_FspLoadDirEntry ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _FspGetNextCluster
_TEXT	SEGMENT
_fat_entry$ = -8					; size = 2
_cluster$ = -4						; size = 2
_CurCluster$ = 8					; size = 2
_FspGetNextCluster PROC					; COMDAT

; 275  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 276  : 	
; 277  : 	WORD cluster, fat_entry;
; 278  : 
; 279  : 	//찾고자 하는 클러스터 번호가 홀수인지 짝수인지 검사
; 280  : 	//fat_entry를 찾는다
; 281  : 	if(CurCluster%2) { /* odd */

  00009	0f b7 45 08	 movzx	 eax, WORD PTR _CurCluster$[ebp]
  0000d	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  00012	79 05		 jns	 SHORT $LN7@FspGetNext
  00014	48		 dec	 eax
  00015	83 c8 fe	 or	 eax, -2			; fffffffeH
  00018	40		 inc	 eax
$LN7@FspGetNext:
  00019	85 c0		 test	 eax, eax
  0001b	74 12		 je	 SHORT $LN4@FspGetNext

; 282  : 		fat_entry = ((CurCluster>>1)*3)+1;

  0001d	0f b7 45 08	 movzx	 eax, WORD PTR _CurCluster$[ebp]
  00021	d1 f8		 sar	 eax, 1
  00023	6b c0 03	 imul	 eax, 3
  00026	83 c0 01	 add	 eax, 1
  00029	66 89 45 f8	 mov	 WORD PTR _fat_entry$[ebp], ax

; 283  : 	} else { /*even */

  0002d	eb 0d		 jmp	 SHORT $LN3@FspGetNext
$LN4@FspGetNext:

; 284  : 		fat_entry = ((CurCluster>>1)*3);

  0002f	0f b7 45 08	 movzx	 eax, WORD PTR _CurCluster$[ebp]
  00033	d1 f8		 sar	 eax, 1
  00035	6b c0 03	 imul	 eax, 3
  00038	66 89 45 f8	 mov	 WORD PTR _fat_entry$[ebp], ax
$LN3@FspGetNext:

; 285  : 	}
; 286  : 
; 287  : 	//fat_entry를 통해 m_FAT버퍼의 FAT테이블과 비트연산을 통해 클러스터 번홀를 찾는다
; 288  : 	cluster = (WORD)(m_FAT[fat_entry]);

  0003c	0f b7 45 f8	 movzx	 eax, WORD PTR _fat_entry$[ebp]
  00040	66 0f b6 88 00
	00 00 00	 movzx	 cx, BYTE PTR _m_FAT[eax]
  00048	66 89 4d fc	 mov	 WORD PTR _cluster$[ebp], cx

; 289  : 	cluster |= ((WORD)(m_FAT[fat_entry+1]) << 8);

  0004c	0f b7 45 f8	 movzx	 eax, WORD PTR _fat_entry$[ebp]
  00050	0f b6 88 01 00
	00 00		 movzx	 ecx, BYTE PTR _m_FAT[eax+1]
  00057	c1 e1 08	 shl	 ecx, 8
  0005a	0f b7 55 fc	 movzx	 edx, WORD PTR _cluster$[ebp]
  0005e	0b d1		 or	 edx, ecx
  00060	66 89 55 fc	 mov	 WORD PTR _cluster$[ebp], dx

; 290  : 
; 291  : 	if(CurCluster % 2)

  00064	0f b7 45 08	 movzx	 eax, WORD PTR _CurCluster$[ebp]
  00068	25 01 00 00 80	 and	 eax, -2147483647	; 80000001H
  0006d	79 05		 jns	 SHORT $LN8@FspGetNext
  0006f	48		 dec	 eax
  00070	83 c8 fe	 or	 eax, -2			; fffffffeH
  00073	40		 inc	 eax
$LN8@FspGetNext:
  00074	85 c0		 test	 eax, eax
  00076	74 0e		 je	 SHORT $LN2@FspGetNext

; 292  : 		cluster >>= 4;

  00078	66 8b 45 fc	 mov	 ax, WORD PTR _cluster$[ebp]
  0007c	66 c1 e8 04	 shr	 ax, 4
  00080	66 89 45 fc	 mov	 WORD PTR _cluster$[ebp], ax

; 293  : 
; 294  : 	else

  00084	eb 0d		 jmp	 SHORT $LN1@FspGetNext
$LN2@FspGetNext:

; 295  : 		cluster &= 0x0fff;

  00086	0f b7 45 fc	 movzx	 eax, WORD PTR _cluster$[ebp]
  0008a	25 ff 0f 00 00	 and	 eax, 4095		; 00000fffH
  0008f	66 89 45 fc	 mov	 WORD PTR _cluster$[ebp], ax
$LN1@FspGetNext:

; 296  : 
; 297  : 	return cluster;

  00093	66 8b 45 fc	 mov	 ax, WORD PTR _cluster$[ebp]

; 298  : 
; 299  : }

  00097	5f		 pop	 edi
  00098	5e		 pop	 esi
  00099	5b		 pop	 ebx
  0009a	8b e5		 mov	 esp, ebp
  0009c	5d		 pop	 ebp
  0009d	c3		 ret	 0
_FspGetNextCluster ENDP
_TEXT	ENDS
END
