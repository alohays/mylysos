; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	c:\Develop\MyoksOS\myoksos.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	_highNum:DWORD
COMM	_lowNum:DWORD
COMM	_normalNum:DWORD
_DATA	ENDS
PUBLIC	??_C@_0BE@DAEAAKEH@High?5Count?5?3?5?$CF15d?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	_HighCount
EXTRN	_CrtPrintf:PROC
EXTRN	_CrtPrintTextXYWithAttr:PROC
;	COMDAT ??_C@_0BE@DAEAAKEH@High?5Count?5?3?5?$CF15d?$AN?6?$AA@
; File c:\develop\myoksos\myoksos.c
CONST	SEGMENT
??_C@_0BE@DAEAAKEH@High?5Count?5?3?5?$CF15d?$AN?6?$AA@ DB 'High Count : %'
	DB	'15d', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _HighCount
_TEXT	SEGMENT
_HighCount PROC						; COMDAT

; 16   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@HighCount:

; 17   : 	while(1){

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	85 c0		 test	 eax, eax
  00010	74 38		 je	 SHORT $LN3@HighCount

; 18   : ENTER_CRITICAL_SECTION();

  00012	9c		 pushfd
  00013	fa		 cli

; 19   : 		highNum++;

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR _highNum
  00019	83 c0 01	 add	 eax, 1
  0001c	a3 00 00 00 00	 mov	 DWORD PTR _highNum, eax

; 20   : 		CrtPrintTextXYWithAttr("", 0, 0, NULL);

  00021	6a 00		 push	 0
  00023	6a 00		 push	 0
  00025	6a 00		 push	 0
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0002c	e8 00 00 00 00	 call	 _CrtPrintTextXYWithAttr
  00031	83 c4 10	 add	 esp, 16			; 00000010H

; 21   : 		CrtPrintf("High Count : %15d\r\n", highNum);  //high 출력

  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR _highNum
  00039	50		 push	 eax
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BE@DAEAAKEH@High?5Count?5?3?5?$CF15d?$AN?6?$AA@
  0003f	e8 00 00 00 00	 call	 _CrtPrintf
  00044	83 c4 08	 add	 esp, 8

; 22   : EXIT_CRITICAL_SECTION();

  00047	9d		 popfd

; 23   : 	}

  00048	eb bf		 jmp	 SHORT $LN2@HighCount
$LN3@HighCount:

; 24   : }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
_HighCount ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BG@IAEPFFNC@Normal?5Count?5?3?5?$CF15d?$AN?6?$AA@ ; `string'
PUBLIC	_NormalCount
;	COMDAT ??_C@_0BG@IAEPFFNC@Normal?5Count?5?3?5?$CF15d?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BG@IAEPFFNC@Normal?5Count?5?3?5?$CF15d?$AN?6?$AA@ DB 'Normal Count'
	DB	' : %15d', 0dH, 0aH, 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _NormalCount
_TEXT	SEGMENT
_NormalCount PROC					; COMDAT

; 26   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@NormalCoun:

; 27   : 	while(1){

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	85 c0		 test	 eax, eax
  00010	74 38		 je	 SHORT $LN3@NormalCoun

; 28   : ENTER_CRITICAL_SECTION();

  00012	9c		 pushfd
  00013	fa		 cli

; 29   : 		normalNum++;

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR _normalNum
  00019	83 c0 01	 add	 eax, 1
  0001c	a3 00 00 00 00	 mov	 DWORD PTR _normalNum, eax

; 30   : 		CrtPrintTextXYWithAttr("", 0, 1, NULL);

  00021	6a 00		 push	 0
  00023	6a 01		 push	 1
  00025	6a 00		 push	 0
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0002c	e8 00 00 00 00	 call	 _CrtPrintTextXYWithAttr
  00031	83 c4 10	 add	 esp, 16			; 00000010H

; 31   : 		CrtPrintf("Normal Count : %15d\r\n", normalNum);  //normal 출력

  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR _normalNum
  00039	50		 push	 eax
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BG@IAEPFFNC@Normal?5Count?5?3?5?$CF15d?$AN?6?$AA@
  0003f	e8 00 00 00 00	 call	 _CrtPrintf
  00044	83 c4 08	 add	 esp, 8

; 32   : EXIT_CRITICAL_SECTION();

  00047	9d		 popfd

; 33   : 	}

  00048	eb bf		 jmp	 SHORT $LN2@NormalCoun
$LN3@NormalCoun:

; 34   : }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
_NormalCount ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BD@JDDCNBAL@Low?5Count?5?3?5?$CF15d?$AN?6?$AA@ ; `string'
PUBLIC	_LowCount
;	COMDAT ??_C@_0BD@JDDCNBAL@Low?5Count?5?3?5?$CF15d?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@JDDCNBAL@Low?5Count?5?3?5?$CF15d?$AN?6?$AA@ DB 'Low Count : %15'
	DB	'd', 0dH, 0aH, 00H				; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _LowCount
_TEXT	SEGMENT
_LowCount PROC						; COMDAT

; 36   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN2@LowCount:

; 37   : 	while(1){

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	85 c0		 test	 eax, eax
  00010	74 38		 je	 SHORT $LN3@LowCount

; 38   : ENTER_CRITICAL_SECTION();

  00012	9c		 pushfd
  00013	fa		 cli

; 39   : 		lowNum++;

  00014	a1 00 00 00 00	 mov	 eax, DWORD PTR _lowNum
  00019	83 c0 01	 add	 eax, 1
  0001c	a3 00 00 00 00	 mov	 DWORD PTR _lowNum, eax

; 40   : 		CrtPrintTextXYWithAttr("", 0, 2, NULL);

  00021	6a 00		 push	 0
  00023	6a 02		 push	 2
  00025	6a 00		 push	 0
  00027	68 00 00 00 00	 push	 OFFSET ??_C@_00CNPNBAHC@?$AA@
  0002c	e8 00 00 00 00	 call	 _CrtPrintTextXYWithAttr
  00031	83 c4 10	 add	 esp, 16			; 00000010H

; 41   : 		CrtPrintf("Low Count : %15d\r\n", lowNum);  //low 출력

  00034	a1 00 00 00 00	 mov	 eax, DWORD PTR _lowNum
  00039	50		 push	 eax
  0003a	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@JDDCNBAL@Low?5Count?5?3?5?$CF15d?$AN?6?$AA@
  0003f	e8 00 00 00 00	 call	 _CrtPrintf
  00044	83 c4 08	 add	 esp, 8

; 42   : EXIT_CRITICAL_SECTION();

  00047	9d		 popfd

; 43   : 	}

  00048	eb bf		 jmp	 SHORT $LN2@LowCount
$LN3@LowCount:

; 44   : }

  0004a	5f		 pop	 edi
  0004b	5e		 pop	 esi
  0004c	5b		 pop	 ebx
  0004d	8b e5		 mov	 esp, ebp
  0004f	5d		 pop	 ebp
  00050	c3		 ret	 0
_LowCount ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BB@CINOICC@Booting?5Error?$CB?$AN?6?$AA@	; `string'
PUBLIC	??_C@_0DD@GHBOJMFM@Floppy?5Disk?5Driver?5is?5initialize@ ; `string'
PUBLIC	??_C@_0CL@LECLFJDL@FddInitializeDriver?$CI?$CJ?5returned?5a@ ; `string'
PUBLIC	??_C@_0DA@BAJDKHNK@Keyboard?5Driver?5is?5initialized?5s@ ; `string'
PUBLIC	??_C@_0CL@BBHNNJJA@KbdInitializeDriver?$CI?$CJ?5returned?5a@ ; `string'
PUBLIC	??_C@_0CL@EKIIKDMP@KrnInitializeKernel?$CI?$CJ?5returned?5a@ ; `string'
PUBLIC	_myoksos_init
EXTRN	_PsSetThreadStatus:PROC
EXTRN	_CrtClearScreen:PROC
EXTRN	_PsCreateThreadPriority:PROC
EXTRN	_PsCreateProcess:PROC
EXTRN	_FddInitializeDriver:PROC
EXTRN	_KbdInitializeDriver:PROC
EXTRN	_KrnInitializeKernel:PROC
EXTRN	_CrtInitializeDriver:PROC
;	COMDAT ??_C@_0BB@CINOICC@Booting?5Error?$CB?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BB@CINOICC@Booting?5Error?$CB?$AN?6?$AA@ DB 'Booting Error!', 0dH, 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@GHBOJMFM@Floppy?5Disk?5Driver?5is?5initialize@
CONST	SEGMENT
??_C@_0DD@GHBOJMFM@Floppy?5Disk?5Driver?5is?5initialize@ DB 'Floppy Disk '
	DB	'Driver is initialized successfully!!', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@LECLFJDL@FddInitializeDriver?$CI?$CJ?5returned?5a@
CONST	SEGMENT
??_C@_0CL@LECLFJDL@FddInitializeDriver?$CI?$CJ?5returned?5a@ DB 'FddIniti'
	DB	'alizeDriver() returned an error.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@BAJDKHNK@Keyboard?5Driver?5is?5initialized?5s@
CONST	SEGMENT
??_C@_0DA@BAJDKHNK@Keyboard?5Driver?5is?5initialized?5s@ DB 'Keyboard Dri'
	DB	'ver is initialized successfully!!', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@BBHNNJJA@KbdInitializeDriver?$CI?$CJ?5returned?5a@
CONST	SEGMENT
??_C@_0CL@BBHNNJJA@KbdInitializeDriver?$CI?$CJ?5returned?5a@ DB 'KbdIniti'
	DB	'alizeDriver() returned an error.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@EKIIKDMP@KrnInitializeKernel?$CI?$CJ?5returned?5a@
CONST	SEGMENT
??_C@_0CL@EKIIKDMP@KrnInitializeKernel?$CI?$CJ?5returned?5a@ DB 'KrnIniti'
	DB	'alizeKernel() returned an error.', 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _myoksos_init
_TEXT	SEGMENT
_l_thread3$ = -40					; size = 4
_l_thread2$ = -36					; size = 4
_l_thread1$ = -32					; size = 4
_n_thread3$ = -28					; size = 4
_n_thread2$ = -24					; size = 4
_n_thread1$ = -20					; size = 4
_h_thread3$ = -16					; size = 4
_h_thread2$ = -12					; size = 4
_h_thread1$ = -8					; size = 4
_process$ = -4						; size = 4
_myoksos_init PROC					; COMDAT

; 49   : int myoksos_init(void){

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 68	 sub	 esp, 104		; 00000068H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 50   : 	
; 51   : 	HANDLE process, h_thread1, h_thread2, h_thread3, n_thread1, n_thread2, n_thread3, l_thread1, l_thread2, l_thread3;
; 52   : 
; 53   : 	//콘솔 시스템 초기화 함수 호출
; 54   : 	if(!CrtInitializeDriver()){

  00009	e8 00 00 00 00	 call	 _CrtInitializeDriver
  0000e	85 c0		 test	 eax, eax
  00010	75 0a		 jne	 SHORT $LN4@myoksos_in

; 55   : 		halt(NULL);

  00012	6a 00		 push	 0
  00014	e8 00 00 00 00	 call	 _halt
  00019	83 c4 04	 add	 esp, 4
$LN4@myoksos_in:

; 56   : 	}
; 57   : 
; 58   : 	//커널 초기화 루틴의 호출
; 59   : 	if(!KrnInitializeKernel()){

  0001c	e8 00 00 00 00	 call	 _KrnInitializeKernel
  00021	85 c0		 test	 eax, eax
  00023	75 0d		 jne	 SHORT $LN3@myoksos_in

; 60   : 		halt("KrnInitializeKernel() returned an error.\r\n");

  00025	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@EKIIKDMP@KrnInitializeKernel?$CI?$CJ?5returned?5a@
  0002a	e8 00 00 00 00	 call	 _halt
  0002f	83 c4 04	 add	 esp, 4
$LN3@myoksos_in:

; 61   : 	}
; 62   : 
; 63   : 	if(!KbdInitializeDriver()){

  00032	e8 00 00 00 00	 call	 _KbdInitializeDriver
  00037	85 c0		 test	 eax, eax
  00039	75 0d		 jne	 SHORT $LN2@myoksos_in

; 64   : 		halt("KbdInitializeDriver() returned an error.\r\n");

  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@BBHNNJJA@KbdInitializeDriver?$CI?$CJ?5returned?5a@
  00040	e8 00 00 00 00	 call	 _halt
  00045	83 c4 04	 add	 esp, 4
$LN2@myoksos_in:

; 65   : 	}
; 66   : 
; 67   : 	CrtPrintf("Keyboard Driver is initialized successfully!!\r\n");

  00048	68 00 00 00 00	 push	 OFFSET ??_C@_0DA@BAJDKHNK@Keyboard?5Driver?5is?5initialized?5s@
  0004d	e8 00 00 00 00	 call	 _CrtPrintf
  00052	83 c4 04	 add	 esp, 4

; 68   : 
; 69   : 	if(!FddInitializeDriver())

  00055	e8 00 00 00 00	 call	 _FddInitializeDriver
  0005a	85 c0		 test	 eax, eax
  0005c	75 0d		 jne	 SHORT $LN1@myoksos_in

; 70   : 	{
; 71   : 		halt("FddInitializeDriver() returned an error.\r\n");

  0005e	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@LECLFJDL@FddInitializeDriver?$CI?$CJ?5returned?5a@
  00063	e8 00 00 00 00	 call	 _halt
  00068	83 c4 04	 add	 esp, 4
$LN1@myoksos_in:

; 72   : 	}
; 73   : 	CrtPrintf("Floppy Disk Driver is initialized successfully!!\r\n");

  0006b	68 00 00 00 00	 push	 OFFSET ??_C@_0DD@GHBOJMFM@Floppy?5Disk?5Driver?5is?5initialize@
  00070	e8 00 00 00 00	 call	 _CrtPrintf
  00075	83 c4 04	 add	 esp, 4

; 74   : 
; 75   : 	// 과제1을 위한 코드 추가!!!!!!!!
; 76   : 
; 77   : 	PsCreateProcess(&process);

  00078	8d 45 fc	 lea	 eax, DWORD PTR _process$[ebp]
  0007b	50		 push	 eax
  0007c	e8 00 00 00 00	 call	 _PsCreateProcess
  00081	83 c4 04	 add	 esp, 4

; 78   : 
; 79   : 	PsCreateThreadPriority(&h_thread1, process, HighCount, NULL, DEFAULT_STACK_SIZE, TRUE, PRIORITY_HIGH);

  00084	6a 00		 push	 0
  00086	6a 01		 push	 1
  00088	68 00 00 01 00	 push	 65536			; 00010000H
  0008d	6a 00		 push	 0
  0008f	68 00 00 00 00	 push	 OFFSET _HighCount
  00094	8b 45 fc	 mov	 eax, DWORD PTR _process$[ebp]
  00097	50		 push	 eax
  00098	8d 4d f8	 lea	 ecx, DWORD PTR _h_thread1$[ebp]
  0009b	51		 push	 ecx
  0009c	e8 00 00 00 00	 call	 _PsCreateThreadPriority
  000a1	83 c4 1c	 add	 esp, 28			; 0000001cH

; 80   : 	PsCreateThreadPriority(&h_thread2, process, HighCount, NULL, DEFAULT_STACK_SIZE, TRUE, PRIORITY_HIGH);

  000a4	6a 00		 push	 0
  000a6	6a 01		 push	 1
  000a8	68 00 00 01 00	 push	 65536			; 00010000H
  000ad	6a 00		 push	 0
  000af	68 00 00 00 00	 push	 OFFSET _HighCount
  000b4	8b 45 fc	 mov	 eax, DWORD PTR _process$[ebp]
  000b7	50		 push	 eax
  000b8	8d 4d f4	 lea	 ecx, DWORD PTR _h_thread2$[ebp]
  000bb	51		 push	 ecx
  000bc	e8 00 00 00 00	 call	 _PsCreateThreadPriority
  000c1	83 c4 1c	 add	 esp, 28			; 0000001cH

; 81   : 	PsCreateThreadPriority(&h_thread3, process, HighCount, NULL, DEFAULT_STACK_SIZE, TRUE, PRIORITY_HIGH);

  000c4	6a 00		 push	 0
  000c6	6a 01		 push	 1
  000c8	68 00 00 01 00	 push	 65536			; 00010000H
  000cd	6a 00		 push	 0
  000cf	68 00 00 00 00	 push	 OFFSET _HighCount
  000d4	8b 45 fc	 mov	 eax, DWORD PTR _process$[ebp]
  000d7	50		 push	 eax
  000d8	8d 4d f0	 lea	 ecx, DWORD PTR _h_thread3$[ebp]
  000db	51		 push	 ecx
  000dc	e8 00 00 00 00	 call	 _PsCreateThreadPriority
  000e1	83 c4 1c	 add	 esp, 28			; 0000001cH

; 82   : 	PsCreateThreadPriority(&n_thread1, process, NormalCount, NULL, DEFAULT_STACK_SIZE, TRUE, PRIORITY_NORMAL);

  000e4	6a 01		 push	 1
  000e6	6a 01		 push	 1
  000e8	68 00 00 01 00	 push	 65536			; 00010000H
  000ed	6a 00		 push	 0
  000ef	68 00 00 00 00	 push	 OFFSET _NormalCount
  000f4	8b 45 fc	 mov	 eax, DWORD PTR _process$[ebp]
  000f7	50		 push	 eax
  000f8	8d 4d ec	 lea	 ecx, DWORD PTR _n_thread1$[ebp]
  000fb	51		 push	 ecx
  000fc	e8 00 00 00 00	 call	 _PsCreateThreadPriority
  00101	83 c4 1c	 add	 esp, 28			; 0000001cH

; 83   : 	PsCreateThreadPriority(&n_thread2, process, NormalCount, NULL, DEFAULT_STACK_SIZE, TRUE, PRIORITY_NORMAL);

  00104	6a 01		 push	 1
  00106	6a 01		 push	 1
  00108	68 00 00 01 00	 push	 65536			; 00010000H
  0010d	6a 00		 push	 0
  0010f	68 00 00 00 00	 push	 OFFSET _NormalCount
  00114	8b 45 fc	 mov	 eax, DWORD PTR _process$[ebp]
  00117	50		 push	 eax
  00118	8d 4d e8	 lea	 ecx, DWORD PTR _n_thread2$[ebp]
  0011b	51		 push	 ecx
  0011c	e8 00 00 00 00	 call	 _PsCreateThreadPriority
  00121	83 c4 1c	 add	 esp, 28			; 0000001cH

; 84   : 	PsCreateThreadPriority(&n_thread3, process, NormalCount, NULL, DEFAULT_STACK_SIZE, TRUE, PRIORITY_NORMAL);

  00124	6a 01		 push	 1
  00126	6a 01		 push	 1
  00128	68 00 00 01 00	 push	 65536			; 00010000H
  0012d	6a 00		 push	 0
  0012f	68 00 00 00 00	 push	 OFFSET _NormalCount
  00134	8b 45 fc	 mov	 eax, DWORD PTR _process$[ebp]
  00137	50		 push	 eax
  00138	8d 4d e4	 lea	 ecx, DWORD PTR _n_thread3$[ebp]
  0013b	51		 push	 ecx
  0013c	e8 00 00 00 00	 call	 _PsCreateThreadPriority
  00141	83 c4 1c	 add	 esp, 28			; 0000001cH

; 85   : 	PsCreateThreadPriority(&l_thread1, process, LowCount, NULL, DEFAULT_STACK_SIZE, TRUE, PRIORITY_LOW);

  00144	6a 02		 push	 2
  00146	6a 01		 push	 1
  00148	68 00 00 01 00	 push	 65536			; 00010000H
  0014d	6a 00		 push	 0
  0014f	68 00 00 00 00	 push	 OFFSET _LowCount
  00154	8b 45 fc	 mov	 eax, DWORD PTR _process$[ebp]
  00157	50		 push	 eax
  00158	8d 4d e0	 lea	 ecx, DWORD PTR _l_thread1$[ebp]
  0015b	51		 push	 ecx
  0015c	e8 00 00 00 00	 call	 _PsCreateThreadPriority
  00161	83 c4 1c	 add	 esp, 28			; 0000001cH

; 86   : 	PsCreateThreadPriority(&l_thread2, process, LowCount, NULL, DEFAULT_STACK_SIZE, TRUE, PRIORITY_LOW);

  00164	6a 02		 push	 2
  00166	6a 01		 push	 1
  00168	68 00 00 01 00	 push	 65536			; 00010000H
  0016d	6a 00		 push	 0
  0016f	68 00 00 00 00	 push	 OFFSET _LowCount
  00174	8b 45 fc	 mov	 eax, DWORD PTR _process$[ebp]
  00177	50		 push	 eax
  00178	8d 4d dc	 lea	 ecx, DWORD PTR _l_thread2$[ebp]
  0017b	51		 push	 ecx
  0017c	e8 00 00 00 00	 call	 _PsCreateThreadPriority
  00181	83 c4 1c	 add	 esp, 28			; 0000001cH

; 87   : 	PsCreateThreadPriority(&l_thread3, process, LowCount, NULL, DEFAULT_STACK_SIZE, TRUE, PRIORITY_LOW);

  00184	6a 02		 push	 2
  00186	6a 01		 push	 1
  00188	68 00 00 01 00	 push	 65536			; 00010000H
  0018d	6a 00		 push	 0
  0018f	68 00 00 00 00	 push	 OFFSET _LowCount
  00194	8b 45 fc	 mov	 eax, DWORD PTR _process$[ebp]
  00197	50		 push	 eax
  00198	8d 4d d8	 lea	 ecx, DWORD PTR _l_thread3$[ebp]
  0019b	51		 push	 ecx
  0019c	e8 00 00 00 00	 call	 _PsCreateThreadPriority
  001a1	83 c4 1c	 add	 esp, 28			; 0000001cH

; 88   : 
; 89   : 	CrtClearScreen();

  001a4	e8 00 00 00 00	 call	 _CrtClearScreen

; 90   : 
; 91   : 	PsSetThreadStatus(h_thread1, THREAD_STATUS_READY);

  001a9	6a 02		 push	 2
  001ab	8b 45 f8	 mov	 eax, DWORD PTR _h_thread1$[ebp]
  001ae	50		 push	 eax
  001af	e8 00 00 00 00	 call	 _PsSetThreadStatus
  001b4	83 c4 08	 add	 esp, 8

; 92   : 	//PsSetThreadStatus(h_thread2, THREAD_STATUS_READY);
; 93   : 	//PsSetThreadStatus(h_thread3, THREAD_STATUS_READY);
; 94   : 	PsSetThreadStatus(n_thread1, THREAD_STATUS_READY);

  001b7	6a 02		 push	 2
  001b9	8b 45 ec	 mov	 eax, DWORD PTR _n_thread1$[ebp]
  001bc	50		 push	 eax
  001bd	e8 00 00 00 00	 call	 _PsSetThreadStatus
  001c2	83 c4 08	 add	 esp, 8

; 95   : 	//PsSetThreadStatus(n_thread2, THREAD_STATUS_READY);
; 96   : 	//PsSetThreadStatus(n_thread3, THREAD_STATUS_READY);
; 97   : 	PsSetThreadStatus(l_thread1, THREAD_STATUS_READY);

  001c5	6a 02		 push	 2
  001c7	8b 45 e0	 mov	 eax, DWORD PTR _l_thread1$[ebp]
  001ca	50		 push	 eax
  001cb	e8 00 00 00 00	 call	 _PsSetThreadStatus
  001d0	83 c4 08	 add	 esp, 8

; 98   : 	//PsSetThreadStatus(l_thread2, THREAD_STATUS_READY);
; 99   : 	//PsSetThreadStatus(l_thread3, THREAD_STATUS_READY);
; 100  : 
; 101  : 	// !!!!!!!!
; 102  : 
; 103  : 
; 104  : 
; 105  : 	// init 쓰레드의 link 필드를 idle 쓰레드로 설정
; 106  : 	_asm {
; 107  : 		push	eax

  001d3	50		 push	 eax

; 108  : 
; 109  : 		pushfd

  001d4	9c		 pushfd

; 110  : 		pop		eax

  001d5	58		 pop	 eax

; 111  : 		or		ah, 40h ; nested

  001d6	80 cc 40	 or	 ah, 64			; 00000040H

; 112  : 		push	eax

  001d9	50		 push	 eax

; 113  : 		popfd

  001da	9d		 popfd

; 114  : 
; 115  : 		pop		eax

  001db	58		 pop	 eax

; 116  : 		iretd

  001dc	cf		 iretd

; 117  : 	}
; 118  : 	
; 119  : 	//만약 초기화 실패시, 이 부분 실행(전체 시스템 정지)
; 120  : 	halt("Booting Error!\r\n");

  001dd	68 00 00 00 00	 push	 OFFSET ??_C@_0BB@CINOICC@Booting?5Error?$CB?$AN?6?$AA@
  001e2	e8 00 00 00 00	 call	 _halt
  001e7	83 c4 04	 add	 esp, 4

; 121  : 	return 0;

  001ea	33 c0		 xor	 eax, eax

; 122  : }

  001ec	5f		 pop	 edi
  001ed	5e		 pop	 esi
  001ee	5b		 pop	 ebx
  001ef	8b e5		 mov	 esp, ebp
  001f1	5d		 pop	 ebp
  001f2	c3		 ret	 0
_myoksos_init ENDP
_TEXT	ENDS
PUBLIC	??_C@_0BC@CPDHJIFL@Halting?5system?4?$AN?6?$AA@	; `string'
;	COMDAT ??_C@_0BC@CPDHJIFL@Halting?5system?4?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BC@CPDHJIFL@Halting?5system?4?$AN?6?$AA@ DB 'Halting system.', 0dH
	DB	0aH, 00H					; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _halt
_TEXT	SEGMENT
_pMsg$ = 8						; size = 4
_halt	PROC						; COMDAT

; 126  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 127  : 	if(pMsg != NULL)

  00009	83 7d 08 00	 cmp	 DWORD PTR _pMsg$[ebp], 0
  0000d	74 19		 je	 SHORT $LN2@halt

; 128  : 	{
; 129  : 		DbgPrint(pMsg);

  0000f	8b 45 08	 mov	 eax, DWORD PTR _pMsg$[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 _CrtPrintf
  00018	83 c4 04	 add	 esp, 4

; 130  : 		DbgPrint("Halting system.\r\n");

  0001b	68 00 00 00 00	 push	 OFFSET ??_C@_0BC@CPDHJIFL@Halting?5system?4?$AN?6?$AA@
  00020	e8 00 00 00 00	 call	 _CrtPrintf
  00025	83 c4 04	 add	 esp, 4
$LN2@halt:

; 131  : 	}
; 132  : 	while(1) ;

  00028	b8 01 00 00 00	 mov	 eax, 1
  0002d	85 c0		 test	 eax, eax
  0002f	74 02		 je	 SHORT $LN4@halt
  00031	eb f5		 jmp	 SHORT $LN2@halt
$LN4@halt:

; 133  : }

  00033	5f		 pop	 edi
  00034	5e		 pop	 esi
  00035	5b		 pop	 ebx
  00036	8b e5		 mov	 esp, ebp
  00038	5d		 pop	 ebp
  00039	c3		 ret	 0
_halt	ENDP
_TEXT	ENDS
END
