; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	c:\Develop\MyoksOS\fdddrv.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CH@MHIGPNEI@FddTurnOffMotor?$CI?$CJ?5returned?5an?5er@ ; `string'
PUBLIC	_FddInitializeDriver
EXTRN	_PsSetThreadStatus:PROC
EXTRN	_PsCreateThread:PROC
EXTRN	_PsCreateProcess:PROC
EXTRN	_CrtPrintf:PROC
_BSS	SEGMENT
_m_ThreadHandle DD 01H DUP (?)
_m_ProcessHandle DD 01H DUP (?)
_BSS	ENDS
;	COMDAT ??_C@_0CH@MHIGPNEI@FddTurnOffMotor?$CI?$CJ?5returned?5an?5er@
; File c:\develop\myoksos\fdddrv.c
CONST	SEGMENT
??_C@_0CH@MHIGPNEI@FddTurnOffMotor?$CI?$CJ?5returned?5an?5er@ DB 'FddTurn'
	DB	'OffMotor() returned an error.', 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _FddInitializeDriver
_TEXT	SEGMENT
_FddInitializeDriver PROC				; COMDAT

; 59   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 60   : 	if(!FddpTurnOffMotor()){

  00009	e8 00 00 00 00	 call	 _FddpTurnOffMotor
  0000e	85 c0		 test	 eax, eax
  00010	75 11		 jne	 SHORT $LN3@FddInitial

; 61   : 		DbgPrint("FddTurnOffMotor() returned an error.\r\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CH@MHIGPNEI@FddTurnOffMotor?$CI?$CJ?5returned?5an?5er@
  00017	e8 00 00 00 00	 call	 _CrtPrintf
  0001c	83 c4 04	 add	 esp, 4

; 62   : 		return FALSE;

  0001f	33 c0		 xor	 eax, eax
  00021	eb 53		 jmp	 SHORT $LN4@FddInitial
$LN3@FddInitial:

; 63   : 	}
; 64   : 
; 65   : 	if(!PsCreateProcess(&m_ProcessHandle))

  00023	68 00 00 00 00	 push	 OFFSET _m_ProcessHandle
  00028	e8 00 00 00 00	 call	 _PsCreateProcess
  0002d	83 c4 04	 add	 esp, 4
  00030	85 c0		 test	 eax, eax
  00032	75 04		 jne	 SHORT $LN2@FddInitial

; 66   : 		return FALSE;

  00034	33 c0		 xor	 eax, eax
  00036	eb 3e		 jmp	 SHORT $LN4@FddInitial
$LN2@FddInitial:

; 67   : 
; 68   : 	if(!PsCreateThread(&m_ThreadHandle, m_ProcessHandle, FddpJobProcessThread, NULL, DEFAULT_STACK_SIZE, FALSE))

  00038	6a 00		 push	 0
  0003a	68 00 00 01 00	 push	 65536			; 00010000H
  0003f	6a 00		 push	 0
  00041	68 00 00 00 00	 push	 OFFSET _FddpJobProcessThread
  00046	a1 00 00 00 00	 mov	 eax, DWORD PTR _m_ProcessHandle
  0004b	50		 push	 eax
  0004c	68 00 00 00 00	 push	 OFFSET _m_ThreadHandle
  00051	e8 00 00 00 00	 call	 _PsCreateThread
  00056	83 c4 18	 add	 esp, 24			; 00000018H
  00059	85 c0		 test	 eax, eax
  0005b	75 04		 jne	 SHORT $LN1@FddInitial

; 69   : 		return FALSE;

  0005d	33 c0		 xor	 eax, eax
  0005f	eb 15		 jmp	 SHORT $LN4@FddInitial
$LN1@FddInitial:

; 70   : 	PsSetThreadStatus(m_ThreadHandle, THREAD_STATUS_READY);

  00061	6a 02		 push	 2
  00063	a1 00 00 00 00	 mov	 eax, DWORD PTR _m_ThreadHandle
  00068	50		 push	 eax
  00069	e8 00 00 00 00	 call	 _PsSetThreadStatus
  0006e	83 c4 08	 add	 esp, 8

; 71   : 
; 72   : 	return TRUE;

  00071	b8 01 00 00 00	 mov	 eax, 1
$LN4@FddInitial:

; 73   : }

  00076	5f		 pop	 edi
  00077	5e		 pop	 esi
  00078	5b		 pop	 ebx
  00079	8b e5		 mov	 esp, ebp
  0007b	5d		 pop	 ebp
  0007c	c3		 ret	 0
_FddInitializeDriver ENDP
_TEXT	ENDS
PUBLIC	_Fdd_IRQ_Handler
_BSS	SEGMENT
_m_FddInterruptOccurred DD 01H DUP (?)
; Function compile flags: /Odtp /ZI
_BSS	ENDS
;	COMDAT _Fdd_IRQ_Handler
_TEXT	SEGMENT
_Fdd_IRQ_Handler PROC					; COMDAT

; 77   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 78   : 	m_FddInterruptOccurred=TRUE;

  00009	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR _m_FddInterruptOccurred, 1

; 79   : }

  00013	5f		 pop	 edi
  00014	5e		 pop	 esi
  00015	5b		 pop	 ebx
  00016	8b e5		 mov	 esp, ebp
  00018	5d		 pop	 ebp
  00019	c3		 ret	 0
_Fdd_IRQ_Handler ENDP
_TEXT	ENDS
EXTRN	_WRITE_PORT_UCHAR:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _FddpTurnOffMotor
_TEXT	SEGMENT
_FddpTurnOffMotor PROC					; COMDAT

; 94   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 95   : 	WRITE_PORT_UCHAR((PUCHAR)FDD_DOR_PORT, 0x00);

  00009	6a 00		 push	 0
  0000b	68 f2 03 00 00	 push	 1010			; 000003f2H
  00010	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00015	83 c4 08	 add	 esp, 8

; 96   : 	return TRUE;

  00018	b8 01 00 00 00	 mov	 eax, 1

; 97   : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_FddpTurnOffMotor ENDP
_TEXT	ENDS
EXTRN	_HalTaskSwitch:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _FddpJobProcessThread
_TEXT	SEGMENT
_job_item$ = -16					; size = 15
_StartContext$ = 8					; size = 4
_FddpJobProcessThread PROC				; COMDAT

; 207  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 50	 sub	 esp, 80			; 00000050H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN3@FddpJobPro:

; 208  : 	FDD_JOB_ITEM job_item;
; 209  : 
; 210  : 	while(1){

  00009	b8 01 00 00 00	 mov	 eax, 1
  0000e	85 c0		 test	 eax, eax
  00010	74 40		 je	 SHORT $LN2@FddpJobPro

; 211  : 		if(!FddpPopJobItem(&job_item)){

  00012	8d 45 f0	 lea	 eax, DWORD PTR _job_item$[ebp]
  00015	50		 push	 eax
  00016	e8 00 00 00 00	 call	 _FddpPopJobItem
  0001b	83 c4 04	 add	 esp, 4
  0001e	85 c0		 test	 eax, eax
  00020	75 07		 jne	 SHORT $LN1@FddpJobPro

; 212  : 			HalTaskSwitch();

  00022	e8 00 00 00 00	 call	 _HalTaskSwitch

; 213  : 			continue;

  00027	eb e0		 jmp	 SHORT $LN3@FddpJobPro
$LN1@FddpJobPro:

; 214  : 		}
; 215  : 
; 216  : 		FddpReadWriteSector(job_item.type, job_item.sector, job_item.numbers_of_sectors, job_item.pt_data);

  00029	8b 45 f7	 mov	 eax, DWORD PTR _job_item$[ebp+7]
  0002c	50		 push	 eax
  0002d	8a 4d f6	 mov	 cl, BYTE PTR _job_item$[ebp+6]
  00030	51		 push	 ecx
  00031	66 8b 55 f4	 mov	 dx, WORD PTR _job_item$[ebp+4]
  00035	52		 push	 edx
  00036	8b 45 f0	 mov	 eax, DWORD PTR _job_item$[ebp]
  00039	50		 push	 eax
  0003a	e8 00 00 00 00	 call	 _FddpReadWriteSector
  0003f	83 c4 10	 add	 esp, 16			; 00000010H

; 217  : 		PsSetThreadStatus(job_item.thread, THREAD_STATUS_READY);

  00042	6a 02		 push	 2
  00044	8b 45 fb	 mov	 eax, DWORD PTR _job_item$[ebp+11]
  00047	50		 push	 eax
  00048	e8 00 00 00 00	 call	 _PsSetThreadStatus
  0004d	83 c4 08	 add	 esp, 8

; 218  : 	}

  00050	eb b7		 jmp	 SHORT $LN3@FddpJobPro
$LN2@FddpJobPro:

; 219  : 
; 220  : 	return 0;

  00052	33 c0		 xor	 eax, eax

; 221  : }

  00054	5f		 pop	 edi
  00055	5e		 pop	 esi
  00056	5b		 pop	 ebx
  00057	8b e5		 mov	 esp, ebp
  00059	5d		 pop	 ebp
  0005a	c3		 ret	 0
_FddpJobProcessThread ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _FddpReadWriteSector
_TEXT	SEGMENT
_i$ = -12						; size = 4
_sector$ = -8						; size = 1
_track$ = -7						; size = 1
_head$ = -6						; size = 1
_drive$ = -5						; size = 1
_pDMAAddr$ = -4						; size = 4
_JobType$ = 8						; size = 4
_Sector$ = 12						; size = 2
_NumbersOfSectors$ = 16					; size = 1
_pData$ = 20						; size = 4
_FddpReadWriteSector PROC				; COMDAT

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 151  : 	BYTE *pDMAAddr = (BYTE *)0x00000000;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _pDMAAddr$[ebp], 0

; 152  : 	BYTE drive, head, track, sector;
; 153  : 	int i;
; 154  : 
; 155  : 	if(JobType == FDD_WRITE_SECTOR)

  00010	83 7d 08 01	 cmp	 DWORD PTR _JobType$[ebp], 1
  00014	75 07		 jne	 SHORT $LN13@FddpReadWr

; 156  : 		return FALSE;

  00016	33 c0		 xor	 eax, eax
  00018	e9 9f 01 00 00	 jmp	 $LN14@FddpReadWr
$LN13@FddpReadWr:

; 157  : 
; 158  : 	drive	= 0;

  0001d	c6 45 fb 00	 mov	 BYTE PTR _drive$[ebp], 0

; 159  : 	head	= ((Sector % (SECTORS_PER_TRACK * 2)) / SECTORS_PER_TRACK);

  00021	0f b7 45 0c	 movzx	 eax, WORD PTR _Sector$[ebp]
  00025	99		 cdq
  00026	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  0002b	f7 f9		 idiv	 ecx
  0002d	8b c2		 mov	 eax, edx
  0002f	99		 cdq
  00030	b9 12 00 00 00	 mov	 ecx, 18			; 00000012H
  00035	f7 f9		 idiv	 ecx
  00037	88 45 fa	 mov	 BYTE PTR _head$[ebp], al

; 160  : 	track	= (Sector / (SECTORS_PER_TRACK * 2));

  0003a	0f b7 45 0c	 movzx	 eax, WORD PTR _Sector$[ebp]
  0003e	99		 cdq
  0003f	b9 24 00 00 00	 mov	 ecx, 36			; 00000024H
  00044	f7 f9		 idiv	 ecx
  00046	88 45 f9	 mov	 BYTE PTR _track$[ebp], al

; 161  : 	sector	= (Sector % SECTORS_PER_TRACK) + 1;

  00049	0f b7 45 0c	 movzx	 eax, WORD PTR _Sector$[ebp]
  0004d	99		 cdq
  0004e	b9 12 00 00 00	 mov	 ecx, 18			; 00000012H
  00053	f7 f9		 idiv	 ecx
  00055	83 c2 01	 add	 edx, 1
  00058	88 55 f8	 mov	 BYTE PTR _sector$[ebp], dl

; 162  : 
; 163  : 	m_FddInterruptOccurred = FALSE;{

  0005b	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_FddInterruptOccurred, 0

; 164  : 		FddpTurnOnMotor();

  00065	e8 00 00 00 00	 call	 _FddpTurnOnMotor
$LN12@FddpReadWr:

; 165  : 	}while(!m_FddInterruptOccurred);

  0006a	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _m_FddInterruptOccurred, 0
  00071	75 02		 jne	 SHORT $LN11@FddpReadWr
  00073	eb f5		 jmp	 SHORT $LN12@FddpReadWr
$LN11@FddpReadWr:

; 166  : 
; 167  : 	m_FddInterruptOccurred = FALSE;{

  00075	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_FddInterruptOccurred, 0

; 168  : 		FddpWriteFdcData(0x07);

  0007f	6a 07		 push	 7
  00081	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00086	83 c4 04	 add	 esp, 4

; 169  : 		FddpWriteFdcData(0x00);

  00089	6a 00		 push	 0
  0008b	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00090	83 c4 04	 add	 esp, 4
$LN10@FddpReadWr:

; 170  : 	}while(!m_FddInterruptOccurred);

  00093	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _m_FddInterruptOccurred, 0
  0009a	75 02		 jne	 SHORT $LN9@FddpReadWr
  0009c	eb f5		 jmp	 SHORT $LN10@FddpReadWr
$LN9@FddpReadWr:

; 171  : 
; 172  : 	m_FddInterruptOccurred = FALSE;{

  0009e	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_FddInterruptOccurred, 0

; 173  : 		FddpWriteFdcData(0x0f);

  000a8	6a 0f		 push	 15			; 0000000fH
  000aa	e8 00 00 00 00	 call	 _FddpWriteFdcData
  000af	83 c4 04	 add	 esp, 4

; 174  : 		FddpWriteFdcData((head << 2) + drive);

  000b2	0f b6 45 fa	 movzx	 eax, BYTE PTR _head$[ebp]
  000b6	0f b6 4d fb	 movzx	 ecx, BYTE PTR _drive$[ebp]
  000ba	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _FddpWriteFdcData
  000c3	83 c4 04	 add	 esp, 4

; 175  : 		FddpWriteFdcData(track);

  000c6	8a 45 f9	 mov	 al, BYTE PTR _track$[ebp]
  000c9	50		 push	 eax
  000ca	e8 00 00 00 00	 call	 _FddpWriteFdcData
  000cf	83 c4 04	 add	 esp, 4
$LN8@FddpReadWr:

; 176  : 	}while(!m_FddInterruptOccurred);

  000d2	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _m_FddInterruptOccurred, 0
  000d9	75 02		 jne	 SHORT $LN7@FddpReadWr
  000db	eb f5		 jmp	 SHORT $LN8@FddpReadWr
$LN7@FddpReadWr:

; 177  : 
; 178  : 	FddpSetupDMA(JobType);

  000dd	8b 45 08	 mov	 eax, DWORD PTR _JobType$[ebp]
  000e0	50		 push	 eax
  000e1	e8 00 00 00 00	 call	 _FddpSetupDMA
  000e6	83 c4 04	 add	 esp, 4

; 179  : 
; 180  : 	m_FddInterruptOccurred = FALSE;{

  000e9	c7 05 00 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_FddInterruptOccurred, 0

; 181  : 		FddpWriteFdcData(0xe6);

  000f3	68 e6 00 00 00	 push	 230			; 000000e6H
  000f8	e8 00 00 00 00	 call	 _FddpWriteFdcData
  000fd	83 c4 04	 add	 esp, 4

; 182  : 		FddpWriteFdcData((head << 2) + drive);

  00100	0f b6 45 fa	 movzx	 eax, BYTE PTR _head$[ebp]
  00104	0f b6 4d fb	 movzx	 ecx, BYTE PTR _drive$[ebp]
  00108	8d 14 81	 lea	 edx, DWORD PTR [ecx+eax*4]
  0010b	52		 push	 edx
  0010c	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00111	83 c4 04	 add	 esp, 4

; 183  : 		FddpWriteFdcData(track);

  00114	8a 45 f9	 mov	 al, BYTE PTR _track$[ebp]
  00117	50		 push	 eax
  00118	e8 00 00 00 00	 call	 _FddpWriteFdcData
  0011d	83 c4 04	 add	 esp, 4

; 184  : 		FddpWriteFdcData(head);

  00120	8a 45 fa	 mov	 al, BYTE PTR _head$[ebp]
  00123	50		 push	 eax
  00124	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00129	83 c4 04	 add	 esp, 4

; 185  : 		FddpWriteFdcData(1);

  0012c	6a 01		 push	 1
  0012e	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00133	83 c4 04	 add	 esp, 4

; 186  : 		FddpWriteFdcData(2);

  00136	6a 02		 push	 2
  00138	e8 00 00 00 00	 call	 _FddpWriteFdcData
  0013d	83 c4 04	 add	 esp, 4

; 187  : 		FddpWriteFdcData(SECTORS_PER_TRACK);

  00140	6a 12		 push	 18			; 00000012H
  00142	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00147	83 c4 04	 add	 esp, 4

; 188  : 		FddpWriteFdcData(27);

  0014a	6a 1b		 push	 27			; 0000001bH
  0014c	e8 00 00 00 00	 call	 _FddpWriteFdcData
  00151	83 c4 04	 add	 esp, 4

; 189  : 		FddpWriteFdcData(0xff);

  00154	68 ff 00 00 00	 push	 255			; 000000ffH
  00159	e8 00 00 00 00	 call	 _FddpWriteFdcData
  0015e	83 c4 04	 add	 esp, 4
$LN6@FddpReadWr:

; 190  : 	}while(!m_FddInterruptOccurred);

  00161	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR _m_FddInterruptOccurred, 0
  00168	75 02		 jne	 SHORT $LN5@FddpReadWr
  0016a	eb f5		 jmp	 SHORT $LN6@FddpReadWr
$LN5@FddpReadWr:

; 191  : 
; 192  : 	pDMAAddr += (BYTES_PER_SECTOR*(sector-1));

  0016c	0f b6 45 f8	 movzx	 eax, BYTE PTR _sector$[ebp]
  00170	83 e8 01	 sub	 eax, 1
  00173	c1 e0 09	 shl	 eax, 9
  00176	03 45 fc	 add	 eax, DWORD PTR _pDMAAddr$[ebp]
  00179	89 45 fc	 mov	 DWORD PTR _pDMAAddr$[ebp], eax

; 193  : 	if(JobType == FDD_READ_SECTOR){

  0017c	83 7d 08 00	 cmp	 DWORD PTR _JobType$[ebp], 0
  00180	75 30		 jne	 SHORT $LN4@FddpReadWr

; 194  : 		for(i=0; i<(BYTES_PER_SECTOR*NumbersOfSectors); i++){

  00182	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00189	eb 09		 jmp	 SHORT $LN3@FddpReadWr
$LN2@FddpReadWr:
  0018b	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  0018e	83 c0 01	 add	 eax, 1
  00191	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN3@FddpReadWr:
  00194	0f b6 45 10	 movzx	 eax, BYTE PTR _NumbersOfSectors$[ebp]
  00198	c1 e0 09	 shl	 eax, 9
  0019b	39 45 f4	 cmp	 DWORD PTR _i$[ebp], eax
  0019e	7d 12		 jge	 SHORT $LN4@FddpReadWr

; 195  : 			*(pData+i) = *(pDMAAddr+i);

  001a0	8b 45 14	 mov	 eax, DWORD PTR _pData$[ebp]
  001a3	03 45 f4	 add	 eax, DWORD PTR _i$[ebp]
  001a6	8b 4d fc	 mov	 ecx, DWORD PTR _pDMAAddr$[ebp]
  001a9	03 4d f4	 add	 ecx, DWORD PTR _i$[ebp]
  001ac	8a 11		 mov	 dl, BYTE PTR [ecx]
  001ae	88 10		 mov	 BYTE PTR [eax], dl

; 196  : 		}

  001b0	eb d9		 jmp	 SHORT $LN2@FddpReadWr
$LN4@FddpReadWr:

; 197  : 	}
; 198  : 
; 199  : 	FddpTurnOffMotor();

  001b2	e8 00 00 00 00	 call	 _FddpTurnOffMotor

; 200  : 
; 201  : 	return TRUE;

  001b7	b8 01 00 00 00	 mov	 eax, 1
$LN14@FddpReadWr:

; 202  : 
; 203  : }

  001bc	5f		 pop	 edi
  001bd	5e		 pop	 esi
  001be	5b		 pop	 ebx
  001bf	8b e5		 mov	 esp, ebp
  001c1	5d		 pop	 ebp
  001c2	c3		 ret	 0
_FddpReadWriteSector ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _FddpTurnOnMotor
_TEXT	SEGMENT
_FddpTurnOnMotor PROC					; COMDAT

; 87   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 88   : 	WRITE_PORT_UCHAR((PUCHAR)FDD_DOR_PORT, 0x1c);

  00009	6a 1c		 push	 28			; 0000001cH
  0000b	68 f2 03 00 00	 push	 1010			; 000003f2H
  00010	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00015	83 c4 08	 add	 esp, 8

; 89   : 	return TRUE;

  00018	b8 01 00 00 00	 mov	 eax, 1

; 90   : }

  0001d	5f		 pop	 edi
  0001e	5e		 pop	 esi
  0001f	5b		 pop	 ebx
  00020	8b e5		 mov	 esp, ebp
  00022	5d		 pop	 ebp
  00023	c3		 ret	 0
_FddpTurnOnMotor ENDP
_TEXT	ENDS
EXTRN	_READ_PORT_UCHAR:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _FddpWriteFdcData
_TEXT	SEGMENT
_status$ = -1						; size = 1
_Data$ = 8						; size = 1
_FddpWriteFdcData PROC					; COMDAT

; 102  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi
$LN3@FddpWriteF:

; 103  : 	UCHAR status;
; 104  : 
; 105  : 	do{
; 106  : 		status = READ_PORT_UCHAR((PUCHAR)FDD_STATUS_PORT);

  00009	68 f4 03 00 00	 push	 1012			; 000003f4H
  0000e	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00013	83 c4 04	 add	 esp, 4
  00016	88 45 ff	 mov	 BYTE PTR _status$[ebp], al

; 107  : 	}while( (status & 0xc0) != 0x80 );

  00019	0f b6 45 ff	 movzx	 eax, BYTE PTR _status$[ebp]
  0001d	25 c0 00 00 00	 and	 eax, 192		; 000000c0H
  00022	3d 80 00 00 00	 cmp	 eax, 128		; 00000080H
  00027	75 e0		 jne	 SHORT $LN3@FddpWriteF

; 108  : 	WRITE_PORT_UCHAR((PUCHAR)FDD_DATA_PORT, Data);

  00029	8a 45 08	 mov	 al, BYTE PTR _Data$[ebp]
  0002c	50		 push	 eax
  0002d	68 f5 03 00 00	 push	 1013			; 000003f5H
  00032	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00037	83 c4 08	 add	 esp, 8

; 109  : 
; 110  : 	return TRUE;

  0003a	b8 01 00 00 00	 mov	 eax, 1

; 111  : }

  0003f	5f		 pop	 edi
  00040	5e		 pop	 esi
  00041	5b		 pop	 ebx
  00042	8b e5		 mov	 esp, ebp
  00044	5d		 pop	 ebp
  00045	c3		 ret	 0
_FddpWriteFdcData ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _FddpSetupDMA
_TEXT	SEGMENT
_count$ = -4						; size = 2
_JobType$ = 8						; size = 4
_FddpSetupDMA PROC					; COMDAT

; 127  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 128  : 	WORD count = BYTES_PER_SECTOR*SECTORS_PER_TRACK-1;

  00009	66 c7 45 fc ff
	23		 mov	 WORD PTR _count$[ebp], 9215 ; 000023ffH

; 129  : 
; 130  : 	if(JobType == FDD_READ_SECTOR){

  0000f	83 7d 08 00	 cmp	 DWORD PTR _JobType$[ebp], 0
  00013	75 0e		 jne	 SHORT $LN2@FddpSetupD

; 131  : 		WRITE_PORT_UCHAR((PUCHAR)0x0b, 0x46);

  00015	6a 46		 push	 70			; 00000046H
  00017	6a 0b		 push	 11			; 0000000bH
  00019	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0001e	83 c4 08	 add	 esp, 8

; 132  : 	}else{

  00021	eb 0c		 jmp	 SHORT $LN1@FddpSetupD
$LN2@FddpSetupD:

; 133  : 		WRITE_PORT_UCHAR((PUCHAR)0x0b,0x4a);

  00023	6a 4a		 push	 74			; 0000004aH
  00025	6a 0b		 push	 11			; 0000000bH
  00027	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0002c	83 c4 08	 add	 esp, 8
$LN1@FddpSetupD:

; 134  : 	}
; 135  : 
; 136  : 	WRITE_PORT_UCHAR((PUCHAR)0x04, 0x00);

  0002f	6a 00		 push	 0
  00031	6a 04		 push	 4
  00033	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00038	83 c4 08	 add	 esp, 8

; 137  : 	WRITE_PORT_UCHAR((PUCHAR)0x04, 0x00);

  0003b	6a 00		 push	 0
  0003d	6a 04		 push	 4
  0003f	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00044	83 c4 08	 add	 esp, 8

; 138  : 	WRITE_PORT_UCHAR((PUCHAR)0x81, 0x00);

  00047	6a 00		 push	 0
  00049	68 81 00 00 00	 push	 129			; 00000081H
  0004e	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00053	83 c4 08	 add	 esp, 8

; 139  : 
; 140  : 	WRITE_PORT_UCHAR((PUCHAR)0x05, (BYTE)count);

  00056	8a 45 fc	 mov	 al, BYTE PTR _count$[ebp]
  00059	50		 push	 eax
  0005a	6a 05		 push	 5
  0005c	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00061	83 c4 08	 add	 esp, 8

; 141  : 	WRITE_PORT_UCHAR((PUCHAR)0x05, (BYTE)(count >> 8));

  00064	0f b7 45 fc	 movzx	 eax, WORD PTR _count$[ebp]
  00068	c1 f8 08	 sar	 eax, 8
  0006b	50		 push	 eax
  0006c	6a 05		 push	 5
  0006e	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00073	83 c4 08	 add	 esp, 8

; 142  : 
; 143  : 	WRITE_PORT_UCHAR((PUCHAR)0x0a, 0x02);

  00076	6a 02		 push	 2
  00078	6a 0a		 push	 10			; 0000000aH
  0007a	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0007f	83 c4 08	 add	 esp, 8

; 144  : 
; 145  : 	return TRUE;

  00082	b8 01 00 00 00	 mov	 eax, 1

; 146  : }

  00087	5f		 pop	 edi
  00088	5e		 pop	 esi
  00089	5b		 pop	 ebx
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c3		 ret	 0
_FddpSetupDMA ENDP
_TEXT	ENDS
_BSS	SEGMENT
_m_JobItemQ DB	01e3H DUP (?)
; Function compile flags: /Odtp /ZI
_BSS	ENDS
;	COMDAT _FddpPopJobItem
_TEXT	SEGMENT
_bResult$ = -4						; size = 4
_pJobItem$ = 8						; size = 4
_FddpPopJobItem PROC					; COMDAT

; 225  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 226  : 	BOOL bResult = TRUE;

  00009	c7 45 fc 01 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 1

; 227  : 
; 228  : ENTER_CRITICAL_SECTION();

  00010	9c		 pushfd
  00011	fa		 cli

; 229  : 	{
; 230  : 		if(m_JobItemQ.cnt == 0){

  00012	0f b6 05 00 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ
  00019	85 c0		 test	 eax, eax
  0001b	75 0c		 jne	 SHORT $LN2@FddpPopJob

; 231  : 			bResult = FALSE;

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _bResult$[ebp], 0

; 232  : 			goto $exit;

  00024	e9 9a 00 00 00	 jmp	 $$exit$910
$LN2@FddpPopJob:

; 233  : 		}
; 234  : 
; 235  : 		m_JobItemQ.cnt--;

  00029	a0 00 00 00 00	 mov	 al, BYTE PTR _m_JobItemQ
  0002e	2c 01		 sub	 al, 1
  00030	a2 00 00 00 00	 mov	 BYTE PTR _m_JobItemQ, al

; 236  : 		pJobItem->type					= m_JobItemQ.queue[m_JobItemQ.head].type;

  00035	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+1
  0003c	6b c0 0f	 imul	 eax, 15			; 0000000fH
  0003f	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  00042	8b 90 03 00 00
	00		 mov	 edx, DWORD PTR _m_JobItemQ[eax+3]
  00048	89 11		 mov	 DWORD PTR [ecx], edx

; 237  : 		pJobItem->sector				= m_JobItemQ.queue[m_JobItemQ.head].sector;

  0004a	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+1
  00051	6b c0 0f	 imul	 eax, 15			; 0000000fH
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  00057	66 8b 90 07 00
	00 00		 mov	 dx, WORD PTR _m_JobItemQ[eax+7]
  0005e	66 89 51 04	 mov	 WORD PTR [ecx+4], dx

; 238  : 		pJobItem->numbers_of_sectors	= m_JobItemQ.queue[m_JobItemQ.head].numbers_of_sectors;

  00062	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+1
  00069	6b c0 0f	 imul	 eax, 15			; 0000000fH
  0006c	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  0006f	8a 90 09 00 00
	00		 mov	 dl, BYTE PTR _m_JobItemQ[eax+9]
  00075	88 51 06	 mov	 BYTE PTR [ecx+6], dl

; 239  : 		pJobItem->pt_data				= m_JobItemQ.queue[m_JobItemQ.head].pt_data;

  00078	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+1
  0007f	6b c0 0f	 imul	 eax, 15			; 0000000fH
  00082	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  00085	8b 90 0a 00 00
	00		 mov	 edx, DWORD PTR _m_JobItemQ[eax+10]
  0008b	89 51 07	 mov	 DWORD PTR [ecx+7], edx

; 240  : 		pJobItem->thread				= m_JobItemQ.queue[m_JobItemQ.head].thread;

  0008e	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+1
  00095	6b c0 0f	 imul	 eax, 15			; 0000000fH
  00098	8b 4d 08	 mov	 ecx, DWORD PTR _pJobItem$[ebp]
  0009b	8b 90 0e 00 00
	00		 mov	 edx, DWORD PTR _m_JobItemQ[eax+14]
  000a1	89 51 0b	 mov	 DWORD PTR [ecx+11], edx

; 241  : 		m_JobItemQ.head++;

  000a4	a0 01 00 00 00	 mov	 al, BYTE PTR _m_JobItemQ+1
  000a9	04 01		 add	 al, 1
  000ab	a2 01 00 00 00	 mov	 BYTE PTR _m_JobItemQ+1, al

; 242  : 		if(m_JobItemQ.head >= FDD_JOB_ITEM_Q_SIZE)

  000b0	0f b6 05 01 00
	00 00		 movzx	 eax, BYTE PTR _m_JobItemQ+1
  000b7	83 f8 20	 cmp	 eax, 32			; 00000020H
  000ba	7c 07		 jl	 SHORT $$exit$910

; 243  : 			m_JobItemQ.head = 0;

  000bc	c6 05 01 00 00
	00 00		 mov	 BYTE PTR _m_JobItemQ+1, 0
$$exit$910:

; 244  : 	}
; 245  : $exit:
; 246  : EXIT_CRITICAL_SECTION();

  000c3	9d		 popfd

; 247  : 	return bResult;

  000c4	8b 45 fc	 mov	 eax, DWORD PTR _bResult$[ebp]

; 248  : }

  000c7	5f		 pop	 edi
  000c8	5e		 pop	 esi
  000c9	5b		 pop	 ebx
  000ca	8b e5		 mov	 esp, ebp
  000cc	5d		 pop	 ebp
  000cd	c3		 ret	 0
_FddpPopJobItem ENDP
_TEXT	ENDS
END
