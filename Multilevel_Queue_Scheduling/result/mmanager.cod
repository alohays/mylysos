; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	c:\Develop\MyoksOS\mmanager.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0CC@MPDKKHPO@Memory?5Manager?5is?5initialized?$CB?$CB?$AN@ ; `string'
PUBLIC	??_C@_0CL@OLLCNKKN@MmpCreateMemPoolBlk?$CI?$CJ?5returned?5a@ ; `string'
PUBLIC	??_C@_0CK@BFFNBLEM@MmpCheckMemorySize?$CI?$CJ?5returned?5an@ ; `string'
PUBLIC	_MmkInitializeMemoryManager
EXTRN	_CrtPrintf:PROC
;	COMDAT ??_C@_0CC@MPDKKHPO@Memory?5Manager?5is?5initialized?$CB?$CB?$AN@
; File c:\develop\myoksos\mmanager.c
CONST	SEGMENT
??_C@_0CC@MPDKKHPO@Memory?5Manager?5is?5initialized?$CB?$CB?$AN@ DB 'Memo'
	DB	'ry Manager is initialized!!', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@OLLCNKKN@MmpCreateMemPoolBlk?$CI?$CJ?5returned?5a@
CONST	SEGMENT
??_C@_0CL@OLLCNKKN@MmpCreateMemPoolBlk?$CI?$CJ?5returned?5a@ DB 'MmpCreat'
	DB	'eMemPoolBlk() returned an error.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@BFFNBLEM@MmpCheckMemorySize?$CI?$CJ?5returned?5an@
CONST	SEGMENT
??_C@_0CK@BFFNBLEM@MmpCheckMemorySize?$CI?$CJ?5returned?5an@ DB 'MmpCheck'
	DB	'MemorySize() returned an error.', 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _MmkInitializeMemoryManager
_TEXT	SEGMENT
_MmkInitializeMemoryManager PROC			; COMDAT

; 116  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 117  : 	if(!MmpCheckMemorySize()){

  00009	e8 00 00 00 00	 call	 _MmpCheckMemorySize
  0000e	85 c0		 test	 eax, eax
  00010	75 11		 jne	 SHORT $LN2@MmkInitial

; 118  : 		DbgPrint("MmpCheckMemorySize() returned an error.\r\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CK@BFFNBLEM@MmpCheckMemorySize?$CI?$CJ?5returned?5an@
  00017	e8 00 00 00 00	 call	 _CrtPrintf
  0001c	83 c4 04	 add	 esp, 4

; 119  : 		return FALSE;

  0001f	33 c0		 xor	 eax, eax
  00021	eb 2c		 jmp	 SHORT $LN3@MmkInitial
$LN2@MmkInitial:

; 120  : 	}
; 121  : 
; 122  : 	if(!MmpCreateMemPoolBlk()){

  00023	e8 00 00 00 00	 call	 _MmpCreateMemPoolBlk
  00028	85 c0		 test	 eax, eax
  0002a	75 11		 jne	 SHORT $LN1@MmkInitial

; 123  : 		DbgPrint("MmpCreateMemPoolBlk() returned an error.\r\n");

  0002c	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@OLLCNKKN@MmpCreateMemPoolBlk?$CI?$CJ?5returned?5a@
  00031	e8 00 00 00 00	 call	 _CrtPrintf
  00036	83 c4 04	 add	 esp, 4

; 124  : 		return FALSE;

  00039	33 c0		 xor	 eax, eax
  0003b	eb 12		 jmp	 SHORT $LN3@MmkInitial
$LN1@MmkInitial:

; 125  : 	}
; 126  : 
; 127  : 	DbgPrint("Memory Manager is initialized!!\r\n");

  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_0CC@MPDKKHPO@Memory?5Manager?5is?5initialized?$CB?$CB?$AN@
  00042	e8 00 00 00 00	 call	 _CrtPrintf
  00047	83 c4 04	 add	 esp, 4

; 128  : 	return TRUE;

  0004a	b8 01 00 00 00	 mov	 eax, 1
$LN3@MmkInitial:

; 129  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	8b e5		 mov	 esp, ebp
  00054	5d		 pop	 ebp
  00055	c3		 ret	 0
_MmkInitializeMemoryManager ENDP
_TEXT	ENDS
_BSS	SEGMENT
_m_MemSize DD	01H DUP (?)
; Function compile flags: /Odtp /ZI
_BSS	ENDS
;	COMDAT _MmpCheckMemorySize
_TEXT	SEGMENT
_tmp$ = -12						; size = 4
_pAddr$ = -8						; size = 4
_bResult$ = -4						; size = 4
_MmpCheckMemorySize PROC				; COMDAT

; 35   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 36   : 	BOOL bResult;
; 37   : 	DWORD *pAddr = (DWORD *)0x00000000, tmp;

  00009	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _pAddr$[ebp], 0
$LN3@MmpCheckMe:

; 38   : 
; 39   : 	while(1){

  00010	b8 01 00 00 00	 mov	 eax, 1
  00015	85 c0		 test	 eax, eax
  00017	74 33		 je	 SHORT $LN2@MmpCheckMe

; 40   : 		pAddr += (4*1024*1024);

  00019	8b 45 f8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  0001c	05 00 00 00 01	 add	 eax, 16777216		; 01000000H
  00021	89 45 f8	 mov	 DWORD PTR _pAddr$[ebp], eax

; 41   : 		tmp = *pAddr;

  00024	8b 45 f8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  00027	8b 08		 mov	 ecx, DWORD PTR [eax]
  00029	89 4d f4	 mov	 DWORD PTR _tmp$[ebp], ecx

; 42   : 		*pAddr = 0x11223344;

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  0002f	c7 00 44 33 22
	11		 mov	 DWORD PTR [eax], 287454020 ; 11223344H

; 43   : 
; 44   : 		if(*pAddr != 0x11223344)

  00035	8b 45 f8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  00038	81 38 44 33 22
	11		 cmp	 DWORD PTR [eax], 287454020 ; 11223344H
  0003e	74 02		 je	 SHORT $LN1@MmpCheckMe

; 45   : 			break;

  00040	eb 0a		 jmp	 SHORT $LN2@MmpCheckMe
$LN1@MmpCheckMe:

; 46   : 
; 47   : 		*pAddr = tmp;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  00045	8b 4d f4	 mov	 ecx, DWORD PTR _tmp$[ebp]
  00048	89 08		 mov	 DWORD PTR [eax], ecx

; 48   : 	}

  0004a	eb c4		 jmp	 SHORT $LN3@MmpCheckMe
$LN2@MmpCheckMe:

; 49   : 
; 50   : ENTER_CRITICAL_SECTION();

  0004c	9c		 pushfd
  0004d	fa		 cli

; 51   : 	m_MemSize = (DWORD)pAddr;

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _pAddr$[ebp]
  00051	a3 00 00 00 00	 mov	 DWORD PTR _m_MemSize, eax

; 52   : 	bResult = (m_MemSize < MEMORY_POOL_START_ADDRESS+(1*1024*1024) ? FALSE : TRUE);

  00056	81 3d 00 00 00
	00 00 00 30 00	 cmp	 DWORD PTR _m_MemSize, 3145728 ; 00300000H
  00060	1b c0		 sbb	 eax, eax
  00062	83 c0 01	 add	 eax, 1
  00065	89 45 fc	 mov	 DWORD PTR _bResult$[ebp], eax

; 53   : EXIT_CRITICAL_SECTION();

  00068	9d		 popfd

; 54   : 
; 55   : 	return bResult;

  00069	8b 45 fc	 mov	 eax, DWORD PTR _bResult$[ebp]

; 56   : }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_MmpCheckMemorySize ENDP
_TEXT	ENDS
_BSS	SEGMENT
_m_MemBlkManager DB 014H DUP (?)
; Function compile flags: /Odtp /ZI
_BSS	ENDS
;	COMDAT _MmpCreateMemPoolBlk
_TEXT	SEGMENT
_pCur$ = -32						; size = 4
_pPrev$ = -28						; size = 4
_pPoolEntry$ = -24					; size = 4
_i$ = -20						; size = 4
_dwBlksOfDescs$ = -16					; size = 4
_dwBlksOfAllocatableMem$ = -12				; size = 4
_dwBlksOfUsableMem$ = -8				; size = 4
_dwUsableMemSize$ = -4					; size = 4
_MmpCreateMemPoolBlk PROC				; COMDAT

; 60   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 60	 sub	 esp, 96			; 00000060H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 61   : 	DWORD dwUsableMemSize;
; 62   : 	DWORD dwBlksOfUsableMem;
; 63   : 	DWORD dwBlksOfAllocatableMem;
; 64   : 	DWORD dwBlksOfDescs;
; 65   : 	DWORD i;
; 66   : 
; 67   : 	int *pPoolEntry;
; 68   : 	MEM_BLK_DESC *pPrev, *pCur;
; 69   : 
; 70   : ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 71   : 	dwUsableMemSize = m_MemSize - MEMORY_POOL_START_ADDRESS;

  0000b	a1 00 00 00 00	 mov	 eax, DWORD PTR _m_MemSize
  00010	2d 00 00 20 00	 sub	 eax, 2097152		; 00200000H
  00015	89 45 fc	 mov	 DWORD PTR _dwUsableMemSize$[ebp], eax

; 72   : EXIT_CRITICAL_SECTION();

  00018	9d		 popfd

; 73   : 
; 74   : 	dwBlksOfUsableMem		= MmpGetRequiredBlocksFromBytes(dwUsableMemSize);

  00019	8b 45 fc	 mov	 eax, DWORD PTR _dwUsableMemSize$[ebp]
  0001c	50		 push	 eax
  0001d	e8 00 00 00 00	 call	 _MmpGetRequiredBlocksFromBytes
  00022	83 c4 04	 add	 esp, 4
  00025	89 45 f8	 mov	 DWORD PTR _dwBlksOfUsableMem$[ebp], eax

; 75   : 	dwBlksOfDescs			= MmpGetRequiredBlocksFromBytes(dwBlksOfUsableMem*sizeof(MEM_BLK_DESC));

  00028	8b 45 f8	 mov	 eax, DWORD PTR _dwBlksOfUsableMem$[ebp]
  0002b	6b c0 0c	 imul	 eax, 12			; 0000000cH
  0002e	50		 push	 eax
  0002f	e8 00 00 00 00	 call	 _MmpGetRequiredBlocksFromBytes
  00034	83 c4 04	 add	 esp, 4
  00037	89 45 f0	 mov	 DWORD PTR _dwBlksOfDescs$[ebp], eax

; 76   : 	dwBlksOfAllocatableMem	= dwBlksOfUsableMem-dwBlksOfDescs;

  0003a	8b 45 f8	 mov	 eax, DWORD PTR _dwBlksOfUsableMem$[ebp]
  0003d	2b 45 f0	 sub	 eax, DWORD PTR _dwBlksOfDescs$[ebp]
  00040	89 45 f4	 mov	 DWORD PTR _dwBlksOfAllocatableMem$[ebp], eax

; 77   : 	dwBlksOfDescs			= MmpGetRequiredBlocksFromBytes(dwBlksOfAllocatableMem*sizeof(MEM_BLK_DESC));

  00043	8b 45 f4	 mov	 eax, DWORD PTR _dwBlksOfAllocatableMem$[ebp]
  00046	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00049	50		 push	 eax
  0004a	e8 00 00 00 00	 call	 _MmpGetRequiredBlocksFromBytes
  0004f	83 c4 04	 add	 esp, 4
  00052	89 45 f0	 mov	 DWORD PTR _dwBlksOfDescs$[ebp], eax

; 78   : 
; 79   : 	pPoolEntry				= (int *)(MEMORY_POOL_START_ADDRESS+dwBlksOfDescs*MEM_BLK_SIZE);

  00055	8b 45 f0	 mov	 eax, DWORD PTR _dwBlksOfDescs$[ebp]
  00058	c1 e0 09	 shl	 eax, 9
  0005b	05 00 00 20 00	 add	 eax, 2097152		; 00200000H
  00060	89 45 e8	 mov	 DWORD PTR _pPoolEntry$[ebp], eax

; 80   : 
; 81   : ENTER_CRITICAL_SECTION();

  00063	9c		 pushfd
  00064	fa		 cli

; 82   : 	m_MemBlkManager.nBlocks		= dwBlksOfAllocatableMem;

  00065	8b 45 f4	 mov	 eax, DWORD PTR _dwBlksOfAllocatableMem$[ebp]
  00068	a3 00 00 00 00	 mov	 DWORD PTR _m_MemBlkManager, eax

; 83   : 	m_MemBlkManager.nUsedBlocks	= 0;

  0006d	c7 05 04 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_MemBlkManager+4, 0

; 84   : 	m_MemBlkManager.nFreeBlocks = dwBlksOfAllocatableMem;

  00077	8b 45 f4	 mov	 eax, DWORD PTR _dwBlksOfAllocatableMem$[ebp]
  0007a	a3 08 00 00 00	 mov	 DWORD PTR _m_MemBlkManager+8, eax

; 85   : 	m_MemBlkManager.pDescEntry	= (MEM_BLK_DESC *)MEMORY_POOL_START_ADDRESS;

  0007f	c7 05 0c 00 00
	00 00 00 20 00	 mov	 DWORD PTR _m_MemBlkManager+12, 2097152 ; 00200000H

; 86   : 	m_MemBlkManager.pPoolEntry	= pPoolEntry;

  00089	8b 45 e8	 mov	 eax, DWORD PTR _pPoolEntry$[ebp]
  0008c	a3 10 00 00 00	 mov	 DWORD PTR _m_MemBlkManager+16, eax

; 87   : 
; 88   : 	pPrev = m_MemBlkManager.pDescEntry;

  00091	a1 0c 00 00 00	 mov	 eax, DWORD PTR _m_MemBlkManager+12
  00096	89 45 e4	 mov	 DWORD PTR _pPrev$[ebp], eax

; 89   : 	pPrev->status = MEM_BLK_FREE;

  00099	8b 45 e4	 mov	 eax, DWORD PTR _pPrev$[ebp]
  0009c	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 90   : 
; 91   : 	for(i=1; i<dwBlksOfAllocatableMem; i++){

  000a2	c7 45 ec 01 00
	00 00		 mov	 DWORD PTR _i$[ebp], 1
  000a9	eb 09		 jmp	 SHORT $LN3@MmpCreateM
$LN2@MmpCreateM:
  000ab	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000ae	83 c0 01	 add	 eax, 1
  000b1	89 45 ec	 mov	 DWORD PTR _i$[ebp], eax
$LN3@MmpCreateM:
  000b4	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000b7	3b 45 f4	 cmp	 eax, DWORD PTR _dwBlksOfAllocatableMem$[ebp]
  000ba	73 32		 jae	 SHORT $LN1@MmpCreateM

; 92   : 		pCur = (MEM_BLK_DESC *)(MEMORY_POOL_START_ADDRESS+sizeof(MEM_BLK_DESC)*i);

  000bc	8b 45 ec	 mov	 eax, DWORD PTR _i$[ebp]
  000bf	6b c0 0c	 imul	 eax, 12			; 0000000cH
  000c2	05 00 00 20 00	 add	 eax, 2097152		; 00200000H
  000c7	89 45 e0	 mov	 DWORD PTR _pCur$[ebp], eax

; 93   : 		pCur->status = MEM_BLK_FREE;

  000ca	8b 45 e0	 mov	 eax, DWORD PTR _pCur$[ebp]
  000cd	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 94   : 		pCur->block_size = 0;

  000d3	8b 45 e0	 mov	 eax, DWORD PTR _pCur$[ebp]
  000d6	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 95   : 		pPrev->pNext = pCur;

  000dd	8b 45 e4	 mov	 eax, DWORD PTR _pPrev$[ebp]
  000e0	8b 4d e0	 mov	 ecx, DWORD PTR _pCur$[ebp]
  000e3	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 96   : 		pPrev = pCur;

  000e6	8b 45 e0	 mov	 eax, DWORD PTR _pCur$[ebp]
  000e9	89 45 e4	 mov	 DWORD PTR _pPrev$[ebp], eax

; 97   : 	}

  000ec	eb bd		 jmp	 SHORT $LN2@MmpCreateM
$LN1@MmpCreateM:

; 98   : 	pCur->pNext = NULL;

  000ee	8b 45 e0	 mov	 eax, DWORD PTR _pCur$[ebp]
  000f1	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 99   : EXIT_CRITICAL_SECTION();

  000f8	9d		 popfd

; 100  : 
; 101  : 	return TRUE;

  000f9	b8 01 00 00 00	 mov	 eax, 1

; 102  : }

  000fe	5f		 pop	 edi
  000ff	5e		 pop	 esi
  00100	5b		 pop	 ebx
  00101	8b e5		 mov	 esp, ebp
  00103	5d		 pop	 ebp
  00104	c3		 ret	 0
_MmpCreateMemPoolBlk ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _MmpGetRequiredBlocksFromBytes
_TEXT	SEGMENT
_dwBlocks$ = -4						; size = 4
_bytes$ = 8						; size = 4
_MmpGetRequiredBlocksFromBytes PROC			; COMDAT

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 106  : 	DWORD dwBlocks = 0;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _dwBlocks$[ebp], 0

; 107  : 
; 108  : 	dwBlocks = bytes/MEM_BLK_SIZE;

  00010	8b 45 08	 mov	 eax, DWORD PTR _bytes$[ebp]
  00013	c1 e8 09	 shr	 eax, 9
  00016	89 45 fc	 mov	 DWORD PTR _dwBlocks$[ebp], eax

; 109  : 	if(bytes % MEM_BLK_SIZE)

  00019	8b 45 08	 mov	 eax, DWORD PTR _bytes$[ebp]
  0001c	33 d2		 xor	 edx, edx
  0001e	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00023	f7 f1		 div	 ecx
  00025	85 d2		 test	 edx, edx
  00027	74 09		 je	 SHORT $LN1@MmpGetRequ

; 110  : 		dwBlocks++;

  00029	8b 45 fc	 mov	 eax, DWORD PTR _dwBlocks$[ebp]
  0002c	83 c0 01	 add	 eax, 1
  0002f	89 45 fc	 mov	 DWORD PTR _dwBlocks$[ebp], eax
$LN1@MmpGetRequ:

; 111  : 
; 112  : 	return dwBlocks;

  00032	8b 45 fc	 mov	 eax, DWORD PTR _dwBlocks$[ebp]

; 113  : }

  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
_MmpGetRequiredBlocksFromBytes ENDP
_TEXT	ENDS
PUBLIC	_MmAllocateNonCachedMemory
; Function compile flags: /Odtp /ZI
;	COMDAT _MmAllocateNonCachedMemory
_TEXT	SEGMENT
_pCur$ = -20						; size = 4
_pAllocStart$ = -16					; size = 4
_i$ = -12						; size = 4
_dwCurBlocks$ = -8					; size = 4
_dwRequiredBlocks$ = -4					; size = 4
_NumberOfBytes$ = 8					; size = 4
_MmAllocateNonCachedMemory PROC				; COMDAT

; 133  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 134  : 	DWORD dwRequiredBlocks, dwCurBlocks, i;
; 135  : 	MEM_BLK_DESC *pAllocStart, *pCur;
; 136  : 	// 요청된 바이트가 0이면 null 리턴
; 137  : 	if(NumberOfBytes == 0)

  00009	83 7d 08 00	 cmp	 DWORD PTR _NumberOfBytes$[ebp], 0
  0000d	75 07		 jne	 SHORT $LN9@MmAllocate

; 138  : 		return (VOID *)NULL;

  0000f	33 c0		 xor	 eax, eax
  00011	e9 f5 00 00 00	 jmp	 $LN10@MmAllocate
$LN9@MmAllocate:

; 139  : 	//요청된 바이트들을 block단위로 변경
; 140  : 	//할당받은 block이 부족할 경우 null리턴
; 141  : 	dwRequiredBlocks = MmpGetRequiredBlocksFromBytes(NumberOfBytes);

  00016	8b 45 08	 mov	 eax, DWORD PTR _NumberOfBytes$[ebp]
  00019	50		 push	 eax
  0001a	e8 00 00 00 00	 call	 _MmpGetRequiredBlocksFromBytes
  0001f	83 c4 04	 add	 esp, 4
  00022	89 45 fc	 mov	 DWORD PTR _dwRequiredBlocks$[ebp], eax

; 142  : ENTER_CRITICAL_SECTION();

  00025	9c		 pushfd
  00026	fa		 cli

; 143  : 	if(m_MemBlkManager.nFreeBlocks < dwRequiredBlocks){

  00027	a1 08 00 00 00	 mov	 eax, DWORD PTR _m_MemBlkManager+8
  0002c	3b 45 fc	 cmp	 eax, DWORD PTR _dwRequiredBlocks$[ebp]
  0002f	73 08		 jae	 SHORT $LN8@MmAllocate

; 144  : 		EXIT_CRITICAL_SECTION();

  00031	9d		 popfd

; 145  : 		return (VOID *)NULL;

  00032	33 c0		 xor	 eax, eax
  00034	e9 d2 00 00 00	 jmp	 $LN10@MmAllocate
$LN8@MmAllocate:

; 146  : 	}
; 147  : 
; 148  : 	//메모리 디스크립터 리스트를 검색하여 할당 가능한 공간을 찾는다
; 149  : 	pAllocStart = pCur = m_MemBlkManager.pDescEntry;

  00039	a1 0c 00 00 00	 mov	 eax, DWORD PTR _m_MemBlkManager+12
  0003e	89 45 ec	 mov	 DWORD PTR _pCur$[ebp], eax
  00041	8b 4d ec	 mov	 ecx, DWORD PTR _pCur$[ebp]
  00044	89 4d f0	 mov	 DWORD PTR _pAllocStart$[ebp], ecx

; 150  : 	dwCurBlocks = 0;

  00047	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwCurBlocks$[ebp], 0
$LN7@MmAllocate:

; 151  : 	while(dwCurBlocks < dwRequiredBlocks){

  0004e	8b 45 f8	 mov	 eax, DWORD PTR _dwCurBlocks$[ebp]
  00051	3b 45 fc	 cmp	 eax, DWORD PTR _dwRequiredBlocks$[ebp]
  00054	73 4b		 jae	 SHORT $LN6@MmAllocate

; 152  : 		if(pCur->pNext == NULL){

  00056	8b 45 ec	 mov	 eax, DWORD PTR _pCur$[ebp]
  00059	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0005d	75 08		 jne	 SHORT $LN5@MmAllocate

; 153  : 			EXIT_CRITICAL_SECTION();

  0005f	9d		 popfd

; 154  : 			return (VOID *)NULL;

  00060	33 c0		 xor	 eax, eax
  00062	e9 a4 00 00 00	 jmp	 $LN10@MmAllocate
$LN5@MmAllocate:

; 155  : 		}
; 156  : 
; 157  : 		if(pCur->status == MEM_BLK_USED){

  00067	8b 45 ec	 mov	 eax, DWORD PTR _pCur$[ebp]
  0006a	83 38 01	 cmp	 DWORD PTR [eax], 1
  0006d	75 1e		 jne	 SHORT $LN4@MmAllocate

; 158  : 			dwCurBlocks = 0;

  0006f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _dwCurBlocks$[ebp], 0

; 159  : 			pAllocStart = pCur = pCur+pCur->block_size;

  00076	8b 45 ec	 mov	 eax, DWORD PTR _pCur$[ebp]
  00079	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0007c	6b c9 0c	 imul	 ecx, 12			; 0000000cH
  0007f	03 4d ec	 add	 ecx, DWORD PTR _pCur$[ebp]
  00082	89 4d ec	 mov	 DWORD PTR _pCur$[ebp], ecx
  00085	8b 55 ec	 mov	 edx, DWORD PTR _pCur$[ebp]
  00088	89 55 f0	 mov	 DWORD PTR _pAllocStart$[ebp], edx

; 160  : 			continue;

  0008b	eb c1		 jmp	 SHORT $LN7@MmAllocate
$LN4@MmAllocate:

; 161  : 		}
; 162  : 
; 163  : 		dwCurBlocks++;

  0008d	8b 45 f8	 mov	 eax, DWORD PTR _dwCurBlocks$[ebp]
  00090	83 c0 01	 add	 eax, 1
  00093	89 45 f8	 mov	 DWORD PTR _dwCurBlocks$[ebp], eax

; 164  : 		pCur = pCur->pNext;

  00096	8b 45 ec	 mov	 eax, DWORD PTR _pCur$[ebp]
  00099	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0009c	89 4d ec	 mov	 DWORD PTR _pCur$[ebp], ecx

; 165  : 	}

  0009f	eb ad		 jmp	 SHORT $LN7@MmAllocate
$LN6@MmAllocate:

; 166  : 
; 167  : 	// 할당가능한 공간 찾은 후, 해당 블록의 상태를 used로 변경
; 168  : 	pCur = pAllocStart;

  000a1	8b 45 f0	 mov	 eax, DWORD PTR _pAllocStart$[ebp]
  000a4	89 45 ec	 mov	 DWORD PTR _pCur$[ebp], eax

; 169  : 	for(i=0; i<dwRequiredBlocks; i++){

  000a7	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  000ae	eb 09		 jmp	 SHORT $LN3@MmAllocate
$LN2@MmAllocate:
  000b0	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000b3	83 c0 01	 add	 eax, 1
  000b6	89 45 f4	 mov	 DWORD PTR _i$[ebp], eax
$LN3@MmAllocate:
  000b9	8b 45 f4	 mov	 eax, DWORD PTR _i$[ebp]
  000bc	3b 45 fc	 cmp	 eax, DWORD PTR _dwRequiredBlocks$[ebp]
  000bf	73 14		 jae	 SHORT $LN1@MmAllocate

; 170  : 		pCur->status = MEM_BLK_USED;

  000c1	8b 45 ec	 mov	 eax, DWORD PTR _pCur$[ebp]
  000c4	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 171  : 		pCur = pCur->pNext;

  000ca	8b 45 ec	 mov	 eax, DWORD PTR _pCur$[ebp]
  000cd	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  000d0	89 4d ec	 mov	 DWORD PTR _pCur$[ebp], ecx

; 172  : 	}

  000d3	eb db		 jmp	 SHORT $LN2@MmAllocate
$LN1@MmAllocate:

; 173  : 	pAllocStart->block_size = dwRequiredBlocks;

  000d5	8b 45 f0	 mov	 eax, DWORD PTR _pAllocStart$[ebp]
  000d8	8b 4d fc	 mov	 ecx, DWORD PTR _dwRequiredBlocks$[ebp]
  000db	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 174  : 
; 175  : 	m_MemBlkManager.nFreeBlocks -= dwRequiredBlocks;

  000de	a1 08 00 00 00	 mov	 eax, DWORD PTR _m_MemBlkManager+8
  000e3	2b 45 fc	 sub	 eax, DWORD PTR _dwRequiredBlocks$[ebp]
  000e6	a3 08 00 00 00	 mov	 DWORD PTR _m_MemBlkManager+8, eax

; 176  : 	m_MemBlkManager.nUsedBlocks -= dwRequiredBlocks;

  000eb	a1 04 00 00 00	 mov	 eax, DWORD PTR _m_MemBlkManager+4
  000f0	2b 45 fc	 sub	 eax, DWORD PTR _dwRequiredBlocks$[ebp]
  000f3	a3 04 00 00 00	 mov	 DWORD PTR _m_MemBlkManager+4, eax

; 177  : 
; 178  : 	// 할당된 메모리 블록의 실제 주소를 받아온다.
; 179  : 	pAllocStart = (MEM_BLK_DESC *)MmpGetPoolAddrFromDescAddr(pAllocStart);

  000f8	8b 45 f0	 mov	 eax, DWORD PTR _pAllocStart$[ebp]
  000fb	50		 push	 eax
  000fc	e8 00 00 00 00	 call	 _MmpGetPoolAddrFromDescAddr
  00101	83 c4 04	 add	 esp, 4
  00104	89 45 f0	 mov	 DWORD PTR _pAllocStart$[ebp], eax

; 180  : EXIT_CRITICAL_SECTION();

  00107	9d		 popfd

; 181  : 
; 182  : 	return (VOID *)pAllocStart;

  00108	8b 45 f0	 mov	 eax, DWORD PTR _pAllocStart$[ebp]
$LN10@MmAllocate:

; 183  : }

  0010b	5f		 pop	 edi
  0010c	5e		 pop	 esi
  0010d	5b		 pop	 ebx
  0010e	8b e5		 mov	 esp, ebp
  00110	5d		 pop	 ebp
  00111	c3		 ret	 0
_MmAllocateNonCachedMemory ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _MmpGetPoolAddrFromDescAddr
_TEXT	SEGMENT
_ResultAddr$ = -4					; size = 4
_pDescAddr$ = 8						; size = 4
_MmpGetPoolAddrFromDescAddr PROC			; COMDAT

; 187  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 188  : 	int ResultAddr;
; 189  : 
; 190  : ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 191  : 	//메모리 풀에서 메모리 블록의 시작주소를 가지고 온다
; 192  : 	ResultAddr = (int)(m_MemBlkManager.pPoolEntry);

  0000b	a1 10 00 00 00	 mov	 eax, DWORD PTR _m_MemBlkManager+16
  00010	89 45 fc	 mov	 DWORD PTR _ResultAddr$[ebp], eax

; 193  : 	//할당된 메모리 블록의 실제 주소를 가지고 온다.
; 194  : 	ResultAddr += (int)((pDescAddr-m_MemBlkManager.pDescEntry)*MEM_BLK_SIZE);

  00013	8b 45 08	 mov	 eax, DWORD PTR _pDescAddr$[ebp]
  00016	2b 05 0c 00 00
	00		 sub	 eax, DWORD PTR _m_MemBlkManager+12
  0001c	99		 cdq
  0001d	b9 0c 00 00 00	 mov	 ecx, 12			; 0000000cH
  00022	f7 f9		 idiv	 ecx
  00024	c1 e0 09	 shl	 eax, 9
  00027	03 45 fc	 add	 eax, DWORD PTR _ResultAddr$[ebp]
  0002a	89 45 fc	 mov	 DWORD PTR _ResultAddr$[ebp], eax

; 195  : EXIT_CRITICAL_SECTION();

  0002d	9d		 popfd

; 196  : 
; 197  : 	return (VOID *)ResultAddr;

  0002e	8b 45 fc	 mov	 eax, DWORD PTR _ResultAddr$[ebp]

; 198  : }

  00031	5f		 pop	 edi
  00032	5e		 pop	 esi
  00033	5b		 pop	 ebx
  00034	8b e5		 mov	 esp, ebp
  00036	5d		 pop	 ebp
  00037	c3		 ret	 0
_MmpGetPoolAddrFromDescAddr ENDP
_TEXT	ENDS
PUBLIC	_MmFreeNonCachedMemory
; Function compile flags: /Odtp /ZI
;	COMDAT _MmFreeNonCachedMemory
_TEXT	SEGMENT
_dwBlockSize$ = -12					; size = 4
_i$ = -8						; size = 4
_pCur$ = -4						; size = 4
_BaseAddress$ = 8					; size = 4
_MmFreeNonCachedMemory PROC				; COMDAT

; 202  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 4c	 sub	 esp, 76			; 0000004cH
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 203  : 	MEM_BLK_DESC *pCur;
; 204  : 	DWORD i, dwBlockSize;
; 205  : 	if(BaseAddress == NULL)

  00009	83 7d 08 00	 cmp	 DWORD PTR _BaseAddress$[ebp], 0
  0000d	75 02		 jne	 SHORT $LN5@MmFreeNonC

; 206  : 		return;

  0000f	eb 78		 jmp	 SHORT $LN6@MmFreeNonC
$LN5@MmFreeNonC:

; 207  : 	// 해제하고자 하는 메모리 블럭의 디스크립터 리스트를 검색
; 208  : 	pCur = (MEM_BLK_DESC *)MmpGetDescAddrFromPoolAddr(BaseAddress);

  00011	8b 45 08	 mov	 eax, DWORD PTR _BaseAddress$[ebp]
  00014	50		 push	 eax
  00015	e8 00 00 00 00	 call	 _MmpGetDescAddrFromPoolAddr
  0001a	83 c4 04	 add	 esp, 4
  0001d	89 45 fc	 mov	 DWORD PTR _pCur$[ebp], eax

; 209  : ENTER_CRITICAL_SECTION();

  00020	9c		 pushfd
  00021	fa		 cli

; 210  : 	if(pCur->status != MEM_BLK_USED){

  00022	8b 45 fc	 mov	 eax, DWORD PTR _pCur$[ebp]
  00025	83 38 01	 cmp	 DWORD PTR [eax], 1
  00028	74 03		 je	 SHORT $LN4@MmFreeNonC

; 211  : 		EXIT_CRITICAL_SECTION();

  0002a	9d		 popfd

; 212  : 		return;

  0002b	eb 5c		 jmp	 SHORT $LN6@MmFreeNonC
$LN4@MmFreeNonC:

; 213  : 	}
; 214  : 	//검색후, 해제하고자 하는 블록의 상태를 free로 변경
; 215  : 	dwBlockSize = pCur->block_size;

  0002d	8b 45 fc	 mov	 eax, DWORD PTR _pCur$[ebp]
  00030	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00033	89 4d f4	 mov	 DWORD PTR _dwBlockSize$[ebp], ecx

; 216  : 	for(i=0; i<dwBlockSize; i++){

  00036	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  0003d	eb 09		 jmp	 SHORT $LN3@MmFreeNonC
$LN2@MmFreeNonC:
  0003f	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  00042	83 c0 01	 add	 eax, 1
  00045	89 45 f8	 mov	 DWORD PTR _i$[ebp], eax
$LN3@MmFreeNonC:
  00048	8b 45 f8	 mov	 eax, DWORD PTR _i$[ebp]
  0004b	3b 45 f4	 cmp	 eax, DWORD PTR _dwBlockSize$[ebp]
  0004e	73 1e		 jae	 SHORT $LN1@MmFreeNonC

; 217  : 		pCur->status = MEM_BLK_FREE;

  00050	8b 45 fc	 mov	 eax, DWORD PTR _pCur$[ebp]
  00053	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 218  : 		pCur->block_size = 0;

  00059	8b 45 fc	 mov	 eax, DWORD PTR _pCur$[ebp]
  0005c	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 219  : 		pCur = pCur->pNext;

  00063	8b 45 fc	 mov	 eax, DWORD PTR _pCur$[ebp]
  00066	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00069	89 4d fc	 mov	 DWORD PTR _pCur$[ebp], ecx

; 220  : 	}

  0006c	eb d1		 jmp	 SHORT $LN2@MmFreeNonC
$LN1@MmFreeNonC:

; 221  : 
; 222  : 	m_MemBlkManager.nFreeBlocks += dwBlockSize;

  0006e	a1 08 00 00 00	 mov	 eax, DWORD PTR _m_MemBlkManager+8
  00073	03 45 f4	 add	 eax, DWORD PTR _dwBlockSize$[ebp]
  00076	a3 08 00 00 00	 mov	 DWORD PTR _m_MemBlkManager+8, eax

; 223  : 	m_MemBlkManager.nUsedBlocks -= dwBlockSize;

  0007b	a1 04 00 00 00	 mov	 eax, DWORD PTR _m_MemBlkManager+4
  00080	2b 45 f4	 sub	 eax, DWORD PTR _dwBlockSize$[ebp]
  00083	a3 04 00 00 00	 mov	 DWORD PTR _m_MemBlkManager+4, eax

; 224  : 
; 225  : EXIT_CRITICAL_SECTION();

  00088	9d		 popfd
$LN6@MmFreeNonC:

; 226  : }

  00089	5f		 pop	 edi
  0008a	5e		 pop	 esi
  0008b	5b		 pop	 ebx
  0008c	8b e5		 mov	 esp, ebp
  0008e	5d		 pop	 ebp
  0008f	c3		 ret	 0
_MmFreeNonCachedMemory ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _MmpGetDescAddrFromPoolAddr
_TEXT	SEGMENT
_ResultAddr$ = -4					; size = 4
_pPoolAddr$ = 8						; size = 4
_MmpGetDescAddrFromPoolAddr PROC			; COMDAT

; 230  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 231  : 	int ResultAddr;
; 232  : 
; 233  : ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 234  : 	// 실제 메모리 블록 주소에서 메모리 풀에서 메모리풀 시작 주소를 뺀 값
; 235  : 	ResultAddr = (int)pPoolAddr-(int)(m_MemBlkManager.pPoolEntry);

  0000b	8b 45 08	 mov	 eax, DWORD PTR _pPoolAddr$[ebp]
  0000e	2b 05 10 00 00
	00		 sub	 eax, DWORD PTR _m_MemBlkManager+16
  00014	89 45 fc	 mov	 DWORD PTR _ResultAddr$[ebp], eax

; 236  : 	// 블록 단위로 나누고, 해당 메모리 디스크립터를 찾는다.
; 237  : 	ResultAddr = ResultAddr/MEM_BLK_SIZE*sizeof(MEM_BLK_DESC);

  00017	8b 45 fc	 mov	 eax, DWORD PTR _ResultAddr$[ebp]
  0001a	99		 cdq
  0001b	81 e2 ff 01 00
	00		 and	 edx, 511		; 000001ffH
  00021	03 c2		 add	 eax, edx
  00023	c1 f8 09	 sar	 eax, 9
  00026	6b c0 0c	 imul	 eax, 12			; 0000000cH
  00029	89 45 fc	 mov	 DWORD PTR _ResultAddr$[ebp], eax

; 238  : 	ResultAddr += (int)(m_MemBlkManager.pDescEntry);

  0002c	8b 45 fc	 mov	 eax, DWORD PTR _ResultAddr$[ebp]
  0002f	03 05 0c 00 00
	00		 add	 eax, DWORD PTR _m_MemBlkManager+12
  00035	89 45 fc	 mov	 DWORD PTR _ResultAddr$[ebp], eax

; 239  : EXIT_CRITICAL_SECTION();

  00038	9d		 popfd

; 240  : 
; 241  : 	return (MEM_BLK_DESC *)ResultAddr;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _ResultAddr$[ebp]

; 242  : }

  0003c	5f		 pop	 edi
  0003d	5e		 pop	 esi
  0003e	5b		 pop	 ebx
  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c3		 ret	 0
_MmpGetDescAddrFromPoolAddr ENDP
_TEXT	ENDS
END
