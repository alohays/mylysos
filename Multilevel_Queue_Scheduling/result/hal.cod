; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.42 

	TITLE	c:\Develop\MyoksOS\hal.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BI@NMHEANFH@Halp_IRQ_HardDrive?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BO@DKPJFPAC@Halp_IRQ_MathCoprocessor?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BE@NEDDPGBJ@Halp_IRQ_Mouse?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@IGOLJKOG@Halp_IRQ_VGA?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BI@MCNHIJMG@Halp_IRQ_CMOSClock?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@BMGLEMCE@Halp_IRQ_LPT1?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@CNIDFGLJ@Halp_IRQ_LPT2?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@PNONLAAJ@Halp_IRQ_COM1?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@MMAFKKJE@Halp_IRQ_COM2?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BP@BPMNCKPI@Halp_IRQ_ReqFromSlave8259?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@NHEAFIGN@Halp_ECT_MachineCheck?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@IIPPLJCI@Halp_ECT_AlignmentCheck?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@BAMOPHKE@Halp_ECT_FloatingPointError?$CI?$CJ?5?$AN?6@ ; `string'
PUBLIC	??_C@_0BI@ECFHJJPN@Halp_ECT_PageFault?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@BNNEHHMP@Halp_ECT_GeneralProtection?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@IPDIOMJP@Halp_ECT_StackException?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CA@NKBGCIFH@Halp_ECT_SegmentNotPresent?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@PELGBAAP@Halp_ECT_InvalidTSS?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CB@KDIHIBHF@Halp_ECT_CoprocessorOverrun?$CI?$CJ?5?$AN?6@ ; `string'
PUBLIC	??_C@_0CB@LIGLLFBG@Halp_ECT_DeviceNotAvailable?$CI?$CJ?5?$AN?6@ ; `string'
PUBLIC	??_C@_0BM@EDOCEHEB@Halp_ECT_InvaildOpcode?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BF@GOILIIOG@Halp_ECT_BOUNDS?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BD@PJNACMJH@Halp_ECT_INTO?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BJ@CHEGJKKD@Halp_ECT_Breakpoint?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@EPIMJMAK@Halp_ECT_NMI?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BN@LHNLHKKE@Halp_ECT_DebugException?$CI?$CJ?5?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0BL@DCNBJOMK@Halp_ECT_DivideByZero?$CI?$CJ?5?$AN?6?$AA@ ; `string'
;	COMDAT ??_C@_0BI@NMHEANFH@Halp_IRQ_HardDrive?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BI@NMHEANFH@Halp_IRQ_HardDrive?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_H'
	DB	'ardDrive() ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@DKPJFPAC@Halp_IRQ_MathCoprocessor?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BO@DKPJFPAC@Halp_IRQ_MathCoprocessor?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp'
	DB	'_IRQ_MathCoprocessor() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@NEDDPGBJ@Halp_IRQ_Mouse?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BE@NEDDPGBJ@Halp_IRQ_Mouse?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_Mouse'
	DB	'() ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IGOLJKOG@Halp_IRQ_VGA?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BC@IGOLJKOG@Halp_IRQ_VGA?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_VGA() ', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MCNHIJMG@Halp_IRQ_CMOSClock?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BI@MCNHIJMG@Halp_IRQ_CMOSClock?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_C'
	DB	'MOSClock() ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@BMGLEMCE@Halp_IRQ_LPT1?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@BMGLEMCE@Halp_IRQ_LPT1?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_LPT1()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@CNIDFGLJ@Halp_IRQ_LPT2?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@CNIDFGLJ@Halp_IRQ_LPT2?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_LPT2()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PNONLAAJ@Halp_IRQ_COM1?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@PNONLAAJ@Halp_IRQ_COM1?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_COM1()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MMAFKKJE@Halp_IRQ_COM2?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@MMAFKKJE@Halp_IRQ_COM2?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_IRQ_COM2()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@BPMNCKPI@Halp_IRQ_ReqFromSlave8259?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BP@BPMNCKPI@Halp_IRQ_ReqFromSlave8259?$CI?$CJ?5?$AN?6?$AA@ DB 'Hal'
	DB	'p_IRQ_ReqFromSlave8259() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@NHEAFIGN@Halp_ECT_MachineCheck?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BL@NHEAFIGN@Halp_ECT_MachineCheck?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_EC'
	DB	'T_MachineCheck() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IIPPLJCI@Halp_ECT_AlignmentCheck?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BN@IIPPLJCI@Halp_ECT_AlignmentCheck?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_'
	DB	'ECT_AlignmentCheck() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@BAMOPHKE@Halp_ECT_FloatingPointError?$CI?$CJ?5?$AN?6@
CONST	SEGMENT
??_C@_0CB@BAMOPHKE@Halp_ECT_FloatingPointError?$CI?$CJ?5?$AN?6@ DB 'Halp_'
	DB	'ECT_FloatingPointError() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@ECFHJJPN@Halp_ECT_PageFault?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BI@ECFHJJPN@Halp_ECT_PageFault?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_P'
	DB	'ageFault() ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@BNNEHHMP@Halp_ECT_GeneralProtection?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0CA@BNNEHHMP@Halp_ECT_GeneralProtection?$CI?$CJ?5?$AN?6?$AA@ DB 'Ha'
	DB	'lp_ECT_GeneralProtection() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@IPDIOMJP@Halp_ECT_StackException?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BN@IPDIOMJP@Halp_ECT_StackException?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_'
	DB	'ECT_StackException() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@NKBGCIFH@Halp_ECT_SegmentNotPresent?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0CA@NKBGCIFH@Halp_ECT_SegmentNotPresent?$CI?$CJ?5?$AN?6?$AA@ DB 'Ha'
	DB	'lp_ECT_SegmentNotPresent() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@PELGBAAP@Halp_ECT_InvalidTSS?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BJ@PELGBAAP@Halp_ECT_InvalidTSS?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_'
	DB	'InvalidTSS() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@KDIHIBHF@Halp_ECT_CoprocessorOverrun?$CI?$CJ?5?$AN?6@
CONST	SEGMENT
??_C@_0CB@KDIHIBHF@Halp_ECT_CoprocessorOverrun?$CI?$CJ?5?$AN?6@ DB 'Halp_'
	DB	'ECT_CoprocessorOverrun() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@LIGLLFBG@Halp_ECT_DeviceNotAvailable?$CI?$CJ?5?$AN?6@
CONST	SEGMENT
??_C@_0CB@LIGLLFBG@Halp_ECT_DeviceNotAvailable?$CI?$CJ?5?$AN?6@ DB 'Halp_'
	DB	'ECT_DeviceNotAvailable() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@EDOCEHEB@Halp_ECT_InvaildOpcode?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BM@EDOCEHEB@Halp_ECT_InvaildOpcode?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_E'
	DB	'CT_InvaildOpcode() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@GOILIIOG@Halp_ECT_BOUNDS?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BF@GOILIIOG@Halp_ECT_BOUNDS?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_BOUN'
	DB	'DS() ', 0dH, 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJNACMJH@Halp_ECT_INTO?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@PJNACMJH@Halp_ECT_INTO?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_INTO()'
	DB	' ', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@CHEGJKKD@Halp_ECT_Breakpoint?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BJ@CHEGJKKD@Halp_ECT_Breakpoint?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_'
	DB	'Breakpoint() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EPIMJMAK@Halp_ECT_NMI?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BC@EPIMJMAK@Halp_ECT_NMI?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_ECT_NMI() ', 0dH
	DB	0aH, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LHNLHKKE@Halp_ECT_DebugException?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BN@LHNLHKKE@Halp_ECT_DebugException?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_'
	DB	'ECT_DebugException() ', 0dH, 0aH, 00H	; `string'
CONST	ENDS
_DATA	SEGMENT
?msg@?1??Halp_ECT_DivideByZero@@9@9 DD FLAT:??_C@_0BL@DCNBJOMK@Halp_ECT_DivideByZero?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_DivideByZero'::`2'::msg
?msg@?1??Halp_ECT_DebugException@@9@9 DD FLAT:??_C@_0BN@LHNLHKKE@Halp_ECT_DebugException?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_DebugException'::`2'::msg
?msg@?1??Halp_ECT_NMI@@9@9 DD FLAT:??_C@_0BC@EPIMJMAK@Halp_ECT_NMI?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_NMI'::`2'::msg
?msg@?1??Halp_ECT_Breakpoint@@9@9 DD FLAT:??_C@_0BJ@CHEGJKKD@Halp_ECT_Breakpoint?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_Breakpoint'::`2'::msg
?msg@?1??Halp_ECT_INTO@@9@9 DD FLAT:??_C@_0BD@PJNACMJH@Halp_ECT_INTO?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_INTO'::`2'::msg
?msg@?1??Halp_ECT_BOUNDS@@9@9 DD FLAT:??_C@_0BF@GOILIIOG@Halp_ECT_BOUNDS?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_BOUNDS'::`2'::msg
?msg@?1??Halp_ECT_InvaildOpcode@@9@9 DD FLAT:??_C@_0BM@EDOCEHEB@Halp_ECT_InvaildOpcode?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_InvaildOpcode'::`2'::msg
?msg@?1??Halp_ECT_DeviceNotAvailable@@9@9 DD FLAT:??_C@_0CB@LIGLLFBG@Halp_ECT_DeviceNotAvailable?$CI?$CJ?5?$AN?6@ ; `Halp_ECT_DeviceNotAvailable'::`2'::msg
?msg@?1??Halp_ECT_CoprocessorOverrun@@9@9 DD FLAT:??_C@_0CB@KDIHIBHF@Halp_ECT_CoprocessorOverrun?$CI?$CJ?5?$AN?6@ ; `Halp_ECT_CoprocessorOverrun'::`2'::msg
?msg@?1??Halp_ECT_InvalidTSS@@9@9 DD FLAT:??_C@_0BJ@PELGBAAP@Halp_ECT_InvalidTSS?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_InvalidTSS'::`2'::msg
?msg@?1??Halp_ECT_SegmentNotPresent@@9@9 DD FLAT:??_C@_0CA@NKBGCIFH@Halp_ECT_SegmentNotPresent?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_SegmentNotPresent'::`2'::msg
?msg@?1??Halp_ECT_StackException@@9@9 DD FLAT:??_C@_0BN@IPDIOMJP@Halp_ECT_StackException?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_StackException'::`2'::msg
?msg@?1??Halp_ECT_GeneralProtection@@9@9 DD FLAT:??_C@_0CA@BNNEHHMP@Halp_ECT_GeneralProtection?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_GeneralProtection'::`2'::msg
?msg@?1??Halp_ECT_PageFault@@9@9 DD FLAT:??_C@_0BI@ECFHJJPN@Halp_ECT_PageFault?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_PageFault'::`2'::msg
?msg@?1??Halp_ECT_FloatingPointError@@9@9 DD FLAT:??_C@_0CB@BAMOPHKE@Halp_ECT_FloatingPointError?$CI?$CJ?5?$AN?6@ ; `Halp_ECT_FloatingPointError'::`2'::msg
?msg@?1??Halp_ECT_AlignmentCheck@@9@9 DD FLAT:??_C@_0BN@IIPPLJCI@Halp_ECT_AlignmentCheck?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_AlignmentCheck'::`2'::msg
?msg@?1??Halp_ECT_MachineCheck@@9@9 DD FLAT:??_C@_0BL@NHEAFIGN@Halp_ECT_MachineCheck?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_ECT_MachineCheck'::`2'::msg
?msg@?1??Halp_IRQ_ReqFromSlave8259@@9@9 DD FLAT:??_C@_0BP@BPMNCKPI@Halp_IRQ_ReqFromSlave8259?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_ReqFromSlave8259'::`2'::msg
?msg@?1??Halp_IRQ_COM2@@9@9 DD FLAT:??_C@_0BD@MMAFKKJE@Halp_IRQ_COM2?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_COM2'::`2'::msg
?msg@?1??Halp_IRQ_COM1@@9@9 DD FLAT:??_C@_0BD@PNONLAAJ@Halp_IRQ_COM1?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_COM1'::`2'::msg
?msg@?1??Halp_IRQ_LPT2@@9@9 DD FLAT:??_C@_0BD@CNIDFGLJ@Halp_IRQ_LPT2?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_LPT2'::`2'::msg
?msg@?1??Halp_IRQ_LPT1@@9@9 DD FLAT:??_C@_0BD@BMGLEMCE@Halp_IRQ_LPT1?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_LPT1'::`2'::msg
?msg@?1??Halp_IRQ_CMOSClock@@9@9 DD FLAT:??_C@_0BI@MCNHIJMG@Halp_IRQ_CMOSClock?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_CMOSClock'::`2'::msg
?msg@?1??Halp_IRQ_VGA@@9@9 DD FLAT:??_C@_0BC@IGOLJKOG@Halp_IRQ_VGA?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_VGA'::`2'::msg
?msg@?1??Halp_IRQ_Mouse@@9@9 DD FLAT:??_C@_0BE@NEDDPGBJ@Halp_IRQ_Mouse?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_Mouse'::`2'::msg
?msg@?1??Halp_IRQ_MathCoprocessor@@9@9 DD FLAT:??_C@_0BO@DKPJFPAC@Halp_IRQ_MathCoprocessor?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_MathCoprocessor'::`2'::msg
?msg@?1??Halp_IRQ_HardDrive@@9@9 DD FLAT:??_C@_0BI@NMHEANFH@Halp_IRQ_HardDrive?$CI?$CJ?5?$AN?6?$AA@ ; `Halp_IRQ_HardDrive'::`2'::msg
	ORG $+4
_m_IntHandlers DB 00H
	DD	FLAT:_Halp_ECT_DivideByZero
	DW	08e00H
	DB	01H
	DD	FLAT:_Halp_ECT_DebugException
	DW	08e00H
	DB	02H
	DD	FLAT:_Halp_ECT_NMI
	DW	08e00H
	DB	03H
	DD	FLAT:_Halp_ECT_Breakpoint
	DW	08e00H
	DB	04H
	DD	FLAT:_Halp_ECT_INTO
	DW	08e00H
	DB	05H
	DD	FLAT:_Halp_ECT_BOUNDS
	DW	08e00H
	DB	06H
	DD	FLAT:_Halp_ECT_InvaildOpcode
	DW	08e00H
	DB	07H
	DD	FLAT:_Halp_ECT_DeviceNotAvailable
	DW	08e00H
	DB	08H
	DD	FLAT:_Halp_ECT_DoubleFault
	DW	08e00H
	DB	09H
	DD	FLAT:_Halp_ECT_CoprocessorOverrun
	DW	08e00H
	DB	0aH
	DD	FLAT:_Halp_ECT_InvalidTSS
	DW	08e00H
	DB	0bH
	DD	FLAT:_Halp_ECT_SegmentNotPresent
	DW	08e00H
	DB	0cH
	DD	FLAT:_Halp_ECT_StackException
	DW	08e00H
	DB	0dH
	DD	FLAT:_Halp_ECT_GeneralProtection
	DW	08e00H
	DB	0eH
	DD	FLAT:_Halp_ECT_PageFault
	DW	08e00H
	DB	010H
	DD	FLAT:_Halp_ECT_FloatingPointError
	DW	08e00H
	DB	011H
	DD	FLAT:_Halp_ECT_AlignmentCheck
	DW	08e00H
	DB	012H
	DD	FLAT:_Halp_ECT_MachineCheck
	DW	08e00H
	DB	021H
	DD	FLAT:_Halp_IRQ_Keyboard
	DW	08e00H
	DB	022H
	DD	FLAT:_Halp_IRQ_ReqFromSlave8259
	DW	08e00H
	DB	023H
	DD	FLAT:_Halp_IRQ_COM2
	DW	08e00H
	DB	024H
	DD	FLAT:_Halp_IRQ_COM1
	DW	08e00H
	DB	025H
	DD	FLAT:_Halp_IRQ_LPT2
	DW	08e00H
	DB	026H
	DD	FLAT:_Halp_IRQ_FloppyDisk
	DW	08e00H
	DB	027H
	DD	FLAT:_Halp_IRQ_LPT1
	DW	08e00H
	DB	028H
	DD	FLAT:_Halp_IRQ_CMOSClock
	DW	08e00H
	DB	029H
	DD	FLAT:_Halp_IRQ_VGA
	DW	08e00H
	DB	02cH
	DD	FLAT:_Halp_IRQ_Mouse
	DW	08e00H
	DB	02dH
	DD	FLAT:_Halp_IRQ_MathCoprocessor
	DW	08e00H
	DB	02eH
	DD	FLAT:_Halp_IRQ_HardDrive
	DW	08e00H
	DB	020H
	DD	038H
	DW	08500H
	DB	030H
	DD	040H
	DW	08500H
	DB	00H
	DD	00H
	DW	00H
_DATA	ENDS
;	COMDAT ??_C@_0BL@DCNBJOMK@Halp_ECT_DivideByZero?$CI?$CJ?5?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BL@DCNBJOMK@Halp_ECT_DivideByZero?$CI?$CJ?5?$AN?6?$AA@ DB 'Halp_EC'
	DB	'T_DivideByZero() ', 0dH, 0aH, 00H		; `string'
CONST	ENDS
PUBLIC	??_C@_0CP@DIODDKOF@HalpInitializeProcessor?$CI?$CJ?5return@ ; `string'
PUBLIC	_HalInitializeHal
EXTRN	_CrtPrintf:PROC
;	COMDAT ??_C@_0CP@DIODDKOF@HalpInitializeProcessor?$CI?$CJ?5return@
; File c:\develop\myoksos\hal.c
CONST	SEGMENT
??_C@_0CP@DIODDKOF@HalpInitializeProcessor?$CI?$CJ?5return@ DB 'HalpIniti'
	DB	'alizeProcessor() returned an error.', 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _HalInitializeHal
_TEXT	SEGMENT
_HalInitializeHal PROC					; COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 40   : 	//실질적인 하드웨어 초기화 함수 호출
; 41   : 	if(!HalpInitializeProcessor()) {

  00009	e8 00 00 00 00	 call	 _HalpInitializeProcessor
  0000e	85 c0		 test	 eax, eax
  00010	75 11		 jne	 SHORT $LN1@HalInitial

; 42   : 		DbgPrint("HalpInitializeProcessor() returned an error.\r\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CP@DIODDKOF@HalpInitializeProcessor?$CI?$CJ?5return@
  00017	e8 00 00 00 00	 call	 _CrtPrintf
  0001c	83 c4 04	 add	 esp, 4

; 43   : 		return FALSE;

  0001f	33 c0		 xor	 eax, eax
  00021	eb 05		 jmp	 SHORT $LN2@HalInitial
$LN1@HalInitial:

; 44   : 	}
; 45   : 
; 46   : 	return TRUE;

  00023	b8 01 00 00 00	 mov	 eax, 1
$LN2@HalInitial:

; 47   : 
; 48   : }

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
_HalInitializeHal ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CD@FBKHEGHB@Interrupt?5Service?5is?5installed?$CB?$CB@ ; `string'
PUBLIC	??_C@_0CL@KJAKIFMC@HalpStartIntService?$CI?$CJ?5returned?5a@ ; `string'
PUBLIC	??_C@_0BP@OLPBBHME@SystemTimer?5is?5initialized?$CB?$CB?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CI@HNIFLDMK@HalpInitSysTimer?$CI?$CJ?5returned?5an?5e@ ; `string'
PUBLIC	??_C@_0BD@GMFGECEC@PIC?5is?5success?$CB?$CB?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@GOIDGDAA@HalpInitPIC?$CI?$CJ?5returned?5an?5error?4@ ; `string'
PUBLIC	??_C@_0BI@MIIPFAGL@A20?5line?5is?5success?$CB?$CB?$AN?6?$AA@ ; `string'
PUBLIC	??_C@_0CF@GHKHCIHI@HalpEnableA20?$CI?$CJ?5returned?5an?5erro@ ; `string'
;	COMDAT ??_C@_0CD@FBKHEGHB@Interrupt?5Service?5is?5installed?$CB?$CB@
CONST	SEGMENT
??_C@_0CD@FBKHEGHB@Interrupt?5Service?5is?5installed?$CB?$CB@ DB 'Interru'
	DB	'pt Service is installed!!', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KJAKIFMC@HalpStartIntService?$CI?$CJ?5returned?5a@
CONST	SEGMENT
??_C@_0CL@KJAKIFMC@HalpStartIntService?$CI?$CJ?5returned?5a@ DB 'HalpStar'
	DB	'tIntService() returned an error.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@OLPBBHME@SystemTimer?5is?5initialized?$CB?$CB?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BP@OLPBBHME@SystemTimer?5is?5initialized?$CB?$CB?$AN?6?$AA@ DB 'Sy'
	DB	'stemTimer is initialized!!', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@HNIFLDMK@HalpInitSysTimer?$CI?$CJ?5returned?5an?5e@
CONST	SEGMENT
??_C@_0CI@HNIFLDMK@HalpInitSysTimer?$CI?$CJ?5returned?5an?5e@ DB 'HalpIni'
	DB	'tSysTimer() returned an error.', 0dH, 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@GMFGECEC@PIC?5is?5success?$CB?$CB?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BD@GMFGECEC@PIC?5is?5success?$CB?$CB?$AN?6?$AA@ DB 'PIC is success'
	DB	'!!', 0dH, 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@GOIDGDAA@HalpInitPIC?$CI?$CJ?5returned?5an?5error?4@
CONST	SEGMENT
??_C@_0CD@GOIDGDAA@HalpInitPIC?$CI?$CJ?5returned?5an?5error?4@ DB 'HalpIn'
	DB	'itPIC() returned an error.', 0dH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@MIIPFAGL@A20?5line?5is?5success?$CB?$CB?$AN?6?$AA@
CONST	SEGMENT
??_C@_0BI@MIIPFAGL@A20?5line?5is?5success?$CB?$CB?$AN?6?$AA@ DB 'A20 line'
	DB	' is success!!', 0dH, 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GHKHCIHI@HalpEnableA20?$CI?$CJ?5returned?5an?5erro@
CONST	SEGMENT
??_C@_0CF@GHKHCIHI@HalpEnableA20?$CI?$CJ?5returned?5an?5erro@ DB 'HalpEna'
	DB	'bleA20() returned an error.', 0dH, 0aH, 00H	; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _HalpInitializeProcessor
_TEXT	SEGMENT
_HalpInitializeProcessor PROC				; COMDAT

; 52   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 53   : 	//A20 Line 활성화 함수
; 54   : 	if(!HalpEnableA20()) {

  00009	e8 00 00 00 00	 call	 _HalpEnableA20
  0000e	85 c0		 test	 eax, eax
  00010	75 14		 jne	 SHORT $LN4@HalpInitia

; 55   : 		DbgPrint("HalpEnableA20() returned an error.\r\n");

  00012	68 00 00 00 00	 push	 OFFSET ??_C@_0CF@GHKHCIHI@HalpEnableA20?$CI?$CJ?5returned?5an?5erro@
  00017	e8 00 00 00 00	 call	 _CrtPrintf
  0001c	83 c4 04	 add	 esp, 4

; 56   : 		return FALSE;

  0001f	33 c0		 xor	 eax, eax
  00021	e9 8c 00 00 00	 jmp	 $LN5@HalpInitia
$LN4@HalpInitia:

; 57   : 	}
; 58   : 	DbgPrint("A20 line is success!!\r\n");

  00026	68 00 00 00 00	 push	 OFFSET ??_C@_0BI@MIIPFAGL@A20?5line?5is?5success?$CB?$CB?$AN?6?$AA@
  0002b	e8 00 00 00 00	 call	 _CrtPrintf
  00030	83 c4 04	 add	 esp, 4

; 59   : 
; 60   : 	//PIC 초기화 함수
; 61   : 	if(!HalpInitPIC()) {

  00033	e8 00 00 00 00	 call	 _HalpInitPIC
  00038	85 c0		 test	 eax, eax
  0003a	75 11		 jne	 SHORT $LN3@HalpInitia

; 62   : 		DbgPrint("HalpInitPIC() returned an error.\r\n");

  0003c	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@GOIDGDAA@HalpInitPIC?$CI?$CJ?5returned?5an?5error?4@
  00041	e8 00 00 00 00	 call	 _CrtPrintf
  00046	83 c4 04	 add	 esp, 4

; 63   : 		return FALSE;

  00049	33 c0		 xor	 eax, eax
  0004b	eb 65		 jmp	 SHORT $LN5@HalpInitia
$LN3@HalpInitia:

; 64   : 	}
; 65   : 	DbgPrint("PIC is success!!\r\n");

  0004d	68 00 00 00 00	 push	 OFFSET ??_C@_0BD@GMFGECEC@PIC?5is?5success?$CB?$CB?$AN?6?$AA@
  00052	e8 00 00 00 00	 call	 _CrtPrintf
  00057	83 c4 04	 add	 esp, 4

; 66   : 
; 67   : 	//TIMER 초기화 함수
; 68   : 	if(!HalpInitSysTimer(TIMEOUT_PER_SECOND)) {

  0005a	6a 32		 push	 50			; 00000032H
  0005c	e8 00 00 00 00	 call	 _HalpInitSysTimer
  00061	83 c4 04	 add	 esp, 4
  00064	85 c0		 test	 eax, eax
  00066	75 11		 jne	 SHORT $LN2@HalpInitia

; 69   : 		DbgPrint("HalpInitSysTimer() returned an error.\r\n");

  00068	68 00 00 00 00	 push	 OFFSET ??_C@_0CI@HNIFLDMK@HalpInitSysTimer?$CI?$CJ?5returned?5an?5e@
  0006d	e8 00 00 00 00	 call	 _CrtPrintf
  00072	83 c4 04	 add	 esp, 4

; 70   : 		return FALSE;

  00075	33 c0		 xor	 eax, eax
  00077	eb 39		 jmp	 SHORT $LN5@HalpInitia
$LN2@HalpInitia:

; 71   : 	}
; 72   : 	DbgPrint("SystemTimer is initialized!!\r\n");

  00079	68 00 00 00 00	 push	 OFFSET ??_C@_0BP@OLPBBHME@SystemTimer?5is?5initialized?$CB?$CB?$AN?6?$AA@
  0007e	e8 00 00 00 00	 call	 _CrtPrintf
  00083	83 c4 04	 add	 esp, 4

; 73   : 
; 74   : 	//INTERRUPT 초기화 함수 
; 75   : 	if(!HalpStartIntService()) {

  00086	e8 00 00 00 00	 call	 _HalpStartIntService
  0008b	85 c0		 test	 eax, eax
  0008d	75 11		 jne	 SHORT $LN1@HalpInitia

; 76   : 		DbgPrint("HalpStartIntService() returned an error.\r\n");

  0008f	68 00 00 00 00	 push	 OFFSET ??_C@_0CL@KJAKIFMC@HalpStartIntService?$CI?$CJ?5returned?5a@
  00094	e8 00 00 00 00	 call	 _CrtPrintf
  00099	83 c4 04	 add	 esp, 4

; 77   : 		return FALSE;

  0009c	33 c0		 xor	 eax, eax
  0009e	eb 12		 jmp	 SHORT $LN5@HalpInitia
$LN1@HalpInitia:

; 78   : 	}
; 79   : 	DbgPrint("Interrupt Service is installed!!\r\n");

  000a0	68 00 00 00 00	 push	 OFFSET ??_C@_0CD@FBKHEGHB@Interrupt?5Service?5is?5installed?$CB?$CB@
  000a5	e8 00 00 00 00	 call	 _CrtPrintf
  000aa	83 c4 04	 add	 esp, 4

; 80   : 
; 81   : 
; 82   : 	return TRUE;

  000ad	b8 01 00 00 00	 mov	 eax, 1
$LN5@HalpInitia:

; 83   : }

  000b2	5f		 pop	 edi
  000b3	5e		 pop	 esi
  000b4	5b		 pop	 ebx
  000b5	8b e5		 mov	 esp, ebp
  000b7	5d		 pop	 ebp
  000b8	c3		 ret	 0
_HalpInitializeProcessor ENDP
_TEXT	ENDS
EXTRN	_WRITE_PORT_UCHAR:PROC
EXTRN	_READ_PORT_UCHAR:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _HalpEnableA20
_TEXT	SEGMENT
_flag$ = -18						; size = 1
_status$ = -17						; size = 1
_test_2_buf$ = -16					; size = 4
_test_2$ = -12						; size = 4
_test_1_buf$ = -8					; size = 4
_test_1$ = -4						; size = 4
_HalpEnableA20 PROC					; COMDAT

; 85   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 54	 sub	 esp, 84			; 00000054H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 86   : 	int *test_1 = (int *)0x00000000, test_1_buf;

  00009	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _test_1$[ebp], 0

; 87   : 	int *test_2 = (int *)0x00100000, test_2_buf;

  00010	c7 45 f4 00 00
	10 00		 mov	 DWORD PTR _test_2$[ebp], 1048576 ; 00100000H
$LN16@HalpEnable:

; 88   : 	UCHAR status, flag;
; 89   : 
; 90   : 	//Status Register(0x64)를 읽어서 입력 버퍼에 데이터가 없을 때까지 대기.
; 91   : 	do { status = READ_PORT_UCHAR((PUCHAR)0x64); }

  00017	6a 64		 push	 100			; 00000064H
  00019	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  0001e	83 c4 04	 add	 esp, 4
  00021	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 92   : 	while( status & 0x02 );

  00024	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  00028	83 e0 02	 and	 eax, 2
  0002b	75 ea		 jne	 SHORT $LN16@HalpEnable

; 93   : 	//Control Register에 데이터를 쓰는 과정
; 94   : 	//output port에서 데이터를 읽어서 출력 버퍼(0x60)에 데이터를 저장하라는 명령.
; 95   : 		WRITE_PORT_UCHAR((PUCHAR)0x64, 0xd0);

  0002d	68 d0 00 00 00	 push	 208			; 000000d0H
  00032	6a 64		 push	 100			; 00000064H
  00034	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00039	83 c4 08	 add	 esp, 8
$LN13@HalpEnable:

; 96   : 
; 97   : 	//Status Register(Ox64)를 읽어서 출력 버퍼(Ox60)에 데이터가 들어올때 까지 대기.
; 98   : 	do { status = READ_PORT_UCHAR((PUCHAR)0x64); }

  0003c	6a 64		 push	 100			; 00000064H
  0003e	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00043	83 c4 04	 add	 esp, 4
  00046	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 99   : 	while( !(status&0x01) );

  00049	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  0004d	83 e0 01	 and	 eax, 1
  00050	74 ea		 je	 SHORT $LN13@HalpEnable

; 100  : 	//출력 버퍼(Ox60)에서 데이터를 읽은 후에 A20 GATE(두 번째 비트)활성화 	
; 101  : 	flag = READ_PORT_UCHAR((PUCHAR)0x60);

  00052	6a 60		 push	 96			; 00000060H
  00054	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00059	83 c4 04	 add	 esp, 4
  0005c	88 45 ee	 mov	 BYTE PTR _flag$[ebp], al

; 102  : 	flag |= 0x02; // A20 line 활성화

  0005f	0f b6 45 ee	 movzx	 eax, BYTE PTR _flag$[ebp]
  00063	83 c8 02	 or	 eax, 2
  00066	88 45 ee	 mov	 BYTE PTR _flag$[ebp], al
$LN10@HalpEnable:

; 103  : 
; 104  : 	//flag값을 Register에 써넣어 A20 활성화
; 105  : 	do { status = READ_PORT_UCHAR((PUCHAR)0x64); }

  00069	6a 64		 push	 100			; 00000064H
  0006b	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00070	83 c4 04	 add	 esp, 4
  00073	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 106  : 	while( status & 0x02 );

  00076	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  0007a	83 e0 02	 and	 eax, 2
  0007d	75 ea		 jne	 SHORT $LN10@HalpEnable

; 107  : 	WRITE_PORT_UCHAR((PUCHAR)0x64, 0xd1);

  0007f	68 d1 00 00 00	 push	 209			; 000000d1H
  00084	6a 64		 push	 100			; 00000064H
  00086	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0008b	83 c4 08	 add	 esp, 8
$LN7@HalpEnable:

; 108  : 
; 109  : 	do { status = READ_PORT_UCHAR((PUCHAR)0x64); } 

  0008e	6a 64		 push	 100			; 00000064H
  00090	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  00095	83 c4 04	 add	 esp, 4
  00098	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 110  : 	while( status & 0x02 );

  0009b	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  0009f	83 e0 02	 and	 eax, 2
  000a2	75 ea		 jne	 SHORT $LN7@HalpEnable

; 111  : 	WRITE_PORT_UCHAR((PUCHAR)0x60, flag); 

  000a4	8a 45 ee	 mov	 al, BYTE PTR _flag$[ebp]
  000a7	50		 push	 eax
  000a8	6a 60		 push	 96			; 00000060H
  000aa	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  000af	83 c4 08	 add	 esp, 8
$LN4@HalpEnable:

; 112  : 
; 113  : 	do { status = READ_PORT_UCHAR((PUCHAR)0x64); } 

  000b2	6a 64		 push	 100			; 00000064H
  000b4	e8 00 00 00 00	 call	 _READ_PORT_UCHAR
  000b9	83 c4 04	 add	 esp, 4
  000bc	88 45 ef	 mov	 BYTE PTR _status$[ebp], al

; 114  : 	while( status & 0x02 );

  000bf	0f b6 45 ef	 movzx	 eax, BYTE PTR _status$[ebp]
  000c3	83 e0 02	 and	 eax, 2
  000c6	75 ea		 jne	 SHORT $LN4@HalpEnable

; 115  : 
; 116  : 	//Test A20 line
; 117  : 	test_1_buf = *test_1;

  000c8	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  000cb	8b 08		 mov	 ecx, DWORD PTR [eax]
  000cd	89 4d f8	 mov	 DWORD PTR _test_1_buf$[ebp], ecx

; 118  : 	test_2_buf = *test_2;

  000d0	8b 45 f4	 mov	 eax, DWORD PTR _test_2$[ebp]
  000d3	8b 08		 mov	 ecx, DWORD PTR [eax]
  000d5	89 4d f0	 mov	 DWORD PTR _test_2_buf$[ebp], ecx

; 119  : 	*test_1 = 0xff00ccaa;

  000d8	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  000db	c7 00 aa cc 00
	ff		 mov	 DWORD PTR [eax], -16724822 ; ff00ccaaH

; 120  : 	*test_2 = 0x22cc11dd;

  000e1	8b 45 f4	 mov	 eax, DWORD PTR _test_2$[ebp]
  000e4	c7 00 dd 11 cc
	22		 mov	 DWORD PTR [eax], 583799261 ; 22cc11ddH

; 121  : 	if(*test_1 == *test_2) {

  000ea	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  000ed	8b 4d f4	 mov	 ecx, DWORD PTR _test_2$[ebp]
  000f0	8b 10		 mov	 edx, DWORD PTR [eax]
  000f2	3b 11		 cmp	 edx, DWORD PTR [ecx]
  000f4	75 0c		 jne	 SHORT $LN1@HalpEnable

; 122  : 		*test_1 = test_1_buf;

  000f6	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  000f9	8b 4d f8	 mov	 ecx, DWORD PTR _test_1_buf$[ebp]
  000fc	89 08		 mov	 DWORD PTR [eax], ecx

; 123  : 		return FALSE;

  000fe	33 c0		 xor	 eax, eax
  00100	eb 15		 jmp	 SHORT $LN17@HalpEnable
$LN1@HalpEnable:

; 124  : 	}
; 125  : 	//A20 line이 활성화 되었다면, test_1과 test_2의 값이 달라야 한다.
; 126  : 	*test_1 = test_1_buf;

  00102	8b 45 fc	 mov	 eax, DWORD PTR _test_1$[ebp]
  00105	8b 4d f8	 mov	 ecx, DWORD PTR _test_1_buf$[ebp]
  00108	89 08		 mov	 DWORD PTR [eax], ecx

; 127  : 	*test_2 = test_2_buf;

  0010a	8b 45 f4	 mov	 eax, DWORD PTR _test_2$[ebp]
  0010d	8b 4d f0	 mov	 ecx, DWORD PTR _test_2_buf$[ebp]
  00110	89 08		 mov	 DWORD PTR [eax], ecx

; 128  : 
; 129  : 	return TRUE;

  00112	b8 01 00 00 00	 mov	 eax, 1
$LN17@HalpEnable:

; 130  : }

  00117	5f		 pop	 edi
  00118	5e		 pop	 esi
  00119	5b		 pop	 ebx
  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c3		 ret	 0
_HalpEnableA20 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _HalpInitPIC
_TEXT	SEGMENT
_HalpInitPIC PROC					; COMDAT

; 140  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 141  : 	// Master PIC
; 142  : 	WRITE_PORT_UCHAR((PUCHAR)0x20, 0x11); //ICW1 : Cascade mode, ICW4 

  00009	6a 11		 push	 17			; 00000011H
  0000b	6a 20		 push	 32			; 00000020H
  0000d	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00012	83 c4 08	 add	 esp, 8

; 143  : 	WRITE_PORT_UCHAR((PUCHAR)0x21, 0x20); //ICW2 : 인터럽트 시작 값 INT vector 20h 

  00015	6a 20		 push	 32			; 00000020H
  00017	6a 21		 push	 33			; 00000021H
  00019	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0001e	83 c4 08	 add	 esp, 8

; 144  : 	WRITE_PORT_UCHAR((PUCHAR)0x21, 0x04); //ICW3  

  00021	6a 04		 push	 4
  00023	6a 21		 push	 33			; 00000021H
  00025	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0002a	83 c4 08	 add	 esp, 8

; 145  : 	WRITE_PORT_UCHAR((PUCHAR)0x21, 0x01); //ICW4 

  0002d	6a 01		 push	 1
  0002f	6a 21		 push	 33			; 00000021H
  00031	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00036	83 c4 08	 add	 esp, 8

; 146  : 	WRITE_PORT_UCHAR((PUCHAR)0x21, 0x00);

  00039	6a 00		 push	 0
  0003b	6a 21		 push	 33			; 00000021H
  0003d	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00042	83 c4 08	 add	 esp, 8

; 147  : 
; 148  : 	// Slave PIC 
; 149  : 	WRITE_PORT_UCHAR((PUCHAR)0xa0, 0x11); //ICW1 : Cascade mode, ICW4 

  00045	6a 11		 push	 17			; 00000011H
  00047	68 a0 00 00 00	 push	 160			; 000000a0H
  0004c	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00051	83 c4 08	 add	 esp, 8

; 150  : 	WRITE_PORT_UCHAR((PUCHAR)0xa1, 0x28); //ICW2 : 인터럽트 시작 값 INT vector 28h 

  00054	6a 28		 push	 40			; 00000028H
  00056	68 a1 00 00 00	 push	 161			; 000000a1H
  0005b	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00060	83 c4 08	 add	 esp, 8

; 151  : 	WRITE_PORT_UCHAR((PUCHAR)0xa1, 0x02); //ICW3  

  00063	6a 02		 push	 2
  00065	68 a1 00 00 00	 push	 161			; 000000a1H
  0006a	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0006f	83 c4 08	 add	 esp, 8

; 152  : 	WRITE_PORT_UCHAR((PUCHAR)0xa1, 0x01); //ICW4 

  00072	6a 01		 push	 1
  00074	68 a1 00 00 00	 push	 161			; 000000a1H
  00079	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0007e	83 c4 08	 add	 esp, 8

; 153  : 	WRITE_PORT_UCHAR((PUCHAR)0xa1, 0x00);

  00081	6a 00		 push	 0
  00083	68 a1 00 00 00	 push	 161			; 000000a1H
  00088	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  0008d	83 c4 08	 add	 esp, 8

; 154  : 
; 155  : 	return TRUE;

  00090	b8 01 00 00 00	 mov	 eax, 1

; 156  : }

  00095	5f		 pop	 edi
  00096	5e		 pop	 esi
  00097	5b		 pop	 ebx
  00098	8b e5		 mov	 esp, ebp
  0009a	5d		 pop	 ebp
  0009b	c3		 ret	 0
_HalpInitPIC ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _HalpInitSysTimer
_TEXT	SEGMENT
_timeout$ = -4						; size = 2
_timeoutPerSecond$ = 8					; size = 1
_HalpInitSysTimer PROC					; COMDAT

; 159  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 160  : 	//새로운 counter 값 입력
; 161  : 	WORD timeout = (WORD)(1193180/timeoutPerSecond);

  00009	0f b6 4d 08	 movzx	 ecx, BYTE PTR _timeoutPerSecond$[ebp]
  0000d	b8 dc 34 12 00	 mov	 eax, 1193180		; 001234dcH
  00012	99		 cdq
  00013	f7 f9		 idiv	 ecx
  00015	66 89 45 fc	 mov	 WORD PTR _timeout$[ebp], ax

; 162  : 
; 163  : 	WRITE_PORT_UCHAR((PUCHAR)0x43, 0x34);

  00019	6a 34		 push	 52			; 00000034H
  0001b	6a 43		 push	 67			; 00000043H
  0001d	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00022	83 c4 08	 add	 esp, 8

; 164  : 
; 165  : 	//COUNTER 0 Register의 Low, High byte 값 설정
; 166  : 	WRITE_PORT_UCHAR((PUCHAR)0x40, (UCHAR)(timeout & 0xff));

  00025	0f b7 45 fc	 movzx	 eax, WORD PTR _timeout$[ebp]
  00029	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  0002e	50		 push	 eax
  0002f	6a 40		 push	 64			; 00000040H
  00031	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00036	83 c4 08	 add	 esp, 8

; 167  : 	WRITE_PORT_UCHAR((PUCHAR)0x40, (UCHAR)(timeout >> 8));

  00039	0f b7 45 fc	 movzx	 eax, WORD PTR _timeout$[ebp]
  0003d	c1 f8 08	 sar	 eax, 8
  00040	50		 push	 eax
  00041	6a 40		 push	 64			; 00000040H
  00043	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00048	83 c4 08	 add	 esp, 8

; 168  : 
; 169  : 	return TRUE;

  0004b	b8 01 00 00 00	 mov	 eax, 1

; 170  : }

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_HalpInitSysTimer ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_DivideByZero
_TEXT	SEGMENT
_Halp_ECT_DivideByZero PROC				; COMDAT

; 176  : 	static char *msg = "Halp_ECT_DivideByZero() \r\n";
; 177  : 	_asm {
; 178  : 		pushad

  00000	60		 pushad

; 179  : 
; 180  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_DivideByZero@@9@9

; 181  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 182  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 183  : 
; 184  : 		popad

  0000f	61		 popad

; 185  : 		iretd

  00010	cf		 iretd
_Halp_ECT_DivideByZero ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_DebugException
_TEXT	SEGMENT
_Halp_ECT_DebugException PROC				; COMDAT

; 191  : 	static char *msg = "Halp_ECT_DebugException() \r\n";
; 192  : 	_asm {
; 193  : 		pushad

  00000	60		 pushad

; 194  : 
; 195  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_DebugException@@9@9

; 196  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 197  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 198  : 
; 199  : 		popad

  0000f	61		 popad

; 200  : 		iretd

  00010	cf		 iretd
_Halp_ECT_DebugException ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_NMI
_TEXT	SEGMENT
_Halp_ECT_NMI PROC					; COMDAT

; 206  : 	static char *msg = "Halp_ECT_NMI() \r\n";
; 207  : 	_asm {
; 208  : 		pushad

  00000	60		 pushad

; 209  : 
; 210  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_NMI@@9@9

; 211  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 212  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 213  : 
; 214  : 		popad

  0000f	61		 popad

; 215  : 		iretd

  00010	cf		 iretd
_Halp_ECT_NMI ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@FJNLJOKK@bp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@ ; `string'
_BSS	SEGMENT
?dwESP@?1??Halp_ECT_Breakpoint@@9@9 DD 01H DUP (?)	; `Halp_ECT_Breakpoint'::`2'::dwESP
_BSS	ENDS
;	COMDAT ??_C@_0CB@FJNLJOKK@bp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@
CONST	SEGMENT
??_C@_0CB@FJNLJOKK@bp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@ DB 'b'
	DB	'p, #1:0x%x, #2:0x%x, #3:0x%x ', 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _Halp_ECT_Breakpoint
_TEXT	SEGMENT
_Halp_ECT_Breakpoint PROC				; COMDAT

; 221  : 	static char *msg = "Halp_ECT_Breakpoint() \r\n";
; 222  : 	static int dwESP;
; 223  : 	_asm {
; 224  : 		cli

  00000	fa		 cli

; 225  : 		mov	dwESP, esp

  00001	89 25 00 00 00
	00		 mov	 DWORD PTR ?dwESP@?1??Halp_ECT_Breakpoint@@9@9, esp

; 226  : 		pushad

  00007	60		 pushad

; 227  : 	}
; 228  : 
; 229  : 	DbgPrint("bp, #1:0x%x, #2:0x%x, #3:0x%x \r\n", *((int *)dwESP), *((int *)dwESP+1), *((int *)dwESP+2));

  00008	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwESP@?1??Halp_ECT_Breakpoint@@9@9
  0000d	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  00010	51		 push	 ecx
  00011	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?dwESP@?1??Halp_ECT_Breakpoint@@9@9
  00017	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0001a	50		 push	 eax
  0001b	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?dwESP@?1??Halp_ECT_Breakpoint@@9@9
  00021	8b 11		 mov	 edx, DWORD PTR [ecx]
  00023	52		 push	 edx
  00024	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@FJNLJOKK@bp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@
  00029	e8 00 00 00 00	 call	 _CrtPrintf
  0002e	83 c4 10	 add	 esp, 16			; 00000010H
$LN2@Halp_ECT_B:

; 230  : 	while(1) ;

  00031	b8 01 00 00 00	 mov	 eax, 1
  00036	85 c0		 test	 eax, eax
  00038	74 02		 je	 SHORT $LN1@Halp_ECT_B
  0003a	eb f5		 jmp	 SHORT $LN2@Halp_ECT_B
$LN1@Halp_ECT_B:

; 231  : 
; 232  : 	_asm {
; 233  : 		popad

  0003c	61		 popad

; 234  : 		iretd

  0003d	cf		 iretd
_Halp_ECT_Breakpoint ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_INTO
_TEXT	SEGMENT
_Halp_ECT_INTO PROC					; COMDAT

; 240  : 	static char *msg = "Halp_ECT_INTO() \r\n";
; 241  : 	_asm {
; 242  : 		pushad

  00000	60		 pushad

; 243  : 
; 244  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_INTO@@9@9

; 245  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 246  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 247  : 
; 248  : 		popad

  0000f	61		 popad

; 249  : 		iretd

  00010	cf		 iretd
_Halp_ECT_INTO ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_BOUNDS
_TEXT	SEGMENT
_Halp_ECT_BOUNDS PROC					; COMDAT

; 255  : 	static char *msg = "Halp_ECT_BOUNDS() \r\n";
; 256  : 	_asm {
; 257  : 		pushad

  00000	60		 pushad

; 258  : 
; 259  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_BOUNDS@@9@9

; 260  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 261  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 262  : 
; 263  : 		popad

  0000f	61		 popad

; 264  : 		iretd

  00010	cf		 iretd
_Halp_ECT_BOUNDS ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_InvaildOpcode
_TEXT	SEGMENT
_Halp_ECT_InvaildOpcode PROC				; COMDAT

; 270  : 	static char *msg = "Halp_ECT_InvaildOpcode() \r\n";
; 271  : 	_asm {
; 272  : 		pushad

  00000	60		 pushad

; 273  : 
; 274  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_InvaildOpcode@@9@9

; 275  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 276  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4
$infinate$1027:

; 277  : 
; 278  : infinate:
; 279  : 		jmp		infinate

  0000f	eb fe		 jmp	 SHORT $infinate$1027

; 280  : 
; 281  : 		popad

  00011	61		 popad

; 282  : 		iretd

  00012	cf		 iretd
_Halp_ECT_InvaildOpcode ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_DeviceNotAvailable
_TEXT	SEGMENT
_Halp_ECT_DeviceNotAvailable PROC			; COMDAT

; 288  : 	static char *msg = "Halp_ECT_DeviceNotAvailable() \r\n";
; 289  : 	_asm {
; 290  : 		pushad

  00000	60		 pushad

; 291  : 
; 292  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_DeviceNotAvailable@@9@9

; 293  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 294  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 295  : 
; 296  : 		popad

  0000f	61		 popad

; 297  : 		iretd

  00010	cf		 iretd
_Halp_ECT_DeviceNotAvailable ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_DoubleFault
_TEXT	SEGMENT
_Halp_ECT_DoubleFault PROC				; COMDAT

; 303  : 	_asm {
; 304  : 		mov		ebx, 0b8000h

  00000	bb 00 80 0b 00	 mov	 ebx, 753664		; 000b8000H

; 305  : 		mov		ecx, 80*25

  00005	b9 d0 07 00 00	 mov	 ecx, 2000		; 000007d0H
$fault_loop$1037:

; 306  : 
; 307  : fault_loop:
; 308  : 		mov		byte ptr [ebx], '#'

  0000a	c6 03 23	 mov	 BYTE PTR [ebx], 35	; 00000023H

; 309  : 		mov		byte ptr [ebx+1], 7

  0000d	c6 43 01 07	 mov	 BYTE PTR [ebx+1], 7

; 310  : 		add		ebx, 2

  00011	83 c3 02	 add	 ebx, 2

; 311  : 		loop	fault_loop

  00014	e2 f4		 loop	 $fault_loop$1037
$infinate$1038:

; 312  : 
; 313  : infinate:
; 314  : 		jmp		infinate

  00016	eb fe		 jmp	 SHORT $infinate$1038
_Halp_ECT_DoubleFault ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_CoprocessorOverrun
_TEXT	SEGMENT
_Halp_ECT_CoprocessorOverrun PROC			; COMDAT

; 320  : 	static char *msg = "Halp_ECT_CoprocessorOverrun() \r\n";
; 321  : 	_asm {
; 322  : 		pushad

  00000	60		 pushad

; 323  : 
; 324  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_CoprocessorOverrun@@9@9

; 325  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 326  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 327  : 
; 328  : 		popad

  0000f	61		 popad

; 329  : 		iretd

  00010	cf		 iretd
_Halp_ECT_CoprocessorOverrun ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_InvalidTSS
_TEXT	SEGMENT
_Halp_ECT_InvalidTSS PROC				; COMDAT

; 335  : 	static char *msg = "Halp_ECT_InvalidTSS() \r\n";
; 336  : 	_asm {
; 337  : 		pushad

  00000	60		 pushad

; 338  : 
; 339  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_InvalidTSS@@9@9

; 340  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 341  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 342  : 
; 343  : 		popad

  0000f	61		 popad

; 344  : 		iretd

  00010	cf		 iretd
_Halp_ECT_InvalidTSS ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_SegmentNotPresent
_TEXT	SEGMENT
_Halp_ECT_SegmentNotPresent PROC			; COMDAT

; 350  : 	static char *msg = "Halp_ECT_SegmentNotPresent() \r\n";
; 351  : 	_asm {
; 352  : 		pushad

  00000	60		 pushad

; 353  : 
; 354  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_SegmentNotPresent@@9@9

; 355  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 356  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 357  : 
; 358  : 		popad

  0000f	61		 popad

; 359  : 		iretd

  00010	cf		 iretd
_Halp_ECT_SegmentNotPresent ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_StackException
_TEXT	SEGMENT
_Halp_ECT_StackException PROC				; COMDAT

; 365  : 	static char *msg = "Halp_ECT_StackException() \r\n";
; 366  : 	_asm {
; 367  : 		pushad

  00000	60		 pushad

; 368  : 
; 369  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_StackException@@9@9

; 370  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 371  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 372  : 
; 373  : 		popad

  0000f	61		 popad

; 374  : 		iretd

  00010	cf		 iretd
_Halp_ECT_StackException ENDP
_TEXT	ENDS
PUBLIC	??_C@_0CB@LEODENJF@gp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@ ; `string'
_BSS	SEGMENT
?dwESP@?1??Halp_ECT_GeneralProtection@@9@9 DD 01H DUP (?) ; `Halp_ECT_GeneralProtection'::`2'::dwESP
_BSS	ENDS
;	COMDAT ??_C@_0CB@LEODENJF@gp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@
CONST	SEGMENT
??_C@_0CB@LEODENJF@gp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@ DB 'g'
	DB	'p, #1:0x%x, #2:0x%x, #3:0x%x ', 0dH, 0aH, 00H ; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _Halp_ECT_GeneralProtection
_TEXT	SEGMENT
_Halp_ECT_GeneralProtection PROC			; COMDAT

; 380  : 	static char *msg = "Halp_ECT_GeneralProtection() \r\n";
; 381  : 	static int dwESP;
; 382  : 	_asm {
; 383  : 		mov		dwESP, esp

  00000	89 25 00 00 00
	00		 mov	 DWORD PTR ?dwESP@?1??Halp_ECT_GeneralProtection@@9@9, esp

; 384  : 		pushad

  00006	60		 pushad

; 385  : 
; 386  : 		push	msg

  00007	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_GeneralProtection@@9@9

; 387  : 		call	CrtPrintf

  0000d	e8 00 00 00 00	 call	 _CrtPrintf

; 388  : 		add		esp, 4

  00012	83 c4 04	 add	 esp, 4

; 389  : 	}
; 390  : 
; 391  : 	DbgPrint("gp, #1:0x%x, #2:0x%x, #3:0x%x \r\n", *((int *)dwESP+0), *((int *)dwESP+1), *((int *)dwESP+2));

  00015	a1 00 00 00 00	 mov	 eax, DWORD PTR ?dwESP@?1??Halp_ECT_GeneralProtection@@9@9
  0001a	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0001d	51		 push	 ecx
  0001e	8b 15 00 00 00
	00		 mov	 edx, DWORD PTR ?dwESP@?1??Halp_ECT_GeneralProtection@@9@9
  00024	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00027	50		 push	 eax
  00028	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?dwESP@?1??Halp_ECT_GeneralProtection@@9@9
  0002e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00030	52		 push	 edx
  00031	68 00 00 00 00	 push	 OFFSET ??_C@_0CB@LEODENJF@gp?0?5?$CD1?30x?$CFx?0?5?$CD2?30x?$CFx?0?5?$CD3?30x?$CFx?5?$AN?6@
  00036	e8 00 00 00 00	 call	 _CrtPrintf
  0003b	83 c4 10	 add	 esp, 16			; 00000010H
$infinate$1075:

; 392  : 
; 393  : 	_asm {
; 394  : infinate:
; 395  : 		jmp		infinate

  0003e	eb fe		 jmp	 SHORT $infinate$1075

; 396  : 
; 397  : 		popad

  00040	61		 popad

; 398  : 		iretd

  00041	cf		 iretd
_Halp_ECT_GeneralProtection ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_PageFault
_TEXT	SEGMENT
_Halp_ECT_PageFault PROC				; COMDAT

; 404  : 	static char *msg = "Halp_ECT_PageFault() \r\n";
; 405  : 	_asm {
; 406  : 		pushad

  00000	60		 pushad

; 407  : 
; 408  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_PageFault@@9@9

; 409  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 410  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 411  : 
; 412  : 		popad

  0000f	61		 popad

; 413  : 		iretd

  00010	cf		 iretd
_Halp_ECT_PageFault ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_FloatingPointError
_TEXT	SEGMENT
_Halp_ECT_FloatingPointError PROC			; COMDAT

; 419  : 	static char *msg = "Halp_ECT_FloatingPointError() \r\n";
; 420  : 	_asm {
; 421  : 		pushad

  00000	60		 pushad

; 422  : 
; 423  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_FloatingPointError@@9@9

; 424  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 425  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 426  : 
; 427  : 		popad

  0000f	61		 popad

; 428  : 		iretd

  00010	cf		 iretd
_Halp_ECT_FloatingPointError ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_AlignmentCheck
_TEXT	SEGMENT
_Halp_ECT_AlignmentCheck PROC				; COMDAT

; 434  : 	static char *msg = "Halp_ECT_AlignmentCheck() \r\n";
; 435  : 	_asm {
; 436  : 		pushad

  00000	60		 pushad

; 437  : 
; 438  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_AlignmentCheck@@9@9

; 439  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 440  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 441  : 
; 442  : 		popad

  0000f	61		 popad

; 443  : 		iretd

  00010	cf		 iretd
_Halp_ECT_AlignmentCheck ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_ECT_MachineCheck
_TEXT	SEGMENT
_Halp_ECT_MachineCheck PROC				; COMDAT

; 449  : 	static char *msg = "Halp_ECT_MachineCheck() \r\n";
; 450  : 	_asm {
; 451  : 		pushad

  00000	60		 pushad

; 452  : 
; 453  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_ECT_MachineCheck@@9@9

; 454  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 455  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 456  : 
; 457  : 		popad

  0000f	61		 popad

; 458  : 		iretd

  00010	cf		 iretd
_Halp_ECT_MachineCheck ENDP
_TEXT	ENDS
EXTRN	_Kbd_IRQ_Handler:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _Halp_IRQ_Keyboard
_TEXT	SEGMENT
_Halp_IRQ_Keyboard PROC					; COMDAT

; 467  : 	_asm {
; 468  : 		pushad

  00000	60		 pushad

; 469  : 		pushfd

  00001	9c		 pushfd

; 470  : 
; 471  : 		push	ds

  00002	1e		 push	 ds

; 472  : 		push	es

  00003	06		 push	 es

; 473  : 		push	fs

  00004	0f a0		 push	 fs

; 474  : 		push	gs

  00006	0f a8		 push	 gs

; 475  : 
; 476  : 		mov		ax, KERNEL_DS		; change to kernel data segment from user-mode(sometimes) data segment

  00008	66 b8 10 00	 mov	 ax, 16			; 00000010H

; 477  : 		mov		ds, ax

  0000c	66 8e d8	 mov	 ds, ax

; 478  : 		mov		es, ax

  0000f	66 8e c0	 mov	 es, ax

; 479  : 		mov		fs, ax

  00012	66 8e e0	 mov	 fs, ax

; 480  : 		mov		gs, ax

  00015	66 8e e8	 mov	 gs, ax

; 481  : 	} 
; 482  : 
; 483  : 	Kbd_IRQ_Handler();

  00018	e8 00 00 00 00	 call	 _Kbd_IRQ_Handler

; 484  : 	WRITE_PORT_UCHAR((PUCHAR)0x20, 0x20);

  0001d	6a 20		 push	 32			; 00000020H
  0001f	6a 20		 push	 32			; 00000020H
  00021	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00026	83 c4 08	 add	 esp, 8

; 485  : 
; 486  : 	_asm {
; 487  : 		pop		gs

  00029	0f a9		 pop	 gs

; 488  : 		pop		fs

  0002b	0f a1		 pop	 fs

; 489  : 		pop		es

  0002d	07		 pop	 es

; 490  : 		pop		ds

  0002e	1f		 pop	 ds

; 491  : 
; 492  : 		popfd

  0002f	9d		 popfd

; 493  : 		popad

  00030	61		 popad

; 494  : 		iretd

  00031	cf		 iretd
_Halp_IRQ_Keyboard ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_ReqFromSlave8259
_TEXT	SEGMENT
_Halp_IRQ_ReqFromSlave8259 PROC				; COMDAT

; 500  : 	static char *msg = "Halp_IRQ_ReqFromSlave8259() \r\n";
; 501  : 	_asm {
; 502  : 		pushad

  00000	60		 pushad

; 503  : 
; 504  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_ReqFromSlave8259@@9@9

; 505  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 506  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 507  : 
; 508  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 509  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 510  : 
; 511  : 		popad

  00013	61		 popad

; 512  : 		iretd

  00014	cf		 iretd
_Halp_IRQ_ReqFromSlave8259 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_COM2
_TEXT	SEGMENT
_Halp_IRQ_COM2 PROC					; COMDAT

; 518  : 	static char *msg = "Halp_IRQ_COM2() \r\n";
; 519  : 	_asm {
; 520  : 		pushad

  00000	60		 pushad

; 521  : 
; 522  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_COM2@@9@9

; 523  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 524  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 525  : 
; 526  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 527  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 528  : 
; 529  : 		popad

  00013	61		 popad

; 530  : 		iretd

  00014	cf		 iretd
_Halp_IRQ_COM2 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_COM1
_TEXT	SEGMENT
_Halp_IRQ_COM1 PROC					; COMDAT

; 536  : 	static char *msg = "Halp_IRQ_COM1() \r\n";
; 537  : 	_asm {
; 538  : 		pushad

  00000	60		 pushad

; 539  : 
; 540  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_COM1@@9@9

; 541  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 542  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 543  : 
; 544  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 545  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 546  : 
; 547  : 		popad

  00013	61		 popad

; 548  : 		iretd

  00014	cf		 iretd
_Halp_IRQ_COM1 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_LPT2
_TEXT	SEGMENT
_Halp_IRQ_LPT2 PROC					; COMDAT

; 554  : 	static char *msg = "Halp_IRQ_LPT2() \r\n";
; 555  : 	_asm {
; 556  : 		pushad

  00000	60		 pushad

; 557  : 
; 558  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_LPT2@@9@9

; 559  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 560  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 561  : 
; 562  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 563  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 564  : 
; 565  : 		popad

  00013	61		 popad

; 566  : 		iretd

  00014	cf		 iretd
_Halp_IRQ_LPT2 ENDP
_TEXT	ENDS
EXTRN	_Fdd_IRQ_Handler:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _Halp_IRQ_FloppyDisk
_TEXT	SEGMENT
_Halp_IRQ_FloppyDisk PROC				; COMDAT

; 572  : 
; 573  : 	_asm {
; 574  : 		pushad

  00000	60		 pushad

; 575  : 		pushfd

  00001	9c		 pushfd

; 576  : 
; 577  : 		push	ds

  00002	1e		 push	 ds

; 578  : 		push	es

  00003	06		 push	 es

; 579  : 		push	fs

  00004	0f a0		 push	 fs

; 580  : 		push	gs

  00006	0f a8		 push	 gs

; 581  : 
; 582  : 		mov		ax, KERNEL_DS		; change to kernel data segment from user-mode(sometimes) data segment

  00008	66 b8 10 00	 mov	 ax, 16			; 00000010H

; 583  : 		mov		ds, ax

  0000c	66 8e d8	 mov	 ds, ax

; 584  : 		mov		es, ax

  0000f	66 8e c0	 mov	 es, ax

; 585  : 		mov		fs, ax

  00012	66 8e e0	 mov	 fs, ax

; 586  : 		mov		gs, ax

  00015	66 8e e8	 mov	 gs, ax

; 587  : 	}
; 588  : 
; 589  : 	Fdd_IRQ_Handler();

  00018	e8 00 00 00 00	 call	 _Fdd_IRQ_Handler

; 590  : 	WRITE_PORT_UCHAR((PUCHAR)0x20, 0x20);

  0001d	6a 20		 push	 32			; 00000020H
  0001f	6a 20		 push	 32			; 00000020H
  00021	e8 00 00 00 00	 call	 _WRITE_PORT_UCHAR
  00026	83 c4 08	 add	 esp, 8

; 591  : 
; 592  : 
; 593  : 	_asm {
; 594  : 		pop		gs

  00029	0f a9		 pop	 gs

; 595  : 		pop		fs

  0002b	0f a1		 pop	 fs

; 596  : 		pop		es

  0002d	07		 pop	 es

; 597  : 		pop		ds

  0002e	1f		 pop	 ds

; 598  : 
; 599  : 		popfd

  0002f	9d		 popfd

; 600  : 		popad

  00030	61		 popad

; 601  : 		iretd

  00031	cf		 iretd
_Halp_IRQ_FloppyDisk ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_LPT1
_TEXT	SEGMENT
_Halp_IRQ_LPT1 PROC					; COMDAT

; 607  : 	static char *msg = "Halp_IRQ_LPT1() \r\n";
; 608  : 	_asm {
; 609  : 		pushad

  00000	60		 pushad

; 610  : 
; 611  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_LPT1@@9@9

; 612  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 613  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 614  : 
; 615  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 616  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 617  : 
; 618  : 		popad

  00013	61		 popad

; 619  : 		iretd

  00014	cf		 iretd
_Halp_IRQ_LPT1 ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_CMOSClock
_TEXT	SEGMENT
_Halp_IRQ_CMOSClock PROC				; COMDAT

; 625  : 	static char *msg = "Halp_IRQ_CMOSClock() \r\n";
; 626  : 	_asm {
; 627  : 		pushad

  00000	60		 pushad

; 628  : 
; 629  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_CMOSClock@@9@9

; 630  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 631  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 632  : 
; 633  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 634  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 635  : 		out		0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 636  : 
; 637  : 		popad

  00015	61		 popad

; 638  : 		iretd

  00016	cf		 iretd
_Halp_IRQ_CMOSClock ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_VGA
_TEXT	SEGMENT
_Halp_IRQ_VGA PROC					; COMDAT

; 644  : 	static char *msg = "Halp_IRQ_VGA() \r\n";
; 645  : 	_asm {
; 646  : 		pushad

  00000	60		 pushad

; 647  : 
; 648  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_VGA@@9@9

; 649  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 650  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 651  : 
; 652  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 653  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 654  : 		out		0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 655  : 
; 656  : 		popad

  00015	61		 popad

; 657  : 		iretd

  00016	cf		 iretd
_Halp_IRQ_VGA ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_Mouse
_TEXT	SEGMENT
_Halp_IRQ_Mouse PROC					; COMDAT

; 663  : 	static char *msg = "Halp_IRQ_Mouse() \r\n";
; 664  : 	_asm {
; 665  : 		pushad

  00000	60		 pushad

; 666  : 
; 667  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_Mouse@@9@9

; 668  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 669  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 670  : 
; 671  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 672  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 673  : 		out		0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 674  : 
; 675  : 		popad

  00015	61		 popad

; 676  : 		iretd

  00016	cf		 iretd
_Halp_IRQ_Mouse ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_MathCoprocessor
_TEXT	SEGMENT
_Halp_IRQ_MathCoprocessor PROC				; COMDAT

; 682  : 	static char *msg = "Halp_IRQ_MathCoprocessor() \r\n";
; 683  : 	_asm {
; 684  : 		pushad

  00000	60		 pushad

; 685  : 
; 686  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_MathCoprocessor@@9@9

; 687  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 688  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 689  : 
; 690  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 691  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 692  : 		out		0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 693  : 
; 694  : 		popad

  00015	61		 popad

; 695  : 		iretd

  00016	cf		 iretd
_Halp_IRQ_MathCoprocessor ENDP
; Function compile flags: /Odtp /ZI
_TEXT	ENDS
;	COMDAT _Halp_IRQ_HardDrive
_TEXT	SEGMENT
_Halp_IRQ_HardDrive PROC				; COMDAT

; 701  : 	static char *msg = "Halp_IRQ_HardDrive() \r\n";
; 702  : 	_asm {
; 703  : 		pushad

  00000	60		 pushad

; 704  : 
; 705  : 		push	msg

  00001	ff 35 00 00 00
	00		 push	 DWORD PTR ?msg@?1??Halp_IRQ_HardDrive@@9@9

; 706  : 		call	CrtPrintf

  00007	e8 00 00 00 00	 call	 _CrtPrintf

; 707  : 		add		esp, 4

  0000c	83 c4 04	 add	 esp, 4

; 708  : 
; 709  : 		mov		al, 20h

  0000f	b0 20		 mov	 al, 32			; 00000020H

; 710  : 		out		20h, al

  00011	e6 20		 out	 32, al			; 00000020H

; 711  : 		out		0a0h, al

  00013	e6 a0		 out	 160, al			; 000000a0H

; 712  : 
; 713  : 		popad

  00015	61		 popad

; 714  : 		iretd

  00016	cf		 iretd
_Halp_IRQ_HardDrive ENDP
_TEXT	ENDS
EXTRN	_HalpEnableInterrupt:PROC
EXTRN	_memset:PROC
_BSS	SEGMENT
_m_IdtrDesc DF	01H DUP (?)
	ALIGN	8

_m_IdtGate DQ	040H DUP (?)
; Function compile flags: /Odtp /ZI
_BSS	ENDS
;	COMDAT _HalpStartIntService
_TEXT	SEGMENT
_i$ = -4						; size = 4
_HalpStartIntService PROC				; COMDAT

; 785  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 786  : 	int i;
; 787  : 
; 788  : 	//메모리 초기화
; 789  : 	memset(m_IdtGate, 0, MAX_IDT*sizeof(IDT_GATE));

  00009	68 00 02 00 00	 push	 512			; 00000200H
  0000e	6a 00		 push	 0
  00010	68 00 00 00 00	 push	 OFFSET _m_IdtGate
  00015	e8 00 00 00 00	 call	 _memset
  0001a	83 c4 0c	 add	 esp, 12			; 0000000cH

; 790  : 
; 791  : 	//IDT Table 만들기
; 792  : 	for(i=0; i<MAX_IDT; i++) 

  0001d	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _i$[ebp], 0
  00024	eb 09		 jmp	 SHORT $LN6@HalpStartI
$LN5@HalpStartI:
  00026	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00029	83 c0 01	 add	 eax, 1
  0002c	89 45 fc	 mov	 DWORD PTR _i$[ebp], eax
$LN6@HalpStartI:
  0002f	83 7d fc 40	 cmp	 DWORD PTR _i$[ebp], 64	; 00000040H
  00033	0f 8d 01 01 00
	00		 jge	 $LN4@HalpStartI

; 793  : 	{
; 794  : 		if(m_IntHandlers[i].offset == 0)

  00039	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0003c	6b c0 07	 imul	 eax, 7
  0003f	83 b8 01 00 00
	00 00		 cmp	 DWORD PTR _m_IntHandlers[eax+1], 0
  00046	75 05		 jne	 SHORT $LN3@HalpStartI

; 795  : 			break;

  00048	e9 ed 00 00 00	 jmp	 $LN4@HalpStartI
$LN3@HalpStartI:

; 796  : 		if((m_IntHandlers[i].type & IDTC_TASKGATE) == IDTC_TASKGATE){

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00050	6b c0 07	 imul	 eax, 7
  00053	0f b7 88 05 00
	00 00		 movzx	 ecx, WORD PTR _m_IntHandlers[eax+5]
  0005a	81 e1 00 05 00
	00		 and	 ecx, 1280		; 00000500H
  00060	81 f9 00 05 00
	00		 cmp	 ecx, 1280		; 00000500H
  00066	75 49		 jne	 SHORT $LN2@HalpStartI

; 797  : 			m_IdtGate[m_IntHandlers[i].number].selector		= (WORD)(m_IntHandlers[i].offset);

  00068	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0006b	6b c0 07	 imul	 eax, 7
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00071	6b c9 07	 imul	 ecx, 7
  00074	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _m_IntHandlers[ecx]
  0007b	66 8b 80 01 00
	00 00		 mov	 ax, WORD PTR _m_IntHandlers[eax+1]
  00082	66 89 04 d5 02
	00 00 00	 mov	 WORD PTR _m_IdtGate[edx*8+2], ax

; 798  : 			m_IdtGate[m_IntHandlers[i].number].type			= m_IntHandlers[i].type;

  0008a	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  0008d	6b c0 07	 imul	 eax, 7
  00090	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  00093	6b c9 07	 imul	 ecx, 7
  00096	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _m_IntHandlers[ecx]
  0009d	66 8b 80 05 00
	00 00		 mov	 ax, WORD PTR _m_IntHandlers[eax+5]
  000a4	66 89 04 d5 04
	00 00 00	 mov	 WORD PTR _m_IdtGate[edx*8+4], ax

; 799  : 			
; 800  : 		}
; 801  : 		else{

  000ac	e9 84 00 00 00	 jmp	 $LN1@HalpStartI
$LN2@HalpStartI:

; 802  : 			m_IdtGate[m_IntHandlers[i].number].selector		= KERNEL_CS;

  000b1	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000b4	6b c0 07	 imul	 eax, 7
  000b7	0f b6 88 00 00
	00 00		 movzx	 ecx, BYTE PTR _m_IntHandlers[eax]
  000be	66 c7 04 cd 02
	00 00 00 08 00	 mov	 WORD PTR _m_IdtGate[ecx*8+2], 8

; 803  : 			m_IdtGate[m_IntHandlers[i].number].type			= m_IntHandlers[i].type;

  000c8	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000cb	6b c0 07	 imul	 eax, 7
  000ce	8b 4d fc	 mov	 ecx, DWORD PTR _i$[ebp]
  000d1	6b c9 07	 imul	 ecx, 7
  000d4	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR _m_IntHandlers[ecx]
  000db	66 8b 80 05 00
	00 00		 mov	 ax, WORD PTR _m_IntHandlers[eax+5]
  000e2	66 89 04 d5 04
	00 00 00	 mov	 WORD PTR _m_IdtGate[edx*8+4], ax

; 804  : 			m_IdtGate[m_IntHandlers[i].number].offset_high	= (WORD)(m_IntHandlers[i].offset >> 16);

  000ea	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  000ed	6b c0 07	 imul	 eax, 7
  000f0	8b 88 01 00 00
	00		 mov	 ecx, DWORD PTR _m_IntHandlers[eax+1]
  000f6	c1 f9 10	 sar	 ecx, 16			; 00000010H
  000f9	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  000fc	6b d2 07	 imul	 edx, 7
  000ff	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _m_IntHandlers[edx]
  00106	66 89 0c c5 06
	00 00 00	 mov	 WORD PTR _m_IdtGate[eax*8+6], cx

; 805  : 			m_IdtGate[m_IntHandlers[i].number].offset_low	= (WORD)(m_IntHandlers[i].offset & 0xffff);

  0010e	8b 45 fc	 mov	 eax, DWORD PTR _i$[ebp]
  00111	6b c0 07	 imul	 eax, 7
  00114	8b 88 01 00 00
	00		 mov	 ecx, DWORD PTR _m_IntHandlers[eax+1]
  0011a	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00120	8b 55 fc	 mov	 edx, DWORD PTR _i$[ebp]
  00123	6b d2 07	 imul	 edx, 7
  00126	0f b6 82 00 00
	00 00		 movzx	 eax, BYTE PTR _m_IntHandlers[edx]
  0012d	66 89 0c c5 00
	00 00 00	 mov	 WORD PTR _m_IdtGate[eax*8], cx
$LN1@HalpStartI:

; 806  : 		}
; 807  : 	}

  00135	e9 ec fe ff ff	 jmp	 $LN5@HalpStartI
$LN4@HalpStartI:

; 808  : 
; 809  : 	//IDTR 설정
; 810  : 	//IDT크기와 시작 Physical Address 설정 
; 811  : 	m_IdtrDesc.address	= (int)&m_IdtGate;

  0013a	c7 05 02 00 00
	00 00 00 00 00	 mov	 DWORD PTR _m_IdtrDesc+2, OFFSET _m_IdtGate

; 812  : 	m_IdtrDesc.size		= (WORD)(MAX_IDT*sizeof(IDT_GATE));

  00144	66 c7 05 00 00
	00 00 00 02	 mov	 WORD PTR _m_IdtrDesc, 512 ; 00000200H

; 813  : 	//IDTR 포인터를 HalpEnableInterrupt로 전달 -> CPU가 IDT 테이블을 인식
; 814  : 	HalpEnableInterrupt((PIDTR_DESC)&m_IdtrDesc);

  0014d	68 00 00 00 00	 push	 OFFSET _m_IdtrDesc
  00152	e8 00 00 00 00	 call	 _HalpEnableInterrupt
  00157	83 c4 04	 add	 esp, 4

; 815  : 
; 816  : 	return TRUE;

  0015a	b8 01 00 00 00	 mov	 eax, 1

; 817  : }

  0015f	5f		 pop	 edi
  00160	5e		 pop	 esi
  00161	5b		 pop	 ebx
  00162	8b e5		 mov	 esp, ebp
  00164	5d		 pop	 ebp
  00165	c3		 ret	 0
_HalpStartIntService ENDP
_TEXT	ENDS
PUBLIC	_HalSetupTaskSwitchingEnv
PUBLIC	_HalSetupTSS
EXTRN	_SysGetSyscallStackPtr:PROC
EXTRN	_SysGetSyscallStackSize:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT _HalSetupTSS
_TEXT	SEGMENT
_stack$ = -8						; size = 4
_dwEFLAGS$ = -4						; size = 4
_pTss32$ = 8						; size = 4
_IsKernelTSS$ = 12					; size = 4
_EntryPoint$ = 16					; size = 4
_pStackBase$ = 20					; size = 4
_StackSize$ = 24					; size = 4
_HalSetupTSS PROC					; COMDAT

; 825  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 48	 sub	 esp, 72			; 00000048H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 826  : 	DWORD dwEFLAGS;
; 827  : 	int stack = (int)pStackBase + StackSize - 1;

  00009	8b 45 18	 mov	 eax, DWORD PTR _StackSize$[ebp]
  0000c	8b 4d 14	 mov	 ecx, DWORD PTR _pStackBase$[ebp]
  0000f	8d 54 01 ff	 lea	 edx, DWORD PTR [ecx+eax-1]
  00013	89 55 f8	 mov	 DWORD PTR _stack$[ebp], edx

; 828  : 
; 829  : 	memset(pTss32, NULL, sizeof(TSS_32));

  00016	6a 68		 push	 104			; 00000068H
  00018	6a 00		 push	 0
  0001a	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0001d	50		 push	 eax
  0001e	e8 00 00 00 00	 call	 _memset
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 830  : 
; 831  : 	_asm{
; 832  : 		push	eax

  00026	50		 push	 eax

; 833  : 
; 834  : 		pushfd

  00027	9c		 pushfd

; 835  : 		pop		eax

  00028	58		 pop	 eax

; 836  : 		or		ah, 02h		; IF

  00029	80 cc 02	 or	 ah, 2

; 837  : 		mov		dwEFLAGS, eax

  0002c	89 45 fc	 mov	 DWORD PTR _dwEFLAGS$[ebp], eax

; 838  : 
; 839  : 		pop		eax

  0002f	58		 pop	 eax

; 840  : 	}
; 841  : 
; 842  : 	if(IsKernelTSS){

  00030	83 7d 0c 00	 cmp	 DWORD PTR _IsKernelTSS$[ebp], 0
  00034	74 1d		 je	 SHORT $LN2@HalSetupTS

; 843  : 		pTss32->cs			= KERNEL_CS;

  00036	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00039	66 c7 40 4c 08
	00		 mov	 WORD PTR [eax+76], 8

; 844  : 		pTss32->ds			= KERNEL_DS;

  0003f	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00042	66 c7 40 54 10
	00		 mov	 WORD PTR [eax+84], 16	; 00000010H

; 845  : 		pTss32->ss			= KERNEL_SS;

  00048	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0004b	66 c7 40 50 10
	00		 mov	 WORD PTR [eax+80], 16	; 00000010H

; 846  : 	} else{

  00051	eb 1b		 jmp	 SHORT $LN1@HalSetupTS
$LN2@HalSetupTS:

; 847  : 		pTss32->cs			= USER_CS;

  00053	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00056	66 c7 40 4c 1b
	00		 mov	 WORD PTR [eax+76], 27	; 0000001bH

; 848  : 		pTss32->ds			= USER_DS;

  0005c	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0005f	66 c7 40 54 23
	00		 mov	 WORD PTR [eax+84], 35	; 00000023H

; 849  : 		pTss32->ss			= USER_SS;

  00065	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00068	66 c7 40 50 23
	00		 mov	 WORD PTR [eax+80], 35	; 00000023H
$LN1@HalSetupTS:

; 850  : 	}
; 851  : 	pTss32->es				= pTss32->ds;

  0006e	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00071	8b 4d 08	 mov	 ecx, DWORD PTR _pTss32$[ebp]
  00074	66 8b 51 54	 mov	 dx, WORD PTR [ecx+84]
  00078	66 89 50 48	 mov	 WORD PTR [eax+72], dx

; 852  : 	pTss32->fs				= pTss32->ds;

  0007c	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0007f	8b 4d 08	 mov	 ecx, DWORD PTR _pTss32$[ebp]
  00082	66 8b 51 54	 mov	 dx, WORD PTR [ecx+84]
  00086	66 89 50 58	 mov	 WORD PTR [eax+88], dx

; 853  : 	pTss32->gs				= pTss32->ds;

  0008a	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0008d	8b 4d 08	 mov	 ecx, DWORD PTR _pTss32$[ebp]
  00090	66 8b 51 54	 mov	 dx, WORD PTR [ecx+84]
  00094	66 89 50 5c	 mov	 WORD PTR [eax+92], dx

; 854  : 
; 855  : 	pTss32->eflags			= dwEFLAGS;

  00098	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0009b	8b 4d fc	 mov	 ecx, DWORD PTR _dwEFLAGS$[ebp]
  0009e	89 48 24	 mov	 DWORD PTR [eax+36], ecx

; 856  : 	pTss32->eip				= EntryPoint;

  000a1	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  000a4	8b 4d 10	 mov	 ecx, DWORD PTR _EntryPoint$[ebp]
  000a7	89 48 20	 mov	 DWORD PTR [eax+32], ecx

; 857  : 	pTss32->esp				= (DWORD)stack;

  000aa	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  000ad	8b 4d f8	 mov	 ecx, DWORD PTR _stack$[ebp]
  000b0	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 858  : 
; 859  : 	pTss32->ss0				= KERNEL_SS;

  000b3	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  000b6	66 c7 40 08 10
	00		 mov	 WORD PTR [eax+8], 16	; 00000010H

; 860  : 	pTss32->esp0			= ((DWORD)((BYTE *)SysGetSyscallStackPtr)+SysGetSyscallStackSize()-1);

  000bc	e8 00 00 00 00	 call	 _SysGetSyscallStackSize
  000c1	05 00 00 00 00	 add	 eax, OFFSET _SysGetSyscallStackPtr
  000c6	83 e8 01	 sub	 eax, 1
  000c9	8b 4d 08	 mov	 ecx, DWORD PTR _pTss32$[ebp]
  000cc	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 861  : 
; 862  : 	HalSetupTaskSwitchingEnv(pTss32);

  000cf	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  000d2	50		 push	 eax
  000d3	e8 00 00 00 00	 call	 _HalSetupTaskSwitchingEnv
  000d8	83 c4 04	 add	 esp, 4

; 863  : 
; 864  : 	return TRUE;

  000db	b8 01 00 00 00	 mov	 eax, 1

; 865  : }

  000e0	5f		 pop	 edi
  000e1	5e		 pop	 esi
  000e2	5b		 pop	 ebx
  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c3		 ret	 0
_HalSetupTSS ENDP
_TEXT	ENDS
PUBLIC	_HalChangeTssBusyBit
; Function compile flags: /Odtp /ZI
;	COMDAT _HalSetupTaskSwitchingEnv
_TEXT	SEGMENT
_stack$ = -4						; size = 4
_pTss32$ = 8						; size = 4
_HalSetupTaskSwitchingEnv PROC				; COMDAT

; 868  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 44	 sub	 esp, 68			; 00000044H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 869  : 	int stack;
; 870  : 
; 871  : ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 872  : 	stack = pTss32->esp;

  0000b	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0000e	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00011	89 4d fc	 mov	 DWORD PTR _stack$[ebp], ecx

; 873  : 	stack -= sizeof(int);

  00014	8b 45 fc	 mov	 eax, DWORD PTR _stack$[ebp]
  00017	83 e8 04	 sub	 eax, 4
  0001a	89 45 fc	 mov	 DWORD PTR _stack$[ebp], eax

; 874  : 	*((int *)stack) = pTss32->eflags;

  0001d	8b 45 fc	 mov	 eax, DWORD PTR _stack$[ebp]
  00020	8b 4d 08	 mov	 ecx, DWORD PTR _pTss32$[ebp]
  00023	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00026	89 10		 mov	 DWORD PTR [eax], edx

; 875  : 	stack -= sizeof(int);

  00028	8b 45 fc	 mov	 eax, DWORD PTR _stack$[ebp]
  0002b	83 e8 04	 sub	 eax, 4
  0002e	89 45 fc	 mov	 DWORD PTR _stack$[ebp], eax

; 876  : 	*((int *)stack) = pTss32->cs;

  00031	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00034	0f b7 48 4c	 movzx	 ecx, WORD PTR [eax+76]
  00038	8b 55 fc	 mov	 edx, DWORD PTR _stack$[ebp]
  0003b	89 0a		 mov	 DWORD PTR [edx], ecx

; 877  : 	stack -= sizeof(int);

  0003d	8b 45 fc	 mov	 eax, DWORD PTR _stack$[ebp]
  00040	83 e8 04	 sub	 eax, 4
  00043	89 45 fc	 mov	 DWORD PTR _stack$[ebp], eax

; 878  : 	*((int *)stack) = pTss32->eip;

  00046	8b 45 fc	 mov	 eax, DWORD PTR _stack$[ebp]
  00049	8b 4d 08	 mov	 ecx, DWORD PTR _pTss32$[ebp]
  0004c	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0004f	89 10		 mov	 DWORD PTR [eax], edx

; 879  : 	pTss32->esp = stack;

  00051	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00054	8b 4d fc	 mov	 ecx, DWORD PTR _stack$[ebp]
  00057	89 48 38	 mov	 DWORD PTR [eax+56], ecx

; 880  : EXIT_CRITICAL_SECTION();

  0005a	9d		 popfd

; 881  : 
; 882  : 	HalChangeTssBusyBit(TASK_SW_SEG, TRUE);

  0005b	6a 01		 push	 1
  0005d	6a 28		 push	 40			; 00000028H
  0005f	e8 00 00 00 00	 call	 _HalChangeTssBusyBit
  00064	83 c4 08	 add	 esp, 8

; 883  : 
; 884  : 	return TRUE;

  00067	b8 01 00 00 00	 mov	 eax, 1

; 885  : }

  0006c	5f		 pop	 edi
  0006d	5e		 pop	 esi
  0006e	5b		 pop	 ebx
  0006f	8b e5		 mov	 esp, ebp
  00071	5d		 pop	 ebp
  00072	c3		 ret	 0
_HalSetupTaskSwitchingEnv ENDP
_TEXT	ENDS
EXTRN	_m_GdtTable:BYTE
; Function compile flags: /Odtp /ZI
;	COMDAT _HalChangeTssBusyBit
_TEXT	SEGMENT
_TssSeg$ = 8						; size = 2
_SetBit$ = 12						; size = 4
_HalChangeTssBusyBit PROC				; COMDAT

; 888  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 889  : ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 890  : 	if(SetBit){

  0000b	83 7d 0c 00	 cmp	 DWORD PTR _SetBit$[ebp], 0
  0000f	74 02		 je	 SHORT $LN2@HalChangeT

; 891  : 		m_GdtTable[TssSeg>>3].type != 0x02;
; 892  : 	} else{

  00011	eb 23		 jmp	 SHORT $LN1@HalChangeT
$LN2@HalChangeT:

; 893  : 		m_GdtTable[TssSeg>>3].type &= 0xfd;

  00013	0f b7 45 08	 movzx	 eax, WORD PTR _TssSeg$[ebp]
  00017	c1 f8 03	 sar	 eax, 3
  0001a	0f b6 0c c5 05
	00 00 00	 movzx	 ecx, BYTE PTR _m_GdtTable[eax*8+5]
  00022	81 e1 fd 00 00
	00		 and	 ecx, 253		; 000000fdH
  00028	0f b7 55 08	 movzx	 edx, WORD PTR _TssSeg$[ebp]
  0002c	c1 fa 03	 sar	 edx, 3
  0002f	88 0c d5 05 00
	00 00		 mov	 BYTE PTR _m_GdtTable[edx*8+5], cl
$LN1@HalChangeT:

; 894  : 	}
; 895  : EXIT_CRITICAL_SECTION();

  00036	9d		 popfd

; 896  : }

  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c3		 ret	 0
_HalChangeTssBusyBit ENDP
_TEXT	ENDS
PUBLIC	_HalSetupTaskLink
; Function compile flags: /Odtp /ZI
;	COMDAT _HalSetupTaskLink
_TEXT	SEGMENT
_pTss32$ = 8						; size = 4
_TaskLink$ = 12						; size = 2
_HalSetupTaskLink PROC					; COMDAT

; 899  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 900  : ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 901  : 	pTss32->eflags != 0x4000;
; 902  : 	pTss32->prev_task_link = TaskLink;

  0000b	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  0000e	66 8b 4d 0c	 mov	 cx, WORD PTR _TaskLink$[ebp]
  00012	66 89 08	 mov	 WORD PTR [eax], cx

; 903  : EXIT_CRITICAL_SECTION();

  00015	9d		 popfd

; 904  : 
; 905  : 	return TRUE;

  00016	b8 01 00 00 00	 mov	 eax, 1

; 906  : }

  0001b	5f		 pop	 edi
  0001c	5e		 pop	 esi
  0001d	5b		 pop	 ebx
  0001e	8b e5		 mov	 esp, ebp
  00020	5d		 pop	 ebp
  00021	c3		 ret	 0
_HalSetupTaskLink ENDP
_TEXT	ENDS
PUBLIC	_HalWriteTssIntoGdt
; Function compile flags: /Odtp /ZI
;	COMDAT _HalWriteTssIntoGdt
_TEXT	SEGMENT
_pTss32$ = 8						; size = 4
_TssSize$ = 12						; size = 4
_TssNumber$ = 16					; size = 4
_SetBusy$ = 20						; size = 4
_HalWriteTssIntoGdt PROC				; COMDAT

; 909  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H
  00006	53		 push	 ebx
  00007	56		 push	 esi
  00008	57		 push	 edi

; 910  : ENTER_CRITICAL_SECTION();

  00009	9c		 pushfd
  0000a	fa		 cli

; 911  : 	m_GdtTable[TssNumber>>3].limit_1	= (BYTE)(TssSize & 0x000000ff);

  0000b	8b 45 0c	 mov	 eax, DWORD PTR _TssSize$[ebp]
  0000e	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00013	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  00016	c1 e9 03	 shr	 ecx, 3
  00019	88 04 cd 00 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8], al

; 912  : 	m_GdtTable[TssNumber>>3].limit_2	= (BYTE)((TssSize & 0x0000ff00) >> 8);

  00020	8b 45 0c	 mov	 eax, DWORD PTR _TssSize$[ebp]
  00023	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00028	c1 e8 08	 shr	 eax, 8
  0002b	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  0002e	c1 e9 03	 shr	 ecx, 3
  00031	88 04 cd 01 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+1], al

; 913  : 	m_GdtTable[TssNumber>>3].glimit_3	= (BYTE)((TssSize & 0x000f0000) >> 16);

  00038	8b 45 0c	 mov	 eax, DWORD PTR _TssSize$[ebp]
  0003b	25 00 00 0f 00	 and	 eax, 983040		; 000f0000H
  00040	c1 e8 10	 shr	 eax, 16			; 00000010H
  00043	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  00046	c1 e9 03	 shr	 ecx, 3
  00049	88 04 cd 06 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+6], al

; 914  : 	m_GdtTable[TssNumber>>3].base_1		= (BYTE)(((int)pTss32) & 0x000000ff);

  00050	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00053	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00058	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  0005b	c1 e9 03	 shr	 ecx, 3
  0005e	88 04 cd 02 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+2], al

; 915  : 	m_GdtTable[TssNumber>>3].base_2		= (BYTE)((((int)pTss32) & 0x0000ff00) >> 8);

  00065	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00068	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  0006d	c1 f8 08	 sar	 eax, 8
  00070	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  00073	c1 e9 03	 shr	 ecx, 3
  00076	88 04 cd 03 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+3], al

; 916  : 	m_GdtTable[TssNumber>>3].base_3		= (BYTE)((((int)pTss32) & 0x00ff0000) >> 16);

  0007d	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00080	25 00 00 ff 00	 and	 eax, 16711680		; 00ff0000H
  00085	c1 f8 10	 sar	 eax, 16			; 00000010H
  00088	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  0008b	c1 e9 03	 shr	 ecx, 3
  0008e	88 04 cd 04 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+4], al

; 917  : 	m_GdtTable[TssNumber>>3].base_4		= (BYTE)((((int)pTss32) & 0xff000000) >> 24);

  00095	8b 45 08	 mov	 eax, DWORD PTR _pTss32$[ebp]
  00098	25 00 00 00 ff	 and	 eax, -16777216		; ff000000H
  0009d	c1 e8 18	 shr	 eax, 24			; 00000018H
  000a0	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  000a3	c1 e9 03	 shr	 ecx, 3
  000a6	88 04 cd 07 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+7], al

; 918  : 	m_GdtTable[TssNumber>>3].type		= (SetBusy ? 0x8b : 0x89);

  000ad	33 c0		 xor	 eax, eax
  000af	83 7d 14 00	 cmp	 DWORD PTR _SetBusy$[ebp], 0
  000b3	0f 95 c0	 setne	 al
  000b6	8d 84 00 89 00
	00 00		 lea	 eax, DWORD PTR [eax+eax+137]
  000bd	8b 4d 10	 mov	 ecx, DWORD PTR _TssNumber$[ebp]
  000c0	c1 e9 03	 shr	 ecx, 3
  000c3	88 04 cd 05 00
	00 00		 mov	 BYTE PTR _m_GdtTable[ecx*8+5], al

; 919  : EXIT_CRITICAL_SECTION();

  000ca	9d		 popfd

; 920  : 
; 921  : 	return TRUE;

  000cb	b8 01 00 00 00	 mov	 eax, 1

; 922  : }

  000d0	5f		 pop	 edi
  000d1	5e		 pop	 esi
  000d2	5b		 pop	 ebx
  000d3	8b e5		 mov	 esp, ebp
  000d5	5d		 pop	 ebp
  000d6	c3		 ret	 0
_HalWriteTssIntoGdt ENDP
_TEXT	ENDS
END
